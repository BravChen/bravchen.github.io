'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/posts/','title':"博客",'content':"记录我的博客笔记\n"});index.add({'id':1,'href':'/posts/flex0001/','title':"Flex 布局教程：语法篇",'content':"作者： 阮一峰\n日期： 2015年7月10日\n 网页布局（layout）是 CSS 的一个重点应用。\n布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。\n2009年，W3C 提出了一种新的方案\u0026mdash;-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。\nFlex 布局将成为未来布局的首选方案。本文介绍它的语法，下一篇文章给出常见布局的 Flex 写法。网友 JailBreak 为本文的所有示例制作了 Demo，也可以参考。\n以下内容主要参考了下面两篇文章：A Complete Guide to Flexbox 和 A Visual Guide to CSS3 Flexbox Properties。\n一、Flex 布局是什么？ #  Flex 是 Flexible Box 的缩写，意为\u0026quot;弹性布局\u0026rdquo;，用来为盒状模型提供最大的灵活性。\n任何一个容器都可以指定为 Flex 布局。\n.box{ display: flex; } 行内元素也可以使用 Flex 布局。\n.box{ display: inline-flex; } Webkit 内核的浏览器，必须加上-webkit前缀。\n.box{ display: -webkit-flex; /* Safari */ display: flex; } 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。\n二、基本概念 #  采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\u0026quot;容器\u0026rdquo;。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\u0026quot;项目\u0026rdquo;。\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。\n项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。\n三、父容器的属性 #  以下6个属性设置在父容器上。\n flex-direction flex-wrap flex-flow justify-content align-items align-content  3.1 flex-direction属性 #  flex-direction属性决定主轴的方向（即项目的排列方向）。\n.box { flex-direction: row | row-reverse | column | column-reverse; } 它可能有4个值。\n row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。  3.2 flex-wrap属性 #  默认情况下，项目都排在一条线（又称\u0026quot;轴线\u0026rdquo;）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\n.box{ flex-wrap: nowrap | wrap | wrap-reverse; } 它可能取三个值。\n（1）nowrap（默认）：不换行。\n（2）wrap：换行，第一行在上方。\n（3）wrap-reverse：换行，第一行在下方。\n3.3 flex-flow #  flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\n.box { flex-flow: \u0026lt;flex-direction\u0026gt; || \u0026lt;flex-wrap\u0026gt;; } 3.4 justify-content属性 #  justify-content属性定义了项目在主轴上的对齐方式。\n.box { justify-content: flex-start | flex-end | center | space-between | space-around; } 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。  3.5 align-items属性 #  align-items属性定义项目在交叉轴上如何对齐。\n.box { align-items: flex-start | flex-end | center | baseline | stretch; } baseline 属性图示\n它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。  3.6 align-content属性 #  align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n.box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } 该属性可能取6个值。\n flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。  四、子元素的属性 #  以下6个属性设置在子元素上。\n order flex-grow flex-shrink flex-basis flex align-self  4.1 order属性 #  order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n.item { order: \u0026lt;integer\u0026gt;; } 4.2 flex-grow属性 #  flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n.item { flex-grow: \u0026lt;number\u0026gt;; /* default 0 */ } 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n4.3 flex-shrink属性 #  flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n.item { flex-shrink: \u0026lt;number\u0026gt;; /* default 1 */ } 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n负值对该属性无效。\n4.4 flex-basis属性 #  flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n.item { flex-basis: \u0026lt;length\u0026gt; | auto; /* default auto */ } 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。\n4.5 flex属性 #  flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n.item { flex: none | [ \u0026lt;\u0026#39;flex-grow\u0026#39;\u0026gt; \u0026lt;\u0026#39;flex-shrink\u0026#39;\u0026gt;? || \u0026lt;\u0026#39;flex-basis\u0026#39;\u0026gt; ] } 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n4.6 align-self属性 #  align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n.item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 该属性可能取6个值，除了auto，其他都与 align-items 属性完全一致。\n（完）\n  本文转载自：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\n版权声明：自由转载-非商用-非衍生-保持署名创意共享3.0许可证\n发表日期： 2015年7月10日\n "});index.add({'id':2,'href':'/history/2019-10-10-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E7%AE%80%E8%AE%B0/','title':"多人博客项目(简记)",'content':"Vue-Cli #  安装 #  可以使用下列任一命令安装这个新的包\nnpm install -g @vue/cli # OR yarn global add @vue/cli 安装后使用，以下命令查看版本\nvue --version  官方文档：Vue-Cli 安装\n 使用 Vue-2.x 模板 #  作用：使用旧版的 Vue 功能\nVue CLI \u0026gt;= 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具：\nnpm install -g @vue/cli-init # `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同 vue init webpack my-project 当前目录创建项目 #  执行以下命令，在当前目录下创建\nvue init webpack .  官方文档：拉取-2-x-模板-旧版本\n less预处理器 #  在项目根目录执行以下命令安装 less 预处理器\nnpm install -D less-loader less  官方文档：引用静态资源\n Element-UI #  npm 安装 #  推荐使用 npm 的方式安装，它能更好地和 webpack 打包工具配合使用。\nnpm i element-ui -S CDN #  目前可以通过 unpkg.com/element-ui 获取到最新版本的资源，在页面上引入 js 和 css 文件即可开始使用。\n\u0026lt;!-- 引入样式 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/element-ui/lib/theme-chalk/index.css\u0026#34;\u0026gt; \u0026lt;!-- 引入组件库 --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/element-ui/lib/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 在文件中引入：\nimport ElementUI from \u0026#39;element-ui\u0026#39;; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;; Vue.use(ElementUI);  官方文档：Element-UI\n 添加 Vuex #  作用：Vuex 主要用于同步不同模块之间的公共数据\n安装 #  NPM\nnpm install vuex --save Yarn\nyarn add vuex  官方文档：Vuex 安装\n 引入 #  import Vue from \u0026#39;vue\u0026#39; import Vuex from \u0026#39;vuex\u0026#39; Vue.use(Vuex) markdown 插件 #  安装\nnpm i marked --save 将 markdown 数据转换为 html 格式\n\u0026lt;section class=\u0026#34;article\u0026#34; v-html=\u0026#34;markdown\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; Vue 语句 #  绑定数据\n\u0026lt;img :src=\u0026#34;user.avatar\u0026#34; :alt=\u0026#34;user.username\u0026#34;\u0026gt; \u0026lt;router-link :to=\u0026#34;`/user/${user.id}`\u0026#34;\u0026gt;用户名称\u0026lt;/router-link\u0026gt; 数据转换为html格式\n\u0026lt;section class=\u0026#34;article\u0026#34; v-html=\u0026#34;markdown\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; input 输入框回车事件\n\u0026lt;input @keyup.enter=\u0026#34;onLogin\u0026#34; v-model=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; placeholder=\u0026#34;请输入密码\u0026#34;\u0026gt; 防止 @click 事件冒泡\n\u0026lt;router-link @click.prevent=\u0026#34;onDelete(blog.id)\u0026#34;\u0026gt;删除\u0026lt;/router-link\u0026gt; 预加载数据\nexport default { data() { return { } }, created() { }, computed: { } } router #  获取\n// 获取用户id案例 this.$route.params.blogId 链接\n\u0026lt;router-link to=\u0026#34;/register\u0026#34;\u0026gt;注册\u0026lt;/router-link\u0026gt; 页面跳转\nthis.$router.push({ path: `/detail/${res.data.id}`}) for in 循环获取数据\n\u0026lt;router-link class=\u0026#34;item\u0026#34; v-for=\u0026#34;blog in blogs\u0026#34; :to=\u0026#34;`/detail/${blog.id}`\u0026#34; :key=\u0026#34;blog.id\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt;  注意此处需要绑定 key 的值\n Element-UI 语句 #  绑定事件\n\u0026lt;el-link @click=\u0026#34;onLogout\u0026#34; :underline=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;/el-link\u0026gt; \u0026lt;el-button size=\u0026#34;medium\u0026#34; type=\u0026#34;primary\u0026#34; plain @click=\u0026#34;onCreate\u0026#34;\u0026gt;确定\u0026lt;/el-button\u0026gt; 多行输入框\n\u0026lt;el-input type=\u0026#34;textarea\u0026#34; :autosize=\u0026#34;{ minRows: 2, maxRows: 10}\u0026#34; placeholder=\u0026#34;请输入内容\u0026#34; v-model=\u0026#34;description\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt;  minRows 最小高度(行) maxRows 最大高度(行)\n 多页面切换按钮\n\u0026lt;el-pagination background :current-page.sync=\u0026#34;page\u0026#34; layout=\u0026#34;prev, pager, next\u0026#34; :total=\u0026#34;total\u0026#34; @current-change=\u0026#34;onPagesChange\u0026#34;\u0026gt; \u0026lt;/el-pagination\u0026gt; axios 的使用 #  import axios from \u0026#39;axios\u0026#39; /* 请求的数据类型约定 */ axios.defaults.headers.post[\u0026#39;Content-Type\u0026#39;] = \u0026#39;application/x-www-form-urlencoded\u0026#39; /* 后端接口域名地址(设置后请求时就可以不用写这部分 URL) */ axios.defaults.baseURL = \u0026#39;https://blog-server.hunger-valley.com\u0026#39; /* 前后端分离的项目，前端后端是在不同的服务器上，会涉及到跨域(默认情况跨域请求是不带 Cookie 数据的) * 此处设置异步请求(跨域)带 Cookie 数据 -- */ axios.defaults.withCredentials = true "});index.add({'id':3,'href':'/history/2019-09-15-keyboard-nav/','title':"键盘导航",'content':"键盘导航 #  案例预览：xxx\n代码链接：xxx\n使用的API #  Element #  创建标签\nelement = document.createElement(\u0026#39;div\u0026#39;) 追加到布局中\nelement.appendChild(divs) 在元素中追加文本\nelement.textContent = \u0026#34;Hi\u0026#34; 给元素设置class样式\nelement.className = \u0026#39;demo\u0026#39; 监听整个文档的键盘事件\nelement.onkeypress = event handling code // 实例 document.onkeypress = function(x){ console.log(x) } 获取当前事件的元素\nelement.onclick = function(e){ console.log(e.target) // e.target 即当前元素 } 获取上一个兄弟节点\nelement.previousSibling\r浏览器地址 #  修改浏览器当前地址栏的地址\nlocation.href = \u0026#39;http://xxx.com\u0026#39; 在新窗口打开地址\nwindow.open(\u0026#39;http://xxx.com\u0026#39;, \u0026#39;_blank\u0026#39;) 语法\nwindow.open(地址, 打开方式) LocalStorage #  在 localStorage 中存储一个哈希\nlet keyValue = JSON.stringify(hash) //存储的值需要转换  localStorage.setItem(keyName, keyValue) 在 localStorage 中读取一个哈希\nlocalStorage.getItem(keyName); // 通过名称获取值  getItem()表示根据键名返回键的值\n JSON #  解析 JSON 格式的字符串\nJSON.parse() 案例：\nvar json = \u0026#39;{\u0026#34;result\u0026#34;:true, \u0026#34;count\u0026#34;:42}\u0026#39;; obj = JSON.parse(json); 将一个JavaScript值 (对象或者数组) 转换为一个 JSON字符串\nJSON.stringify(value) // value 表示 JavaScript值 (对象或者数组) 事件错误处理函数 #  error 事件的事件处理程序。针对各种目标的不同类型的错误触发了 Error 事件：\n当一项资源（如img 或 script）加载失败，加载资源的元素会触发一个Event接口的error事件，并执行该元素上的onerror()处理函数。这些error事件不会向上冒泡到window，不过（至少在Firefox中）能被单一的window.addEventListener捕获。\n案例：\nimg.onerror = function(e){ e.target.src = \u0026#39;images.png\u0026#39; } // 当获取图片的值错误时则执行 onerror 后的函数 封装函数 #  创建元素\nfunction tag(tagName){ return document.createElement(tagName) } 创建元素并添加属性\nfunction tag(tagName, attributes){ let element = document.createElement(tagName) for(let key in attributes){ element[key] = attributes[key] } return element } // 调用这个函数 tag(\u0026#39;div\u0026#39;,{ className: \u0026#39;row\u0026#39;, textContent: \u0026#39;Hi\u0026#39;}) return 多个值\nfunction myFunction(){ let keys = 1 let hash = 2 return { \u0026#39;keys\u0026#39;: keys, \u0026#39;hash\u0026#39;: hash } } // 调用 let demo = myFunction() demo.keys demo.hash CSS属性 #  将元素的文本内容字母变为大写\ntext-transform: uppercase;\r背景图片布局\nbody { background: url(../img/rs-cover.jpg); /* 背景图片水平居中，垂直居中 */ background-position: center center; /* 盖住我当前div的所有面积，按比例缩放。大概就是按照div的比例缩放的意思 */ background-size: cover; } 使用的工具 #  在线图片压缩：https://compressjpeg.com/zh/\n"});index.add({'id':4,'href':'/history/2019-09-14-canvas/','title':"Canvas画板",'content':"画板案例 #  使用的单词 #   dot ——— n.点，小圆点； drawLine ——— n. 画直线； circle ——— n. 圆, 圆周; 圈, 环状物；  Canvas 大小自适应 #  设置自适应窗口的 Canvas 画板大小\n首先获取浏览器窗口当前最大化时的宽高\nlet pageWidth = window.screen.availWidth let pageHeight = window.screen.availHeight 使用 window 窗口改变事件处理函数，每次窗口改变都执行一次 将当前画布记录下来放到一个变量中，然后重置画布大小为窗口最大化的大小，再将当前画布的放回去，这样即时调整画布也不会重置 canvas 的内容，并且调整窗口不会显示滚动条。\n代码如下：\nlet canvas = document.querySelector(\u0026#39;#draw\u0026#39;) let context = canvas.getContext(\u0026#39;2d\u0026#39;) autoSetCanvasSize() /* 设置画板大小自适应 */ function autoSetCanvasSize(){ let pageWidth = window.screen.availWidth let pageHeight = window.screen.availHeight canvas.width = pageWidth canvas.height = pageHeight let backups = context.getImageData(0, 0, canvas.width, canvas.height) window.onresize = function(){ backups = context.getImageData(0, 0, canvas.width, canvas.height) canvas.width = pageWidth canvas.height = pageHeight context.putImageData(backups, 0, 0) } } 也可以使用 addEventListener，如\nwindow.addEventListener(\u0026#39;resize\u0026#39;,function(){ SetCanvasSize() }) 或 jQuery ，如\n// 每当当前窗口大小改变时 $(window).resize(function(){ console.log($(window).height()) console.log($(document).height()) }) 画点函数 #  /* 画点函数 */ function drawDot(x, y, radius){ context.beginPath() context.fillStyle = \u0026#39;#333333\u0026#39;; context.arc(x, y, radius, 0, Math.PI*2) context.fill() // 描边 } 画线函数 #  /* 画线函数 */ function drawLine(x1, y1, x2, y2, width){ context.beginPath(); context.strokeStyle = \u0026#39;black\u0026#39; context.moveTo(x1, y1); context.lineWidth = width context.lineTo(x2, y2); context.stroke(); } 组成画线函数 #  canvas.onmousedown = function (a) { let top = a.target.offsetTop let left = a.target.offsetLeft painting = true let x = a.clientX - left let y = a.clientY - top lastPoint = {\u0026#39;x\u0026#39;:x, \u0026#39;y\u0026#39;:y} drawDot(x, y, 1) } canvas.onmousemove = function(a){ if(painting){ let top = a.target.offsetTop let left = a.target.offsetLeft let x = a.clientX - left let y = a.clientY - top let newPoint = {\u0026#39;x\u0026#39;:x, \u0026#39;y\u0026#39;:y} drawDot(x, y, 1) drawLine(lastPoint.x, lastPoint.y, newPoint.x, newPoint.y) lastPoint = newPoint } } canvas.onmouseup = function(){ painting = false } 设置点击其他地方关闭浮层 #  Html\n\u0026lt;style\u0026gt; .popover { width: 100px; height: 100px; position: absolute; top: 8px; left: 52px; background-color: #ccc; } \u0026lt;/style\u0026gt; \u0026lt;div id=\u0026#34;wrapper\u0026#34; class=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;clickMe\u0026#34;\u0026gt;点我\u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;popover\u0026#34; class=\u0026#34;popover\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34;\u0026gt;选我 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; JS\nlet $ = (element)=\u0026gt;{ return document.querySelector(element)} let popover = $(\u0026#39;#popover\u0026#39;) let clickMe = $(\u0026#39;#clickMe\u0026#39;) let wrapper = $(\u0026#39;#wrapper\u0026#39;) let open = true clickMe.addEventListener(\u0026#39;click\u0026#39;, function(e){ open = !open open ? popover.style.display = \u0026#39;block\u0026#39; : popover.style.display = \u0026#39;none\u0026#39; /* if(open){ popover.style.display = \u0026#39;block\u0026#39; }else { popover.style.display = \u0026#39;none\u0026#39; } */ }) wrapper.addEventListener(\u0026#39;click\u0026#39;, function(e){ e.stopPropagation() /* 阻断事件冒泡 */ }) document.addEventListener(\u0026#39;click\u0026#39;, function(){ popover.style.display = \u0026#39;none\u0026#39; open = false }) 使用到的API #  获取 #  获取元素 #  通过 id 获取元素\ndocument.getElementById(Id) 通过标签获取元素\nelement.getElementsByTagName(\u0026#39;div\u0026#39;) 通过选择器获取元素\nelement.querySelector(\u0026#39;div \u0026gt; h2\u0026#39;) 获取坐标 #  语法\n获取鼠标点击元素时的X轴、Y轴坐标 ( 此处坐标与元素的位置无关，只与鼠标位置有关 )\nMouseEvent.clientX // 只读 鼠标指针在点击元素（DOM）中的X坐标。 MouseEvent.clientY // 只读 鼠标指针在点击元素（DOM）中的Y坐标。 获取当前事件元素距离屏幕顶部的距离X轴、Y轴坐标\nelement.offsetTop; element.offsetLeft 案例\n获取鼠标坐标\nelement.onmousedown = function(t){ let x = t.clientX let y = t.clientY console.log(\u0026#39;x:\u0026#39;+x) console.log(\u0026#39;y:\u0026#39;+y) } 获取当前事件的元素距离屏幕的距离\nelement.onmousedown = function(t){ let top = a.target.offsetTop let left = a.target.offsetLeft }  缺点：对移动版浏览器兼容性较差\n 获取网页当前视窗宽高 #  语法\n这个属性是只读属性，如果没有定义CSS或者内联布局盒子的元素为0。该属性包括内边距，但不包括垂直滚动条（如果有）、边框和外边距。\nvar Width = element.clientWidth; var Height = element.clientHeight; 案例\nvar pageWidth = document.documentElement.clientWidth // 当前视窗宽度 var pageHeight = document.documentElement.clientHeight // 当前视窗高度 获取浏览器窗口当前最大化时的宽高 #  语法\n返回浏览器窗口可占用的水平宽度 / 高度\nwindow.screen.availWidth window.screen.availHeight 案例\nlet pageWidth = window.screen.availWidth let pageHeight = window.screen.availHeight 添加 #  追加class样式\nelement.classList.add(\u0026#39;active\u0026#39;) 删除class样式\nelement.classList.remove(\u0026#39;active\u0026#39;) 鼠标事件 #  鼠标按下 #  element.onmousedown = function(){} 鼠标移动 #  element.onmousemove = function(){} 鼠标松开 #  element.onmouseup = function(){} 触屏设备 #  给网页添加 meta 标签\n判断是否支持触屏\nGoogle 搜索：js detech touch support\n如果获取该事件的值为 null 说明支持该事件，如果获取该事件的值的 undefined 说明不支持该事件。通过这种方法就可以添加 if 判断来区分是否支持触屏\n如：\ndocument.body.ontouchstart // 如果为 null 则是存在，如果为 undefined则是不存在 // 所以可以用if判断 if(document.body.ontouchstart !== undefined){则为触屏设备} 也可以通过 in 判断：\n\u0026#39;ontouchstart\u0026#39; in document.body // 如果支持就是 true 不支持就是 false 手指按下 #  canvas.ontouchstart = function(){ console.log(\u0026#39;开始触摸屏幕\u0026#39;) } 手指移动 #  canvas.ontouchmove = function(){ console.log(\u0026#39;触摸并移动\u0026#39;) } 手指抬起 #  canvas.ontouchend = function(){ console.log(\u0026#39;抬起手指\u0026#39;) } 获取触摸坐标\n由于移动设备可能会支持多点触控，所以它们的坐标属性会有多个，例如\ncanvas.ontouchstart = function(x){ console.log(a.touches[0].clientX) /* x坐标 */ } Canvas #  画一个矩形 #  语法 #  // 绘制一个填充的矩形 fillRect(x, y, width, height) // 绘制一个矩形的边框 strokeRect(x, y, width, height) // 清除指定矩形区域，让清除部分完全透明。 clearRect(x, y, width, height) // 建立一个 2D 渲染背景的上下文 canvas.getContext(\u0026#39;2d\u0026#39;); 填充案例 #  const canvas = document.getElementById(\u0026#39;canvas\u0026#39;); const context = canvas.getContext(\u0026#39;2d\u0026#39;); context.fillStyle = \u0026#39;green\u0026#39;; context.fillRect(10, 10, 150, 100);  rect 是 rectangle 的缩写\n Js Bin 链接：https://jsbin.com/lerukuhero/1/edit?html,js,output\n描边案例 #  const canvas = document.getElementById(\u0026#39;canvas\u0026#39;); const context = canvas.getContext(\u0026#39;2d\u0026#39;); context.strokeStyle = \u0026#39;green\u0026#39;; // 边框颜色，设置要在 fillRect 前 context.strokeRect(10, 10, 150, 100);  stroke 一画, 一笔\n Js Bin 链接：https://jsbin.com/nizalababo/1/edit?html,js,output\n清除案例 #  const canvas = document.getElementById(\u0026#39;demo\u0026#39;); const context = canvas.getContext(\u0026#39;2d\u0026#39;); context.fillStyle = \u0026#39;green\u0026#39;; context.fillRect(10, 10, 150, 100); context.clearRect(20, 20, 50, 50) Js Bin 链接：https://jsbin.com/zumiqeceno/edit?html,js,output\n画线 #  语法 #  beginPath() //新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。 closePath() //闭合路径之后图形绘制命令又重新指向到上下文中。 stroke() //通过线条来绘制图形轮廓。 fill() //通过填充路径的内容区域生成实心的图形。 lineWidth //线宽 案例 #  let canvas = document.getElementById(\u0026#39;xxx\u0026#39;); let context = canvas.getContext(\u0026#39;2d\u0026#39;); context.beginPath(); context.strokeStyle = \u0026#39;black\u0026#39; context.moveTo(5, 5); context.lineWidth = 5 context.lineTo(100, 5); context.stroke(); Js Bin 链接：http://js.jirengu.com/qepamorena/1/edit\n画一个三角形 #  let canvas = document.getElementById(\u0026#39;canvas\u0026#39;); let context = canvas.getContext(\u0026#39;2d\u0026#39;); context.beginPath(); // 开始画 context.moveTo(75, 50); // 画笔起始位置 context.lineTo(100, 75); // 第一笔画到的位置 context.lineTo(100, 25); // 第二笔画到的位置 context.fill(); // 填充 案例链接：http://js.jirengu.com/denawusato/3/edit?html,css,js,output\n画弧线 #  语法 #  arc(x, y, radius, startAngle, endAngle, anticlockwise)  前两个值为圆心的坐标，第三个值是圆心的半径，最后两个值分别表示起始度数和结束度数 (这里的度数都是以Π为单位)\n 画一个圆 #  let canvas = document.getElementById(\u0026#39;canvas\u0026#39;) let context = canvas.getContext(\u0026#39;2d\u0026#39;) context.beginPath() context.arc(150, 150, 50, 0, Math.PI*2) context.stroke() // 描边 案例链接：http://js.jirengu.com/vigaqibequ/4/edit\n画图形分别可以用两种方式结尾：描边 context.stroke(); ，填充 context.fill();\nCSS样式 #  屏幕的高度\nheight: 100vh;  vh 是 viewport height 的简称\n 动画\ntransform: scale(1.2); /* 放大1.2倍 */ transition: all 0.3s; /* 动画平滑过渡 0.3秒 */ "});index.add({'id':5,'href':'/history/2019-08-28-%E5%AE%89%E5%8D%93%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E6%A1%88%E4%BE%8B/','title':"安卓音乐播放器案例",'content':"搭建环境 #  首先新建一个git仓库，然后初始化\ngit init 然后再初始化一个配置文件，用于打包工具\nnpm init -y 安装需要的组件：\nnpm install --save-dev parcel-bundler 创建需要的目录文件：\n  dist\n  src\n js scss svg    index.html\n  在 src 中创建一个 js 文件和 scss 文件并在主页引入：\nscss文件写法：\n$color1: #ececec; $color2: #ff0000; body { background-color: color1; h2 { color: color2; } } 然后开一个测试服务器，命令：\nnpx parcel index.html 将代码自动编译到待发布的 dist 文件夹：\nnpx parcel build index.html 如果运行上面的命令有这样的报错：\nxxx: Error in parsing SVG: Unbound namespa ce prefix: \u0026#34;xlink\u0026#34; 那就给 html 页面的 svg 标签加上一个xmlns:xlink=\u0026quot;http://www.w3.org/1999/xlink\u0026quot;属性，如下：\n\u0026lt;svg class=\u0026#34;icon\u0026#34; xmlns:xlink=\u0026#34;http://www.w3.org/1999/xlink\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;use xlink:href=\u0026#34;#icon-like-1\u0026#34;\u0026gt;\u0026lt;/use\u0026gt; \u0026lt;/svg\u0026gt; 注意：上传到 GitHub 时要执行这句代码，来更改路径问题，不然 GitHub 预览没有效果\nnpx parcel build index.html --public-url ./  更改之前删除之前的 dist 文件夹\n 制作静态页面 #  scss 写法总结：\n表示 div 的 class 名称为 demo 的样式：\ndiv { \u0026amp;.demo { color: red; } } 水平垂直居中\ndisplay: flex; justify-content: center; align-items: center; 动画一直转圈圈：\ndiv { animation: rotate 10s linear infinite; /*分别表示 动画名称 时间 过渡形式(此处线性) 动画不停止*/ } div { animation: rotate 10s linear infinite reverse; /*分别表示 动画名称 时间 过渡形式(此处线性) 动画不停止 动画倒放*/ } @keyframes rotate { 0% { transform: rotate(0) } 100% { transform: rotate(360deg) } } svg的使用 #  svg文件在 html 页面中引入：\n\u0026lt;div class=\u0026#34;xxa\u0026#34;\u0026gt; \u0026lt;svg\u0026gt; \u0026lt;use xlink:href=\u0026#34;#xxx\u0026#34;\u0026gt;\u0026lt;/use\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/div\u0026gt; svg文件合并\n\u0026lt; ?xml\u0026gt; \u0026lt;svg\u0026gt; \u0026lt;symbol id=\u0026#34;xxx\u0026#34;\u0026gt; \u0026lt;g\u0026gt;xxx\u0026lt;/g\u0026gt; \u0026lt;/symbol\u0026gt; \u0026lt;/svg\u0026gt; js文件：\nlet svgxxx = document.createElement(\u0026#39;div\u0026#39;) svgxxx.style.position=\u0026#34;absolute\u0026#34; svgxxx.style.width = 0 svgxxx.style.height = 0 svgxxx.style.overflow = \u0026#34;hidden\u0026#34; // svgxxx.style.display = \u0026#34;none\u0026#34; document.body.appendChild(svgxxx) svgxxx.innerHTML = `\u0026lt;?xml\u0026gt; svg内容xxx` js方式引入svg：\nimport \u0026#39;./icon.js\u0026#39; //import \u0026#39;./刚刚的js文件路径\u0026#39; 高度计算值\nbody { height: calc(100vh - 260px); }  注：括号中的计算必须有空格\n 获取元素简写：\nfunction $(){ return document.querySelector(selector) } //简写 const $ = selector =\u0026gt; document.querySelector(selector) JS结构\nclass Player { constructor(node) { } bind() { } } 等价于\nfunction Player() { } Player.prototype.bind = function() { } 在网页上扒歌词文件 #  以网易云音乐为例，打开一首歌曲的播放页面，然后打开控制台\n选择 Network 在搜索框的一栏选择 AII 然后搜索 lyric ，如图\n保持控制台开启并刷新网页，就会出现一个歌词文件，右键这个歌词文件\n选择 copy 在二级菜单选择 copy response\n然后新建一个json文件粘贴刚刚复制的内容即可，如图\n音乐播放相关操作 #  开始，暂停，上一曲，下一曲，\n开始播放 #  首先 new 一个音频播放对象\nthis.audio = new Audio() 之后就可以使用 this.audio 来调用\nAudio() 自带了以下方法\n"});index.add({'id':6,'href':'/docs/','title':"转载",'content':"记录一些转载好文\n"});index.add({'id':7,'href':'/posts/flex0002/','title':"Flex 布局教程：实例篇",'content':"作者： 阮一峰\n日期： 2015年7月14日\n 上一篇文章介绍了Flex布局的语法，今天介绍常见布局的Flex写法。\n你会看到，不管是什么布局，Flex往往都可以几行命令搞定。\n我只列出代码，详细的语法解释请查阅《Flex布局教程：语法篇》。我的主要参考资料是Landon Schropp的文章和Solved by Flexbox。\n一、骰子的布局 #  骰子的一面，最多可以放置9个点。\n下面，就来看看Flex如何实现，从1个点到9个点的布局。你可以到codepen查看Demo。\n如果不加说明，本节的HTML模板一律如下。\n\u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 上面代码中，div元素（代表骰子的一个面）是Flex容器，span元素（代表一个点）是Flex项目。如果有多个项目，就要添加多个span元素，以此类推。\n1.1 单项目 #  首先，只有左上角1个点的情况。Flex布局默认就是首行左对齐，所以一行代码就够了。\n.box { display: flex; } 设置项目的对齐方式，就能实现居中对齐和右对齐。\n.box { display: flex; justify-content: center; } .box { display: flex; justify-content: flex-end; } 设置交叉轴对齐方式，可以垂直移动主轴。\n.box { display: flex; align-items: center; } .box { display: flex; justify-content: center; align-items: center; } .box { display: flex; justify-content: center; align-items: flex-end; } .box { display: flex; justify-content: flex-end; align-items: flex-end; } 1.2 双项目 #  .box { display: flex; justify-content: space-between; } .box { display: flex; flex-direction: column; justify-content: space-between; } .box { display: flex; flex-direction: column; justify-content: space-between; align-items: center; } .box { display: flex; flex-direction: column; justify-content: space-between; align-items: flex-end; } .box { display: flex; } .item:nth-child(2) { align-self: center; } .box { display: flex; justify-content: space-between; } .item:nth-child(2) { align-self: flex-end; } 1.3 三项目 #  .box { display: flex; } .item:nth-child(2) { align-self: center; } .item:nth-child(3) { align-self: flex-end; } 1.4 四项目 #  .box { display: flex; flex-wrap: wrap; justify-content: flex-end; align-content: space-between; } HTML代码如下。\n\u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;column\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;column\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; CSS代码如下。\n.box { display: flex; flex-wrap: wrap; align-content: space-between; } .column { flex-basis: 100%; display: flex; justify-content: space-between; } 1.5 六项目 #  .box { display: flex; flex-wrap: wrap; align-content: space-between; } .box { display: flex; flex-direction: column; flex-wrap: wrap; align-content: space-between; } HTML代码如下。\n\u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; CSS代码如下。\n.box { display: flex; flex-wrap: wrap; } .row{ flex-basis: 100%; display:flex; } .row:nth-child(2){ justify-content: center; } .row:nth-child(3){ justify-content: space-between; } 1.6 九项目 #  .box { display: flex; flex-wrap: wrap; } 二、网格布局 #  2.1 基本网格布局 #  最简单的网格布局，就是平均分布。在容器里面平均分配空间，跟上面的骰子布局很像，但是需要设置项目的自动缩放。\nHTML代码如下。\n\u0026lt;div class=\u0026#34;Grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;Grid-cell\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;Grid-cell\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;Grid-cell\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; CSS代码如下。\n.Grid { display: flex; } .Grid-cell { flex: 1; } 2.2 百分比布局 #  某个网格的宽度为固定的百分比，其余网格平均分配剩余的空间。\nHTML代码如下。\n\u0026lt;div class=\u0026#34;Grid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;Grid-cell u-1of4\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;Grid-cell\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;Grid-cell u-1of3\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; .Grid { display: flex; } .Grid-cell { flex: 1; } .Grid-cell.u-full { flex: 0 0 100%; } .Grid-cell.u-1of2 { flex: 0 0 50%; } .Grid-cell.u-1of3 { flex: 0 0 33.3333%; } .Grid-cell.u-1of4 { flex: 0 0 25%; } 三、圣杯布局 #  圣杯布局（Holy Grail Layout）指的是一种最常见的网站布局。页面从上到下，分成三个部分：头部（header），躯干（body），尾部（footer）。其中躯干又水平分成三栏，从左到右为：导航、主栏、副栏。\nHTML代码如下。\n\u0026lt;body class=\u0026#34;HolyGrail\u0026#34;\u0026gt; \u0026lt;header\u0026gt;...\u0026lt;/header\u0026gt; \u0026lt;div class=\u0026#34;HolyGrail-body\u0026#34;\u0026gt; \u0026lt;main class=\u0026#34;HolyGrail-content\u0026#34;\u0026gt;...\u0026lt;/main\u0026gt; \u0026lt;nav class=\u0026#34;HolyGrail-nav\u0026#34;\u0026gt;...\u0026lt;/nav\u0026gt; \u0026lt;aside class=\u0026#34;HolyGrail-ads\u0026#34;\u0026gt;...\u0026lt;/aside\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;footer\u0026gt;...\u0026lt;/footer\u0026gt; \u0026lt;/body\u0026gt; CSS代码如下。\n.HolyGrail { display: flex; min-height: 100vh; flex-direction: column; } header, footer { flex: 1; } .HolyGrail-body { display: flex; flex: 1; } .HolyGrail-content { flex: 1; } .HolyGrail-nav, .HolyGrail-ads { /* 两个边栏的宽度设为12em */ flex: 0 0 12em; } .HolyGrail-nav { /* 导航放到最左边 */ order: -1; } 如果是小屏幕，躯干的三栏自动变为垂直叠加。\n@media (max-width: 768px) { .HolyGrail-body { flex-direction: column; flex: 1; } .HolyGrail-nav, .HolyGrail-ads, .HolyGrail-content { flex: auto; } } 四、输入框的布局 #  我们常常需要在输入框的前方添加提示，后方添加按钮。\nHTML代码如下。\n\u0026lt;div class=\u0026#34;InputAddOn\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;InputAddOn-item\u0026#34;\u0026gt;...\u0026lt;/span\u0026gt; \u0026lt;input class=\u0026#34;InputAddOn-field\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;InputAddOn-item\u0026#34;\u0026gt;...\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; CSS代码如下。\n.InputAddOn { display: flex; } .InputAddOn-field { flex: 1; } 五、悬挂式布局 #  有时，主栏的左侧或右侧，需要添加一个图片栏。\nHTML代码如下。\n\u0026lt;div class=\u0026#34;Media\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;Media-figure\u0026#34; src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;Media-body\u0026#34;\u0026gt;...\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; CSS代码如下。\n.Media { display: flex; align-items: flex-start; } .Media-figure { margin-right: 1em; } .Media-body { flex: 1; } 六、固定的底栏 #  有时，页面内容太少，无法占满一屏的高度，底栏就会抬高到页面的中间。这时可以采用Flex布局，让底栏总是出现在页面的底部。\nHTML代码如下。\n\u0026lt;body class=\u0026#34;Site\u0026#34;\u0026gt; \u0026lt;header\u0026gt;...\u0026lt;/header\u0026gt; \u0026lt;main class=\u0026#34;Site-content\u0026#34;\u0026gt;...\u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt;...\u0026lt;/footer\u0026gt; \u0026lt;/body\u0026gt; CSS代码如下。\n.Site { display: flex; min-height: 100vh; flex-direction: column; } .Site-content { flex: 1; } 七，流式布局 #  每行的项目数固定，会自动分行。\nCSS的写法。\n.parent { width: 200px; height: 150px; background-color: black; display: flex; flex-flow: row wrap; align-content: flex-start; } .child { box-sizing: border-box; background-color: white; flex: 0 0 25%; height: 50px; border: 1px solid red; } （完）\n文档信息 #   版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证） 发表日期： 2015年7月14日   本文转载自：http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\n "});index.add({'id':8,'href':'/posts/2020-02-08-%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87and%E6%96%B9%E6%B3%95/','title':"学习目标and方法",'content':"学习的内因，外因 #  外因 #    关注前端的人比 Java Python 少多了\n  学习前端的人少，但是公司的需求并不少\n  前端工资高\n  内因 #    对前端有兴趣\n  希望自己的工作是可积累的\n  希望自己的工作是有挑战性的\n  三个忠告 #  忠告一 #  遗忘曲线：学习任何东西你都会忘掉，所以你需要记笔记和回顾\n 总结：每次学习新知识后不间断的复习3-4天\n 忠告二 #  你不可能一年就学会写文章\n多抄一些优秀的代码\n多使用 百度、Google 搜索\n看到三遍以上看不懂的内容，说明遇到了知识的诅咒\n 总结：编程就像写文章，你需要临摹很多人的代码，才能原创一小段自己的代码\n 忠告三 #  Done is better than Perfect\n做出来优于做到完美，不要在一开始就追求完美。\n 总结：先做出来，再追求完美去完善\n "});index.add({'id':9,'href':'/history/2019-12-12-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95%E7%B3%96%E7%AE%80%E7%89%88/','title':"函数与对象的语法糖(索引)",'content':"函数与对象的语法糖 #   函数默认参数  与 Python 的区别 http://effbot.org/zone/default-values.htm   剩余参数  Array.prototype.slice.call(arguments,2) Array.from(arguments).slice(2) function fn (a,b, \u0026hellip;c){}   展开操作  [\u0026hellip;iterableObj] = [1, 3, 5, 7, 9]; [0, 2, \u0026hellip;iterableObj, 4, 6, 8];   解构赋值  [a, b] = [b, a] [a, b, \u0026hellip;rest] = [10, 20, 30, 40, 50] let {name, age} = frank [a=5, b=7] = [1]; [a, b] = f() [a, , b] = f(); {p: foo, q: bar} = o let {a = 10, b = 5} = {a: 3}; let {a:aa = 10, b:bb = 5} = {a: 3}; 对象浅拷贝 对象合并 MDN 上更多的例子   对象属性加强  obj = { x, y } obj = {[\u0026ldquo;baz\u0026rdquo; + quux() ]: 42} 函数属性可以缩写    新的字符串 #    多行字符串\n  字符串里插入变量（插值）\n  函数接字符串\nfn`${name} 是一个 ${person}`\rstyled-component 就是用的这个语法\n  "});index.add({'id':10,'href':'/history/','title':"历史",'content':"用于存放历史博客\n"});index.add({'id':11,'href':'/history/2019-12-01-function-object-sugar/','title':"函数与对象的语法糖一",'content':"或语法(||) #  传参案例 #  function sum(a, b){ console.log(b) return a+b } console.log(\u0026#39;返回值：\u0026#39;+sum(1)) 此时 b 的值是 undefined ，所以结果是 NaN 无法相加，打出的 b 为 undefined\n为了避免这种情况，可以使用以下写法：\nES6写法 #  如果 a 或 b === undefined，则等于 0 。相当于未传值时的默认值为 0\nfunction sum(a=0, b=0){ return a+b }  其中 a=0 相当于 if(a===undefined){ a=0 }，b 同理\n ES6之前的写法 #  如果 b 为真，则 b = b 否则 b = 0 ，a 同理\nfunction sum(a, b){ a = a || 0 b = b || 0 return a+b }  其中 b = b || 0 相当于 if(b){ b = b }else{ b = 0 }\n JS与Python添加数组的区别 #  JS\n每次添加都会重新初始化一个数组\nfunction push(item, array=[]){ array.push(item) return array } console.log(push(1)) // 输出: \u0026gt;[1] console.log(push(2)) // 输出: \u0026gt;[2] Python\n只会初始化一次数组\ndef fn(item, array=[]) array.append(item) return array fn(1) # 输出 [1] fn(2) # 输出 [1, 2] 剩余参数 #  1. 之前的JS写法 #  如果函数需要传入多个未知数量的参数：\nfunction sum(){ let result = 0 for(let i=0;i\u0026lt;arguments.length;i++){ result += arguments[i] } return result } sum(1,2,3,4,5,6,7,8,9,10) // 输出: 55 2. 参数区分 #  如果在传入的多个参数前加一个前缀的参数，可以用以下写法：\nfunction sum(message){ let result = 0 for(let i=1;i\u0026lt;arguments.length;i++){ result += arguments[i] } return message + result } sum(\u0026#39;结果是: \u0026#39;,1,2,3,4,5,6,7,8,9,10) // 输出: // 结果是: 55 上面的写法就是从第二个参数开始循环将每个参数相加，最后再与第一个参数相加\n3. ES6 参数区分 #  ES6 中使用了更简洁的参数区分的写法\nfunction sum(message, ...numbers){ let result = 0 for(let i=0;i\u0026lt;numbers.length;i++){ result += numbers[i] } return message + result } sum(\u0026#39;结果是: \u0026#39;,1,2,3,4,5,6,7,8,9,10) // 输出: // 结果是: 55 4. ES6 参数区分(简化for循环) #  下面的案例中使用了 .reduce((p,v)=\u0026gt;p+v, 0) 方法简化了 for 循环\nfunction sum(message, ...numbers){ let result = numbers.reduce((p,v)=\u0026gt;p+v, 0) return message + result } sum(\u0026#39;结果是: \u0026#39;,1,2,3,4,5,6,7,8,9,10) // 输出: // 结果是: 55 5. ES6 伪数组转数组 #  function sum(message){ let args = Array.prototype.slice.call(arguments) // ES5中最便捷的数组转换方式  let args = Array.from(arguments) // ES6语法  let args = [...arguments] // ES6语法  let result = numbers.reduce((p,v)=\u0026gt;p+v, 0) return message + result } sum(\u0026#39;结果是: \u0026#39;,1,2,3,4,5,6,7,8,9,10)  伪数组：原型链直接指向对象，只有数组的样子，但是没有数组的方法\n 展开语法(Spread syntax) #  1. 截取数组后半部分内容 #  截取数组后半部分内容组成新的数组\nlet array1 = [1, 2, 3, 4, 5, 6] let [a, b, c, ...array2] = array1 console.log(array2) // 输出 [4, 5, 6] 2. 截取数组后半部分内容(简化) #  简化前面的参数\nlet array1 = [1, 2, 3, 4, 5, 6] let [,,, ...array2] = array1 console.log(array2) // 输出 [4, 5, 6] 3. 数组前后追加项 #  在数组的最前和最后分别追加项\nlet array1 = [1, 2, 3, 4, 5, 6] let array2 = [0, ...array1, 7] console.log(array2) // 输出 [0, 1, 2, 3, 4, 5, 6, 7] 拓展：ES6之前的写法 #  let array1 = [1, 2, 3, 4, 5, 6] let array2 = [0].concat(array1).concat(7) console.log(array2) // 输出 [0, 1, 2, 3, 4, 5, 6, 7] "});index.add({'id':12,'href':'/history/2019-12-01-%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%E4%BA%8C/','title':"函数与对象的语法糖二",'content':"解构赋值 #  a b 值转换 #  let a = 1 let b = 2; [a, b] = [b, a] console.log(a, b)  注：使用这个方法在方括号，或括号前没有内容需要在前面添加一个分号，否则会合并为一行\n 拓展：ES6之前的转换\nlet a = 1 let b = 2 let temp = a a = b b = temp console.log(a, b) 变量批量声明 #  使用数组批量声明变量，a、b表示前两个值 rest 表示后面所有值组成的数组\nlet [a, b, ...rest] = [10, 20, 30, 40, 50] console.log(a, b) console.log(rest) // 输出 // 10 20 // [30, 40, 50]  注：剩余参数(...rest) 只能放在数组最后，否则使用时会产生歧义\n 对象批量赋值 #  let frank = {name: \u0026#39;frank\u0026#39;, age: 18, gender: \u0026#39;Male\u0026#39;} let {name, age, gender} = frank 拓展：ES6之前的写法\nvar frank = {name: \u0026#39;frank\u0026#39;, age: 18, gender: \u0026#39;Male\u0026#39;} var name = frank.name var age = frank.age var gender = frank.gender 变量赋值(默认值) #  数组 #  如果 a 的值为空则为 5，如果 b 的值为空则为 7\nlet [a=5, b=7] = [1, 2] console.log(a, b) // 输出 1 2 a 为空\nlet [a=5, b=7] = [, 2] console.log(a, b) // 输出 5 2 b 为空\nlet [a=5, b=7] = [1] console.log(a, b) // 输出 1 7 a b 都为空\nlet [a=5, b=7] = [] console.log(a, b) // 输出 5 7 函数 #  批量赋值，返回数组批量赋值\nlet f = function(){ return [1, 2] } let [a, b] = f() console.log(a, b) // 输出 1 2 批量赋值，指定位置\nlet f = function(){ return [1, 2, 3] } let [a, , b] = f() console.log(a, b) // 输出 1 3 对象 #  将对象 frank 中的 name1 属性的值赋给 一个新的变量 xingming\nlet frank = { name1: \u0026#39;Jack\u0026#39;, age: 18, gender: \u0026#39;Male\u0026#39; } let {name1: xingming} = frank // 这里的frank是上面的frank对象 console.log(xingming) // 输出 Jack 将对象中的子对象 的属性值 声明\nlet frank = { name: \u0026#39;Jack\u0026#39;, age: 18, gender: \u0026#39;Male\u0026#39;, child: { name: \u0026#39;Tom\u0026#39;, age: 1, gender: \u0026#39;Male\u0026#39; } } let {child: {name}} = frank // 这里的frank是上面的frank对象 console.log(name) // 输出 Tom 子对象的属性 name 存储在为 xingming 的变量中\nlet frank = { name: \u0026#39;Jack\u0026#39;, age: 18, gender: \u0026#39;Male\u0026#39;, child: { name: \u0026#39;Tom\u0026#39;, age: 1, gender: \u0026#39;Male\u0026#39; } } let {child: {name: xingming}} = frank // 这里的frank是上面的frank对象 console.log(xingming) // 输出 综合使用 #  判断 frank 对象中的 子对象 child 中的 name 有没有值，如果存在值，则输出存在的值，如果不存在值则输出 Tom\nlet frank = { name: \u0026#39;Jack\u0026#39;, age: 18, gender: \u0026#39;Male\u0026#39;, child: { name: \u0026#39;Jerry\u0026#39;, age: 1, gender: \u0026#39;Male\u0026#39; } } let {child: {name: xingming = \u0026#39;Tom\u0026#39;, age, gender}} = frank console.log(xingming) console.log(age) console.log(gender) /* 输出： Jerry 1 Male */ 案例 #  对象浅拷贝\nlet objA = {name: \u0026#39;a\u0026#39;} let objB = Object.assign({}, objA) console.log(objB) // 输出 {name: \u0026#34;a\u0026#34;} 浅拷贝的含义\n只拷贝当前对象，对象的属性指向不会拷贝，如下\nlet objA = { name: { x: \u0026#39;a\u0026#39; } } let objB = Object.assign({}, objA) objB.name.x = \u0026#39;b\u0026#39; console.log(objA.name) name 打出的是 B ，拷贝后的对象影响了拷贝前对象的属性的值，这就是浅拷贝\nES6写法\nlet objA = { name: { x: \u0026#39;a\u0026#39; } } let objB = {...objA} console.log(objB) // 输出 {name: { x: \u0026#39;a\u0026#39; }} 对象合并 #  案例1\nlet objA = { p1: 1, p2: 2 } let objB = { p1: 10, p3: 3 } let objC = Object.assign({}, objA, objB) console.log(objC) // 输出: {p1: 10, p2: 2, p3: 3} 简化案例1\nlet objA = { p1: 1, p2: 2 } let objB = { p1: 10, p3: 3 } let objC = {...objA, ...objB} console.log(objC) // 输出: {p1: 10, p2: 2, p3: 3} 函数参数默认值 #  ES5 版本 #  function drawES5Chart(options) { options = options === undefined ? {} : options; var size = options.size === undefined ? \u0026#39;big\u0026#39; : options.size; var cords = options.cords === undefined ? { x: 0, y: 0 } : options.cords; var radius = options.radius === undefined ? 25 : options.radius; console.log(size, cords, radius); // now finally do some chart drawing } drawES5Chart({ cords: { x: 18, y: 30 }, radius: 30 }); ES2015 版本(ES6) #  function drawES2015Chart({size = \u0026#39;big\u0026#39;, cords = { x: 0, y: 0 }, radius = 25} = {}) { console.log(size, cords, radius); // do some chart drawing } drawES2015Chart({ cords: { x: 18, y: 30 }, radius: 30 }); 更清晰的写法\nfunction drawES2015Chart(options = {}){ let {size=25, cords={x:0, y:0}, raidus=25} = options console.log(size) console.log(cords) console.log(raidus) } drawES2015Chart() /* 输出 * 25 * {x: 0, y: 0} * 25 * /  MDN原文链接：函数参数默认值\n 对象属性加强 #  声明对象将变量 x 的值赋给对象 obj 的 x 属性，y 同理\n之前的写法\nlet x = 1 let y = 2 let obj = { x: x, y: y } console.log(obj) ES6写法\nlet x = 1 let y = 2 let obj = {x, y} console.log(obj) ES6写法简化1\nlet [x, y] = [1, 2] let obj = {x, y} console.log(obj) // 输出 {x: 1, y: 2} ES6写法简化2\nlet obj = {x:1 , y:2} let {x, y} = obj console.log(obj) // 输出 {x: 1, y: 2} 对象写法案例\nlet x = 1 let y = 2 let obj1 = {name:1, age:2} let obj2 = { z: 1, x, y, ...obj1, // 引入对象 obj1 中的属性  sayHi(name){}, sayBye(name){}, sayByeBye: function(){} } console.log(obj2) 对象属性名更改 #  通过传入变量更改\nlet key = \u0026#39;x\u0026#39; let value = \u0026#39;y\u0026#39; let obj = {} obj[key] = value console.log(obj) // 输出 {x: \u0026#34;y\u0026#34;} 注：key 属性不能在 obj 对象中直接写入，否则会变为 字符串 \u0026ldquo;key\u0026rdquo;，如下：\nvar obj = { key: value // 错误 } ES6 写法\nlet key = \u0026#39;x\u0026#39; let value = \u0026#39;y\u0026#39; let obj = { [key]: value // 其中[key]为上面的变量key } console.log(obj) // 输出 {x: \u0026#34;y\u0026#34;} 拓展：属性名拼接\nlet key = \u0026#39;x\u0026#39; let value = \u0026#39;y\u0026#39; let obj = { [key + key]: value // 属性key由两个变量key拼接而成(\u0026#39;xx\u0026#39;) } console.log(obj) // 输出 {xx: \u0026#34;y\u0026#34;} 字符串拼接 #  ES6语法\nlet b = \u0026#39;内容\u0026#39; let a = ` \u0026lt;p\u0026gt;${b}\u0026lt;/p\u0026gt; ` console.log(a)  在上面的方括号中添加的所有空格都会被省略\n 历史案例\nlet string = \u0026#34;\u0026lt;div\u0026gt;\\ \u0026lt;p\u0026gt;内容\u0026lt;/p\u0026gt;\\ \u0026lt;/div\u0026gt; \u0026#34; // 结果没有回车  let string2 = \u0026#34;\u0026lt;div\u0026gt;\\ \u0026lt;p\u0026gt;内容\u0026lt;/p\u0026gt;\\ \u0026lt;/div\u0026gt; \u0026#34; // 语法错误 反斜杠后不能加空格  let string3 = \u0026#34;\u0026lt;div\u0026gt;\u0026#34; + \u0026#34;\u0026lt;p\u0026gt;内容\u0026lt;/p\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34; // 结果没有回车  let string4 = ` \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;内容\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ` // 结果包含4个回车 函数接字符串 #  fn`${name}是一个 ${person}` 语法案例\nlet name = \u0026#39;小明\u0026#39; let person = \u0026#39;人\u0026#39; let fn = function(){ console.log(arguments[0]) console.log(arguments[1]) console.log(arguments[2]) } fn`${name}是一个 ${person}` /* 输出： [\u0026#34;\u0026#34;, \u0026#34; 是一个 \u0026#34;, \u0026#34;\u0026#34;, raw: Array(3)] \u0026#34;小明\u0026#34; \u0026#34;人\u0026#34; */ 使用案例\nlet name = \u0026#39;小红\u0026#39; let person = \u0026#39;人\u0026#39; let fn = function(){ let strings = arguments[0] let var1 = arguments[1] let var2 = arguments[2] if(var1 === \u0026#39;小明\u0026#39;){ return var1 + strings[1] + \u0026#39;好人\u0026#39; }else{ return var1 + strings[1] + \u0026#39;坏人\u0026#39; } } fn`${name}是一个 ${person}` console.log(fn`${name}是一个 ${person}`)  用法实例：React 中一个库：styled-component 就是用的这个语法\n "});index.add({'id':13,'href':'/posts/a0000003/','title':"互联网的基石",'content':"WWW 的历史 #  1990年 万维网（World Wide Web）出生的年份。这一年 Tim Berners-Lee 发明了用网址就能访问网页的办法，他发明了第一个网页、第一个浏览器和第一个服务器。\ncurl 命令 #  发请求，同时接收响应\nMarkdown #  Markdown 不是一个被发明的东西，是被人们总结的语法，所以 MarkDown 的语法形式有很多。\nWWW 的发明 #  Tim Berners-Lee（下文中称为李爵士）在 1989 年至 1992 年间，发明了 WWW（World Wide Web），一种适用于全世界的网络。主要包含三个概念\n URI，俗称网址 HTTP，两个电脑之间传输内容的协议 HTML，超级文本，主要用来做页面跳转  URL 的作用是能让你访问一个页面，HTTP 的作用是让你能下载这个页面，HTML 的作用是让你能看懂这个页面。这是一个简单而完美的系统。李爵士除了发明了这些概念，还付诸了行动：\n 发明了第一个服务器 发明了第一个浏览器 写出了第一个网页，地址：info.cern.ch ，注：网站与网页是不同的，网站是有很多网页的，网页只是一个页面。  URI是什么 #  U(统一)R(资源)I(标识符)\nURI 分为 URL 和 URN 两种\nURN #  URN(统一资源名称)\nISBN: 9787115275790 就是一个 URN，通过 URN 你可以确定一个「唯一的」资源，ISBN: 9787115275790 对应的资源的是《JavaScript 高级程序设计（第三版）》这本书。你去是介绍任何一个图书馆、书店，他们都知道是这本书。\nURL #  URL(统一资源定位符)\nbaidu.com (二级域名) 与 www.baidu.com (三级域名) 共有一个二级域名\n以 www.baidu.com 为例\n .com 为顶级域名 baidu 为二级域名 www 为三级域名  DNS #  D(域)N(名)S(系统): 域名系统\n功能\n 输入域名 输出IP  查询域名对应的IP命令\nnslookup baidu.com ping baidu.com 通过DNS服务器解析域名，得到网址\n指定IP #  可以给域名一个指定的IP(绕过DNS自己指定一个IP),例:\n在hosts文件中给百度添加指定域名\n127.0.0.1 baidu.com\r 特殊情况下，可以通过在 hosts 中给谷歌设置指定IP来达到科学的效果(由于设定原因，服务器[电信等网络]可能给你返回一个假的IP)\n本方法不够稳定，因为谷歌的IP会不定时改变\n Server + Client + HTTP #  Server(服务器) Client(客户端) HTTP(协议)\n图示\n常用端口 #    21 端口：FTP服务\n  443 端口：HTTPS\n  1080 端口：代理服务器端口\n  3306 端口：MySQI服务器\n  80 端口：HTTP协议\n  HTTP #  HTTP的作用就是指导浏览器和服务器如何进行沟通，例如\n请求的网址错误：返回404\n请求的服务器不在线(或服务器正在重启)：返回502\nexplainshell.com #  用于解释每个命令的含义\ncurl -s -v -H \u0026#34;Sun: xxx\u0026#34; -- \u0026#34;https://www.baidu.com\u0026#34; -s 不要显示进度条\n-v 显示请求和响应，如果没有这个就只会显示响应\n-H \u0026quot;Sun: xxx\u0026quot; 添加一个响应头\n-- \u0026quot;https://www.baidu.com\u0026quot; 把你要请求的网址写在两个横线后\n请求 #  命令\ncurl -s -v -H \u0026#34;Sun: xxx\u0026#34; -- \u0026#34;https://www.baidu.com\u0026#34; 请求案例：\n其中 \u0026gt; 后的内容是请求的内容 \u0026lt; 后的内容是响应的内容 * 后的内容是注释，可不看\n请求内容中\nGET / HTTP/1.1\rGET 请求方式\r/ 请求路径\rHTTP　请求协议\r1.1 版本号\rHost: www.baidu.com\r告诉服务器我访问的域名\rUser-Agent: curl/7.64.0\r请求/响应使用的工具(软件)以及版本\rAccept: */*\r表示接收请求返回的任何内容\rPOST请求 #  curl -X POST -s -v -H \u0026#34;Sun: xxx\u0026#34; -- \u0026#34;https://www.baidu.com\u0026#34; 请求案例：\n其中 -X POST 表示请求方式为POST\nPOST请求传值\ncurl -X POST -d \u0026#34;123456789\u0026#34; -s -v -H \u0026#34;Sun: xxx\u0026#34; -- \u0026#34;https://www.baidu.com\u0026#34; 请求案例：\n其中\nContent-Length: 9\r请求传入的内容长度\rContent-Type: application/x-www-form-urlencoded\r请求的类型\r# upload completely sent off: 9 out of 9 bytes\r完整的上传了9个字节的数据\r"});index.add({'id':14,'href':'/history/0cd88b5c/','title':"模块化",'content':"MDN 文档\n引入 import：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import\n导出 export：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export\n模块化概念 #  模块：豆腐块\n依赖：用到了\n导出：给别人用\nES6导出模块\nlet data2 = {a: 1, b: 2, c: 3} export default data2 ES6引入模块\nJS中引入（在JS中引入时，必须以 ./data.js 的格式）\nimport data2 from \u0026#39;./data.js\u0026#39; html中引入（在html中引入时，必须添加 type=\u0026quot;module\u0026quot;）\n\u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;./main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 导出指定变量\nlet num = 10 let string = \u0026#39;xxx\u0026#39; let data2 = {a: 1, b: 2, c: 3} export {num, string, data2} JS中引入指定变量\nimport {num, string, data2} from \u0026#39;./data.js\u0026#39; 引入的简写：\nimport * as name from \u0026#39;./data.js\u0026#39; 同时导出/引入两种方式\n导出指定变量\nlet num = 10 let string = \u0026#39;xxx\u0026#39; let data2 = {a: 1, b: 2, c: 3} export {num, string, data2} export default data2 两种方式同时引入\nimport data2, {num, string, data2} from \u0026#39;./data.js\u0026#39; 解决命名冲突\n假如需要引入两个文件 data1.js 和 data2.js\ndata1.js\nlet num = 10 let string = \u0026#39;xxx\u0026#39; let data = {a: 1, b: 2, c: 3} export {num, string, data} export default data1 data2.js\nlet num = 9 let string = \u0026#39;aaa\u0026#39; let data = {a: 11, b: 22, c: 33} export {num, string, data} export default data2 可以在引入时重新命名：\nimport data1, {num as num1, string as string1} from \u0026#39;./data.js\u0026#39; import data2, {num as num2, string as string2} from \u0026#39;./data.js\u0026#39; console.log(num1, num2) console.log(string1, string2) 只使用 import\n在引入的模块中，模块文件的代码会执行，但模块文件中的函数需要调用时才会执行\nimport \u0026#39;./data.js\u0026#39; // 此时data.js 中的代码依然会执行，但函数不能被调用 将导入的 a.js 的所有内容导出\nexport * from \u0026#39;a.js\u0026#39;; export * as name1 \u0026#39;a.js\u0026#39;; // 导出并命名为as "});index.add({'id':15,'href':'/history/2020-04-07-vue%E5%A4%9A%E4%BA%BA%E5%85%B1%E4%BA%AB%E5%8D%9A%E5%AE%A2/','title':"[项目] Vue 多人共享博客",'content':"curl 命令 #  curl -d \u0026#34;请求的参数\u0026#34; -X \u0026#34;请求类型\u0026#34; -i \u0026#34;显示响应头，以及响应体\u0026#34; -b \u0026#34;传入Cookie\u0026#34; curl -d \u0026#34;username=chenning\u0026amp;password=123\u0026#34; -X \u0026#34;http://blog-server.com/auth/register\u0026#34; -i 敏感操作，如创建博客，需要携带用户Cookie\n"});index.add({'id':16,'href':'/docs/javascript%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%E4%B8%80%E6%A8%A1%E5%9D%97%E7%9A%84%E5%86%99%E6%B3%95/','title':"Javascript模块化编程（一）：模块的写法",'content':"作者： 阮一峰\n日期： 2012年10月26日\n随着网站逐渐变成\u0026rdquo;互联网应用程序\u0026quot;，嵌入网页的Javascript代码越来越庞大，越来越复杂。\n\n网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等\u0026hellip;\u0026hellip;开发者不得不使用软件工程的方法，管理网页的业务逻辑。\nJavascript模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。\n但是，Javascript不是一种模块化编程语言，它不支持\u0026rdquo;类\u0026quot;（class），更遑论\u0026quot;模块\u0026rdquo;（module）了。（正在制定中的ECMAScript标准第六版，将正式支持\u0026quot;类\u0026quot;和\u0026quot;模块\u0026rdquo;，但还需要很长时间才能投入实用。）\nJavascript社区做了很多努力，在现有的运行环境中，实现\u0026quot;模块\u0026quot;的效果。本文总结了当前＂Javascript模块化编程＂的最佳实践，说明如何投入实用。虽然这不是初级教程，但是只要稍稍了解Javascript的基本语法，就能看懂。\n一、原始写法\n模块就是实现特定功能的一组方法。\n只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。\nfunction m1(){ //... } function m2(){ //... } 上面的函数m1()和m2()，组成一个模块。使用的时候，直接调用就行了。\n这种做法的缺点很明显：\u0026ldquo;污染\u0026quot;了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。\n二、对象写法\n为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。\nvar module1 = new Object({ _count : 0, m1 : function (){ //...  }, m2 : function (){ //...  } }); 上面的函数m1()和m2(），都封装在module1对象里。使用的时候，就是调用这个对象的属性。\nmodule1.m1(); 但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。\nmodule1._count = 5; 三、立即执行函数写法\n使用\u0026rdquo;立即执行函数\u0026quot;（Immediately-Invoked Function Expression，IIFE），可以达到不暴露私有成员的目的。\nvar module1 = (function(){ var _count = 0; var m1 = function(){ //...  }; var m2 = function(){ //...  }; return { m1 : m1, m2 : m2 }; })(); 使用上面的写法，外部代码无法读取内部的_count变量。\nconsole.info(module1._count); //undefined module1 就是 Javascript 模块的基本写法。下面，再对这种写法进行加工。\n四、放大模式\n如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用\u0026quot;放大模式\u0026rdquo;（augmentation）。\nvar module1 = (function (mod){ mod.m3 = function () { //...  }; return mod; })(module1); 上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。\n五、宽放大模式（Loose augmentation）\n在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用\u0026quot;宽放大模式\u0026rdquo;。\nvar module1 = ( function (mod){ //...  return mod; })(window.module1 || {}); 与\u0026quot;放大模式\u0026quot;相比，＂宽放大模式＂就是\u0026quot;立即执行函数\u0026quot;的参数可以是空对象。\n六、输入全局变量\n独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。\n为了在模块内部调用全局变量，必须显式地将其他变量输入模块。\nvar module1 = (function ($, YAHOO) { //... })(jQuery, YAHOO); 上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。这方面更多的讨论，参见Ben Cherry的著名文章《JavaScript Module Pattern: In-Depth》。\n这个系列的第二部分，将讨论如何在浏览器环境组织不同的模块、管理模块之间的依赖性。\n（完）\n文档信息 #   版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）\n发表日期： 2012年10月26日\n "});index.add({'id':17,'href':'/docs/javascript%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%E4%BA%8Camd%E8%A7%84%E8%8C%83/','title':"Javascript模块化编程（二）：AMD规范",'content':"作者： 阮一峰\n日期： 2012年10月30日\n这个系列的第一部分介绍了Javascript模块的基本写法，今天介绍如何规范地使用模块。\n（接上文）\n七、模块的规范\n先想一想，为什么模块很重要？\n因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。\n但是，这样做有一个前提，那就是大家必须以同样的方式编写模块，否则你有你的写法，我有我的写法，岂不是乱了套！考虑到Javascript模块现在还没有官方规范，这一点就更重要了。\n目前，通行的Javascript模块规范共有两种：CommonJS和AMD。我主要介绍AMD，但是要先从CommonJS讲起。\n八、CommonJS\n2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。\n这标志\u0026quot;Javascript模块化编程\u0026quot;正式诞生。因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。\nnode.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。\n 　var math = require(\u0026lsquo;math\u0026rsquo;);\n 然后，就可以调用模块提供的方法：\n 　var math = require(\u0026lsquo;math\u0026rsquo;);\n　math.add(2,3); // 5\n 因为这个系列主要针对浏览器编程，不涉及node.js，所以对CommonJS就不多做介绍了。我们在这里只要知道，require()用于加载模块就行了。\n九、浏览器环境\n有了服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。\n但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上一节的代码，如果在浏览器中运行，会有一个很大的问题，你能看出来吗？\n 　var math = require(\u0026lsquo;math\u0026rsquo;);\n　math.add(2, 3);\n 第二行math.add(2, 3)，在第一行require(\u0026lsquo;math\u0026rsquo;)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。\n这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于\u0026quot;假死\u0026quot;状态。\n因此，浏览器端的模块，不能采用\u0026quot;同步加载\u0026rdquo;（synchronous），只能采用\u0026quot;异步加载\u0026rdquo;（asynchronous）。这就是AMD规范诞生的背景。\n十、AMD\nAMD是\u0026quot;Asynchronous Module Definition\u0026quot;的缩写，意思就是\u0026quot;异步模块定义\u0026rdquo;。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。\nAMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：\n 　require([module], callback);\n 第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：\n 　require([\u0026lsquo;math\u0026rsquo;], function (math) {\n　math.add(2, 3);\n　});\n math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。\n目前，主要有两个Javascript库实现了AMD规范：require.js和curl.js。本系列的第三部分，将通过介绍require.js，进一步讲解AMD的用法，以及如何将模块化编程投入实战。\n（完）\n文档信息 #   版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证） 发表日期： 2012年10月30日  "});index.add({'id':18,'href':'/docs/javascript%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%E4%B8%89require.js%E7%9A%84%E7%94%A8%E6%B3%95/','title':"Javascript模块化编程（三）：require.js的用法",'content':"作者： 阮一峰\n日期： 2012年11月 7日\n这个系列的第一部分和第二部分，介绍了Javascript模块原型和理论概念，今天介绍如何将它们用于实战。\n我采用的是一个非常流行的库require.js。\n一、为什么要用require.js？\n最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。下面的网页代码，相信很多人都见过。\n\u0026lt;script src=\u0026#34;1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;2.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;3.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;4.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;5.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;6.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 这段代码依次加载多个js文件。\n这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。\nrequire.js的诞生，就是为了解决这两个问题：\n　　（1）实现js文件的异步加载，避免网页失去响应；\n　（2）管理模块之间的依赖性，便于代码的编写和维护。\n二、require.js的加载\n使用require.js的第一步，是先去官方网站下载最新版本。\n下载后，假定把它放在js子目录下面，就可以加载了。\n\u0026lt;script src=\u0026#34;js/require.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 有人可能会想到，加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样：\n\u0026lt;script src=\u0026#34;js/require.js\u0026#34; defer async=\u0026#34;true\u0026#34; \u0026gt;\u0026lt;/script\u0026gt; async 属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。\n加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了：\n\u0026lt;script src=\u0026#34;js/require.js\u0026#34; data-main=\u0026#34;js/main\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; data-main 属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。\n三、主模块的写法\n上一节的main.js，我把它称为\u0026quot;主模块\u0026rdquo;，意思是整个网页的入口代码。它有点像C语言的main()函数，所有代码都从这儿开始运行。\n下面就来看，怎么写main.js。\n如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码。\n// main.js alert(\u0026#34;加载成功！\u0026#34;); 但这样的话，就没必要使用require.js了。真正常见的情况是，主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。\n// main.js require([\u0026#39;moduleA\u0026#39;, \u0026#39;moduleB\u0026#39;, \u0026#39;moduleC\u0026#39;], function (moduleA, moduleB, moduleC){ // some code here }); require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[\u0026lsquo;moduleA\u0026rsquo;, \u0026lsquo;moduleB\u0026rsquo;, \u0026lsquo;moduleC\u0026rsquo;]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。\nrequire()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。\n下面，我们看一个实际的例子。\n假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写：\nrequire([\u0026#39;jquery\u0026#39;, \u0026#39;underscore\u0026#39;, \u0026#39;backbone\u0026#39;], function ($, _, Backbone){ // some code here }); require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。主模块的代码就写在回调函数中。\n四、模块的加载\n上一节最后的示例中，主模块的依赖模块是[\u0026lsquo;jquery\u0026rsquo;, \u0026lsquo;underscore\u0026rsquo;, \u0026lsquo;backbone\u0026rsquo;]。默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。\n使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。\nrequire.config({ paths: { \u0026#34;jquery\u0026#34;: \u0026#34;jquery.min\u0026#34;, \u0026#34;underscore\u0026#34;: \u0026#34;underscore.min\u0026#34;, \u0026#34;backbone\u0026#34;: \u0026#34;backbone.min\u0026#34; } }); 上面的代码给出了三个模块的文件名，路径默认与main.js在同一个目录（js子目录）。如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。\nrequire.config({ paths: { \u0026#34;jquery\u0026#34;: \u0026#34;**lib/**jquery.min\u0026#34;, \u0026#34;underscore\u0026#34;: \u0026#34;**lib/**underscore.min\u0026#34;, \u0026#34;backbone\u0026#34;: \u0026#34;**lib/**backbone.min\u0026#34; } }); 另一种则是直接改变基目录（baseUrl）。\nrequire.config({ **baseUrl: \u0026#34;js/lib\u0026#34;,** paths: { \u0026#34;jquery\u0026#34;: \u0026#34;jquery.min\u0026#34;, \u0026#34;underscore\u0026#34;: \u0026#34;underscore.min\u0026#34;, \u0026#34;backbone\u0026#34;: \u0026#34;backbone.min\u0026#34; } }); 如果某个模块在另一台主机上，也可以直接指定它的网址，比如：\nrequire.config({ paths: { \u0026#34;jquery\u0026#34;: \u0026#34;https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min\u0026#34; } }); require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个优化工具，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。\n五、AMD模块的写法\nrequire.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。\n具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。\n假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写：\n// math.js define(function (){ var add = function (x,y){ return x+y; }; return { add: add }; }); 加载方法如下：\n// main.js require([\u0026#39;math\u0026#39;], function (math){ alert(math.add(1,1)); }); 如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。\ndefine([\u0026#39;myLib\u0026#39;], function(myLib){ function foo(){ myLib.doSomething(); } return { foo : foo }; }); 当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。\n六、加载非规范的模块\n理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？\n回答是可以的。\n这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。\n举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。\nrequire.config({ shim: { \u0026#39;underscore\u0026#39;:{ exports: \u0026#39;_\u0026#39; }, \u0026#39;backbone\u0026#39;: { deps: [\u0026#39;underscore\u0026#39;, \u0026#39;jquery\u0026#39;], exports: \u0026#39;Backbone\u0026#39; } } }); require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。\n比如，jQuery的插件可以这样定义：\nshim: { \u0026#39;jquery.scroll\u0026#39;: { deps: [\u0026#39;jquery\u0026#39;], exports: \u0026#39;jQuery.fn.scroll\u0026#39; } } 七、require.js插件\nrequire.js还提供一系列插件，实现一些特定的功能。\ndomready插件，可以让回调函数在页面DOM结构加载完成后再运行。\nrequire([\u0026#39;domready!\u0026#39;], function (doc){ // called once the DOM is ready }); text和image插件，则是允许require.js加载文本和图片文件。\ndefine([ \u0026#39;text!review.txt\u0026#39;, \u0026#39;image!cat.jpg\u0026#39; ], function(review,cat){ console.log(review); document.body.appendChild(cat); } ); 类似的插件还有json和mdown，用于加载json文件和markdown文件。\n（完）\n文档信息 #   版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证） 发表日期： 2012年11月 7日  "});index.add({'id':19,'href':'/history/2020-03-31-jsonp/','title':"[高级] 35 - JSONP",'content':"数据库 #  只要能够长久的存放数据，就是数据库\n  文件系统是一种数据库 (例: window文件资源管理器)\n  MySQL是一种数据库\n  MySQL的由来 #  My 是作者女儿名字的缩写，SQL 是一种查询语言\n使用到的JS功能 #  字符串转数字 #  let n = \u0026#39;1\u0026#39; let number /* 三种字符串转数字方法 */ number = n - 0 number = +n number = parseInt(n, 10) 伪随机数 Math.random #  Math.random() 返回 0-1 之间的一个小数\nMath.random() 函数返回一个浮点, 伪随机数在范围从0到小于1\n最早的前后端交互案例 #  GitHub 地址: https://github.com/ChenNing02/nodejs-payment\nimg发请求案例 #  GitHub 地址: https://github.com/ChenNing02/nodejs-post-demo-img\n"});index.add({'id':20,'href':'/docs/generator%E5%87%BD%E6%95%B0%E7%9A%84%E5%90%AB%E4%B9%89%E4%B8%8E%E7%94%A8%E6%B3%95/','title':"Generator 函数的含义与用法",'content':"作者： 阮一峰\n日期： 2015年4月24日\n 本文是《深入掌握 ECMAScript 6 异步编程》系列文章的第一篇。\n  Generator函数的含义与用法 Thunk函数的含义与用法 co函数库的含义与用法 async函数的含义与用法   异步编程对 JavaScript 语言太重要。JavaScript 只有一根线程，如果没有异步编程，根本没法用，非卡死不可。\n以前，异步编程的方法，大概有下面四种。\n  回调函数 事件监听 发布/订阅 Promise 对象   ECMAScript 6 （简称 ES6 ）作为下一代 JavaScript 语言，将 JavaScript 异步编程带入了一个全新的阶段。这组系列文章的主题，就是介绍更强大、更完善的 ES6 异步编程方法。\n新方法比较抽象，初学时，我常常感到费解，直到很久以后才想通，**异步编程的语法目标，就是怎样让它更像同步编程。**这组系列文章，将帮助你深入理解 JavaScript 异步编程的本质。所有将要讲到的内容，都已经实现了。也就是说，马上就能用，套用一句广告语，就是\u0026quot;未来已来\u0026rdquo;。\n一、什么是异步？ #  所谓\u0026quot;异步\u0026rdquo;，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。比如，有一个任务是读取文件进行处理，异步的执行过程就是下面这样。\n上图中，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。\n**这种不连续的执行，就叫做异步。**相应地，连续的执行，就叫做同步。\n上图就是同步的执行方式。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。\n二、回调函数的概念 #  JavaScript 语言对异步编程的实现，就是回调函数。**所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。**它的英语名字 callback，直译过来就是\u0026quot;重新调用\u0026rdquo;。\n读取文件进行处理，是这样写的。\nfs.readFile(\u0026#39;/etc/passwd\u0026#39;, function (err, data) { if (err) throw err; console.log(data); }); 上面代码中，readFile 函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了 /etc/passwd 这个文件以后，回调函数才会执行。\n一个有趣的问题是，为什么 Node.js 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是 null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。\n三、Promise #  回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。\nfs.readFile(fileA, function (err, data) { fs.readFile(fileB, function (err, data) { // ...  }); }); 不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为\u0026ldquo;回调函数噩梦\u0026rdquo;（callback hell）。\nPromise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。采用Promise，连续读取多个文件，写法如下。\nvar readFile = require(\u0026#39;fs-readfile-promise\u0026#39;); readFile(fileA) .then(function(data){ console.log(data.toString()); }) .then(function(){ return readFile(fileB); }) .then(function(data){ console.log(data.toString()); }) .catch(function(err) { console.log(err); }); 上面代码中，我使用了 fs-readfile-promise 模块，它的作用就是返回一个 Promise 版本的 readFile 函数。Promise 提供 then 方法加载回调函数，catch方法捕捉执行过程中抛出的错误。\n可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。\nPromise 的最大问题是代码冗余，原来的任务被Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚。\n那么，有没有更好的写法呢？\n四、协程 #  传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做\u0026ldquo;协程\u0026rdquo;（coroutine），意思是多个线程互相协作，完成异步任务。\n协程有点像函数，又有点像线程。它的运行流程大致如下。\n 第一步，协程A开始执行。\n第二步，协程A执行到一半，进入暂停，执行权转移到协程B。\n第三步，（一段时间后）协程B交还执行权。\n第四步，协程A恢复执行。\n 上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。\n举例来说，读取文件的协程写法如下。\nfunction asnycJob() { // ...其他代码  var f = yield readFile(fileA); // ...其他代码 } 上面代码的函数 asyncJob 是一个协程，它的奥妙就在其中的 yield 命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。\n协程遇到 yield 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。\n五、Generator函数的概念 #  Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。\nfunction* gen(x){ var y = yield x + 2; return y; } 上面代码就是一个 Generator 函数。它不同于普通函数，是可以暂停执行的，所以函数名之前要加星号，以示区别。\n整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。Generator 函数的执行方法如下。\nvar g = gen(1); g.next() // { value: 3, done: false } g.next() // { value: undefined, done: true } 上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器 ）g 。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针 g 的 next 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 yield 语句，上例是执行到 x + 2 为止。\n换言之，next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。\n六、Generator 函数的数据交换和错误处理 #  Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。\nnext 方法返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，这是向 Generator 函数体内输入数据。\nfunction* gen(x){ var y = yield x + 2; return y; } var g = gen(1); g.next() // { value: 3, done: false } g.next(2) // { value: 2, done: true } 上面代码中，第一个 next 方法的 value 属性，返回表达式 x + 2 的值（3）。第二个 next 方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量 y 接收。因此，这一步的 value 属性，返回的就是2（变量 y 的值）。\nGenerator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。\nfunction* gen(x){ try { var y = yield x + 2; } catch (e){ console.log(e); } return y; } var g = gen(1); g.next(); g.throw（\u0026#39;出错了\u0026#39;）; // 出错了 上面代码的最后一行，Generator 函数体外，使用指针对象的 throw 方法抛出的错误，可以被函数体内的 try \u0026hellip; catch 代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。\n七、Generator 函数的用法 #  下面看看如何使用 Generator 函数，执行一个真实的异步任务。\nvar fetch = require(\u0026#39;node-fetch\u0026#39;); function* gen(){ var url = \u0026#39;https://api.github.com/users/github\u0026#39;; var result = yield fetch(url); console.log(result.bio); } 上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了 yield 命令。\n执行这段代码的方法如下。\nvar g = gen(); var result = g.next(); result.value.then(function(data){ return data.json(); }).then(function(data){ g.next(data); }); 上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用 next 方法（第二行），执行异步任务的第一阶段。由于 Fetch 模块返回的是一个 Promise 对象，因此要用 then 方法调用下一个next 方法。\n可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。本系列的后面部分，就将介绍如何自动化异步任务的流程管理。另外，本文对 Generator 函数的介绍很简单，详尽的教程请阅读我写的《ECMAScript 6入门》。\n文档信息 #   版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证） 发表日期： 2015年4月24日    本文转自：http://www.ruanyifeng.com/blog/2015/04/generator.html\n "});index.add({'id':21,'href':'/docs/javascript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%844%E7%A7%8D%E6%96%B9%E6%B3%95/','title':"Javascript异步编程的4种方法",'content':"作者： 阮一峰\n日期： 2012年12月21日\n 你可能知道，Javascript语言的执行环境是\u0026quot;单线程\u0026rdquo;（single thread）。\n所谓\u0026quot;单线程\u0026rdquo;，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。\n这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。\n为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。\n\u0026ldquo;同步模式\u0026quot;就是上一段的模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；\u0026ldquo;异步模式\u0026quot;则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\u0026ldquo;异步模式\u0026quot;非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，\u0026ldquo;异步模式\u0026quot;甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应。\n本文总结了\u0026quot;异步模式\u0026quot;编程的4种方法，理解它们可以让你写出结构更合理、性能更出色、维护更方便的Javascript程序。\n一、回调函数 #  这是异步编程最基本的方法。\n假定有两个函数f1和f2，后者等待前者的执行结果。\nf1(); f2(); 如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数。\nfunction f1(callback){ setTimeout(function () { // f1的任务代码 　callback(); }, 1000); } 执行代码就变成下面这样：\nf1(f2); 采用这种方式，我们把同步操作变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。\n回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。\n二、事件监听 #  另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。\n还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的jQuery的写法）。\nf1.on(\u0026#39;done\u0026#39;, f2); 上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写：\nfunction f1(){ setTimeout(function () { // f1的任务代码 　f1.trigger(\u0026#39;done\u0026#39;); }, 1000); } f1.trigger('done') 表示，执行完成后，立即触发done事件，从而开始执行f2。\n这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以\u0026ldquo;去耦合\u0026rdquo;（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。\n三、发布/订阅 #  上一节的\u0026quot;事件\u0026rdquo;，完全可以理解成\u0026quot;信号\u0026rdquo;。\n我们假定，存在一个\u0026quot;信号中心\u0026rdquo;，某个任务执行完成，就向信号中心\u0026quot;发布\u0026rdquo;（publish）一个信号，其他任务可以向信号中心\u0026quot;订阅\u0026rdquo;（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做\u0026ldquo;发布/订阅模式\u0026rdquo;（publish-subscribe pattern），又称\u0026ldquo;观察者模式\u0026rdquo;（observer pattern）。\n这个模式有多种实现，下面采用的是Ben Alman的Tiny Pub/Sub，这是jQuery的一个插件。\n首先，f2向\u0026quot;信号中心\u0026quot;jQuery订阅\u0026quot;done\u0026quot;信号。\njQuery.subscribe(\u0026#34;done\u0026#34;, f2); 然后，f1进行如下改写：\nfunction f1(){ setTimeout(function () { // f1的任务代码 　jQuery.publish(\u0026#34;done\u0026#34;); }, 1000); } jQuery.publish(\u0026ldquo;done\u0026rdquo;)的意思是，f1执行完成后，向\u0026quot;信号中心\u0026quot;jQuery发布\u0026quot;done\u0026quot;信号，从而引发f2的执行。\n此外，f2完成执行后，也可以取消订阅（unsubscribe）。\njQuery.unsubscribe(\u0026#34;done\u0026#34;, f2); 这种方法的性质与\u0026quot;事件监听\u0026quot;类似，但是明显优于后者。因为我们可以通过查看\u0026quot;消息中心\u0026rdquo;，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\n四、Promises对象 #  Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。\n简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成：\nf1().then(f2); f1要进行如下改写（这里使用的是jQuery的实现）：\nfunction f1(){ var dfd = $.Deferred(); setTimeout(function () { // f1的任务代码 　dfd.resolve(); }, 500); return dfd.promise; } 这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。\n比如，指定多个回调函数：\nf1().then(f2).then(f3); 再比如，指定发生错误时的回调函数：\nf1().then(f2).fail(f3); 而且，它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。这种方法的缺点就是编写和理解，都相对比较难。\n五、参考链接 #  Asynchronous JS: Callbacks, Listeners, Control Flow Libs and Promises\n（完）\n 文档信息\n 本文转自：http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html 版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证） 发表日期： 2012年12月21日  "});index.add({'id':22,'href':'/docs/thunk%E5%87%BD%E6%95%B0%E7%9A%84%E5%90%AB%E4%B9%89%E5%92%8C%E7%94%A8%E6%B3%95/','title':"Thunk 函数的含义和用法",'content':"作者： 阮一峰\n日期： 2015年5月 1日\n 本文是《深入掌握 ECMAScript 6 异步编程》系列文章的第二篇。\n  Generator函数的含义与用法 Thunk函数的含义与用法 co函数库的含义与用法 async函数的含义与用法   一、参数的求值策略 #  Thunk函数早在上个世纪60年代就诞生了。\n那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是\u0026ldquo;求值策略\u0026rdquo;，即函数的参数到底应该何时求值。\nvar x = 1; function f(m){ return m * 2; } f(x + 5) 上面代码先定义函数 f，然后向它传入表达式 x + 5 。请问，这个表达式应该何时求值？\n一种意见是\u0026ldquo;传值调用\u0026rdquo;（call by value），即在进入函数体之前，就计算 x + 5 的值（等于6），再将这个值传入函数 f 。C语言就采用这种策略。\nf(x + 5) // 传值调用时，等同于 f(6) 另一种意见是\u0026ldquo;传名调用\u0026rdquo;（call by name），即直接将表达式 x + 5 传入函数体，只在用到它的时候求值。Hskell语言采用这种策略。\nf(x + 5) // 传名调用时，等同于 (x + 5) * 2 **传值调用和传名调用，哪一种比较好？回答是各有利弊。**传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。\nfunction f(a, b){ return b; } f(3 * x * x - 2 * x - 1, x); 上面代码中，函数 f 的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。\n因此，有一些计算机学家倾向于\u0026quot;传名调用\u0026rdquo;，即只在执行时求值。\n二、Thunk 函数的含义 #  编译器的\u0026quot;传名调用\u0026quot;实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。\nfunction f(m){ return m * 2; } f(x + 5); // 等同于  var thunk = function () { return x + 5; }; function f(thunk){ return thunk() * 2; } 上面代码中，函数 f 的参数 x + 5 被一个函数替换了。凡是用到原参数的地方，对 Thunk 函数求值即可。\n这就是 Thunk 函数的定义，它是\u0026quot;传名调用\u0026quot;的一种实现策略，用来替换某个表达式。\n三、JavaScript 语言的 Thunk 函数 #  JavaScript 语言是传值调用，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。\n// 正常版本的readFile（多参数版本） fs.readFile(fileName, callback); // Thunk版本的readFile（单参数版本） var readFileThunk = Thunk(fileName); readFileThunk(callback); var Thunk = function (fileName){ return function (callback){ return fs.readFile(fileName, callback); }; }; 上面代码中，fs 模块的 readFile 方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。\n任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。下面是一个简单的 Thunk 函数转换器。\nvar Thunk = function(fn){ return function (){ var args = Array.prototype.slice.call(arguments); return function (callback){ args.push(callback); return fn.apply(this, args); } }; }; 使用上面的转换器，生成 fs.readFile 的 Thunk 函数。\nvar readFileThunk = Thunk(fs.readFile); readFileThunk(fileA)(callback); 四、Thunkify 模块 #  生产环境的转换器，建议使用 Thunkify 模块。\n首先是安装。\n$ npm install thunkify 使用方式如下。\nvar thunkify = require(\u0026#39;thunkify\u0026#39;); var fs = require(\u0026#39;fs\u0026#39;); var read = thunkify(fs.readFile); read(\u0026#39;package.json\u0026#39;)(function(err, str){ // ... }); Thunkify 的源码与上一节那个简单的转换器非常像。\nfunction thunkify(fn){ return function(){ var args = new Array(arguments.length); var ctx = this; for(var i = 0; i \u0026lt; args.length; ++i) { args[i] = arguments[i]; } return function(done){ var called; args.push(function(){ if (called) return; called = true; done.apply(null, arguments); }); try { fn.apply(ctx, args); } catch (err) { done(err); } } } }; 它的源码主要多了一个检查机制，变量 called 确保回调函数只运行一次。这样的设计与下文的 Generator 函数相关。请看下面的例子。\nfunction f(a, b, callback){ var sum = a + b; callback(sum); callback(sum); } var ft = thunkify(f); ft(1, 2)(console.log); // 3 上面代码中，由于 thunkify 只允许回调函数执行一次，所以只输出一行结果。\n五、Generator 函数的流程管理 #  你可能会问， Thunk 函数有什么用？回答是以前确实没什么用，但是 ES6 有了 Generator 函数，Thunk 函数现在可以用于 Generator 函数的自动流程管理。\n以读取文件为例。下面的 Generator 函数封装了两个异步操作。\nvar fs = require(\u0026#39;fs\u0026#39;); var thunkify = require(\u0026#39;thunkify\u0026#39;); var readFile = thunkify(fs.readFile); var gen = function* (){ var r1 = yield readFile(\u0026#39;/etc/fstab\u0026#39;); console.log(r1.toString()); var r2 = yield readFile(\u0026#39;/etc/shells\u0026#39;); console.log(r2.toString()); }; 上面代码中，yield 命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。\n这种方法就是 Thunk 函数，因为它可以在回调函数里，将执行权交还给 Generator 函数。为了便于理解，我们先看如何手动执行上面这个 Generator 函数。\nvar g = gen(); var r1 = g.next(); r1.value(function(err, data){ if (err) throw err; var r2 = g.next(data); r2.value(function(err, data){ if (err) throw err; g.next(data); }); }); 上面代码中，变量 g 是 Generator 函数的内部指针，表示目前执行到哪一步。next 方法负责将指针移动到下一步，并返回该步的信息（value 属性和 done 属性）。\n仔细查看上面的代码，可以发现 Generator 函数的执行过程，其实是将同一个回调函数，反复传入 next 方法的 value 属性。这使得我们可以用递归来自动完成这个过程。\n六、Thunk 函数的自动流程管理 #  Thunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。\nfunction run(fn) { var gen = fn(); function next(err, data) { var result = gen.next(data); if (result.done) return; result.value(next); } next(); } run(gen); 上面代码的 run 函数，就是一个 Generator 函数的自动执行器。内部的 next 函数就是 Thunk 的回调函数。 next 函数先将指针移到 Generator 函数的下一步（gen.next 方法），然后判断 Generator 函数是否结束（result.done 属性），如果没结束，就将 next 函数再传入 Thunk 函数（result.value 属性），否则就直接退出。\n有了这个执行器，执行 Generator 函数方便多了。不管有多少个异步操作，直接传入 run 函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在 yield 命令后面的必须是 Thunk 函数。\nvar gen = function* (){ var f1 = yield readFile(\u0026#39;fileA\u0026#39;); var f2 = yield readFile(\u0026#39;fileB\u0026#39;); // ...  var fn = yield readFile(\u0026#39;fileN\u0026#39;); }; run(gen); 上面代码中，函数 gen 封装了 n 个异步的读取文件操作，只要执行 run 函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。\nThunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。本系列的下一篇，将介绍基于 Promise 的自动执行器。\n文档信息 #   版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证） 发表日期： 2015年5月 1日    本文转自：http://www.ruanyifeng.com/blog/2015/05/thunk.html\n "});index.add({'id':23,'href':'/docs/co%E5%87%BD%E6%95%B0%E5%BA%93%E7%9A%84%E5%90%AB%E4%B9%89%E5%92%8C%E7%94%A8%E6%B3%95/','title':"co 函数库的含义和用法",'content':"作者： 阮一峰\n日期： 2015年5月 6日\n 以下是《深入掌握 ECMAScript 6 异步编程》系列文章的第三篇。\n  Generator函数的含义与用法 Thunk函数的含义与用法 co函数库的含义与用法 async函数的含义与用法   一、什么是 co 函数库？ #  co 函数库是著名程序员 TJ Holowaychuk 于2013年6月发布的一个小工具，用于 Generator 函数的自动执行。\n比如，有一个 Generator 函数，用于依次读取两个文件。\nvar gen = function* (){ var f1 = yield readFile(\u0026#39;/etc/fstab\u0026#39;); var f2 = yield readFile(\u0026#39;/etc/shells\u0026#39;); console.log(f1.toString()); console.log(f2.toString()); }; co 函数库可以让你不用编写 Generator 函数的执行器。\nvar co = require(\u0026#39;co\u0026#39;); co(gen); 上面代码中，Generator 函数只要传入 co 函数，就会自动执行。\nco 函数返回一个 Promise 对象，因此可以用 then 方法添加回调函数。\nco(gen).then(function (){ console.log(\u0026#39;Generator 函数执行完成\u0026#39;); }) 上面代码中，等到 Generator 函数执行结束，就会输出一行提示。\n二、 co 函数库的原理 #  为什么 co 可以自动执行 Generator 函数？\n前面文章说过，Generator 函数就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。\n两种方法可以做到这一点。\n （1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。\n（2）Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。\n **co 函数库其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个库。**使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或 Promise 对象。\n上一篇文章已经介绍了基于 Thunk 函数的自动执行器。下面来看，基于 Promise 对象的自动执行器。这是理解 co 函数库必须的。\n三、基于 Promise 对象的自动执行 #  还是沿用上面的例子。首先，把 fs 模块的 readFile 方法包装成一个 Promise 对象。\nvar fs = require(\u0026#39;fs\u0026#39;); var readFile = function (fileName){ return new Promise(function (resolve, reject){ fs.readFile(fileName, function(error, data){ if (error) reject(error); resolve(data); }); }); }; var gen = function* (){ var f1 = yield readFile(\u0026#39;/etc/fstab\u0026#39;); var f2 = yield readFile(\u0026#39;/etc/shells\u0026#39;); console.log(f1.toString()); console.log(f2.toString()); }; 然后，手动执行上面的 Generator 函数。\nvar g = gen(); g.next().value.then(function(data){ g.next(data).value.then(function(data){ g.next(data); }); }) 手动执行其实就是用 then 方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。\nfunction run(gen){ var g = gen(); function next(data){ var result = g.next(data); if (result.done) return result.value; result.value.then(function(data){ next(data); }); } next(); } run(gen); 上面代码中，只要 Generator 函数还没执行到最后一步，next 函数就调用自身，以此实现自动执行。\n四、co 函数库的源码 #  co 就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。\n首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。\nfunction co(gen) { var ctx = this; return new Promise(function(resolve, reject) { }); } 在返回的 Promise 对象里面，co 先检查参数 gen 是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为 resolved 。\nfunction co(gen) { var ctx = this; return new Promise(function(resolve, reject) { if (typeof gen === \u0026#39;function\u0026#39;) gen = gen.call(ctx); if (!gen || typeof gen.next !== \u0026#39;function\u0026#39;) return resolve(gen); }); } 接着，co 将 Generator 函数的内部指针对象的 next 方法，包装成 onFulefilled 函数。这主要是为了能够捕捉抛出的错误。\nfunction co(gen) { var ctx = this; return new Promise(function(resolve, reject) { if (typeof gen === \u0026#39;function\u0026#39;) gen = gen.call(ctx); if (!gen || typeof gen.next !== \u0026#39;function\u0026#39;) return resolve(gen); onFulfilled(); function onFulfilled(res) { var ret; try { ret = gen.next(res); } catch (e) { return reject(e); } next(ret); } }); } 最后，就是关键的 next 函数，它会反复调用自身。\nfunction next(ret) { if (ret.done) return resolve(ret.value); var value = toPromise.call(ctx, ret.value); if (value \u0026amp;\u0026amp; isPromise(value)) return value.then(onFulfilled, onRejected); return onRejected(new TypeError(\u0026#39;You may only yield a function, promise, generator, array, or object, \u0026#39; + \u0026#39;but the following object was passed: \u0026#34;\u0026#39; + String(ret.value) + \u0026#39;\u0026#34;\u0026#39;)); } }); 上面代码中，next 函数的内部代码，一共只有四行命令。\n 第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。\n第二行，确保每一步的返回值，是 Promise 对象。\n第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。\n第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行。\n 五、并发的异步操作 #  co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。\n这时，要把并发的操作都放在数组或对象里面。\n// 数组的写法 co(function* () { var res = yield [ Promise.resolve(1), Promise.resolve(2) ]; console.log(res); }).catch(onerror); // 对象的写法 co(function* () { var res = yield { 1: Promise.resolve(1), 2: Promise.resolve(2), }; console.log(res); }).catch(onerror); 文档信息 #   版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证） 发表日期： 2015年5月 6日    本文转自：http://www.ruanyifeng.com/blog/2015/05/co.html\n "});index.add({'id':24,'href':'/docs/async%E5%87%BD%E6%95%B0%E7%9A%84%E5%90%AB%E4%B9%89%E5%92%8C%E7%94%A8%E6%B3%95/','title':"async 函数的含义和用法",'content':"作者： 阮一峰\n日期： 2015年5月11日\n 本文是《深入掌握 ECMAScript 6 异步编程》系列文章的最后一篇。\n  Generator函数的含义与用法 Thunk函数的含义与用法 co函数库的含义与用法 async函数的含义与用法   一、终极解决 #  异步操作是 JavaScript 编程的麻烦事，麻烦到一直有人提出各种各样的方案，试图解决这个问题。\n从最早的回调函数，到 Promise 对象，再到 Generator 函数，每次都有所改进，但又让人觉得不彻底。它们都有额外的复杂性，都需要理解抽象的底层运行机制。\n异步I/O不就是读取一个文件吗，干嘛要搞得这么复杂？异步编程的最高境界，就是根本不用关心它是不是异步。\nasync 函数就是隧道尽头的亮光，很多人认为它是异步操作的终极解决方案。\n二、async 函数是什么？ #  一句话，async 函数就是 Generator 函数的语法糖。\n前文有一个 Generator 函数，依次读取两个文件。\nvar fs = require(\u0026#39;fs\u0026#39;); var readFile = function (fileName){ return new Promise(function (resolve, reject){ fs.readFile(fileName, function(error, data){ if (error) reject(error); resolve(data); }); }); }; var gen = function* (){ var f1 = yield readFile(\u0026#39;/etc/fstab\u0026#39;); var f2 = yield readFile(\u0026#39;/etc/shells\u0026#39;); console.log(f1.toString()); console.log(f2.toString()); }; 写成 async 函数，就是下面这样。\nvar asyncReadFile = async function (){ var f1 = await readFile(\u0026#39;/etc/fstab\u0026#39;); var f2 = await readFile(\u0026#39;/etc/shells\u0026#39;); console.log(f1.toString()); console.log(f2.toString()); }; 一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。\n三、async 函数的优点 #  async 函数对 Generator 函数的改进，体现在以下三点。\n（1）内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。\nvar result = asyncReadFile(); （2）更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。\n（3）更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\n四、async 函数的实现 #  async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。\nasync function fn(args){ // ... } // 等同于  function fn(args){ return spawn(function*() { // ...  }); } 所有的 async 函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。\n下面给出 spawn 函数的实现，基本就是前文自动执行器的翻版。\nfunction spawn(genF) { return new Promise(function(resolve, reject) { var gen = genF(); function step(nextF) { try { var next = nextF(); } catch(e) { return reject(e); } if(next.done) { return resolve(next.value); } Promise.resolve(next.value).then(function(v) { step(function() { return gen.next(v); }); }, function(e) { step(function() { return gen.throw(e); }); }); } step(function() { return gen.next(undefined); }); }); } async 函数是非常新的语法功能，新到都不属于 ES6，而是属于 ES7。目前，它仍处于提案阶段，但是转码器 Babel 和 regenerator 都已经支持，转码后就能使用。\n五、async 函数的用法 #  同 Generator 函数一样，async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。\n下面是一个例子。\nasync function getStockPriceByName(name) { var symbol = await getStockSymbol(name); var stockPrice = await getStockPrice(symbol); return stockPrice; } getStockPriceByName(\u0026#39;goog\u0026#39;).then(function (result){ console.log(result); }); 上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。\n下面的例子，指定多少毫秒后输出一个值。\nfunction timeout(ms) { return new Promise((resolve) =\u0026gt; { setTimeout(resolve, ms); }); } async function asyncPrint(value, ms) { await timeout(ms); console.log(value) } asyncPrint(\u0026#39;hello world\u0026#39;, 50); 上面代码指定50毫秒以后，输出\u0026quot;hello world\u0026rdquo;。\n六、注意点 #  await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try\u0026hellip;catch 代码块中。\nasync function myFunction() { try { await somethingThatReturnsAPromise(); } catch (err) { console.log(err); } } // 另一种写法  async function myFunction() { await somethingThatReturnsAPromise().catch(function (err){ console.log(err); }); } await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。\nasync function dbFuc(db) { let docs = [{}, {}, {}]; // 报错  docs.forEach(function (doc) { await db.post(doc); }); } 上面代码会报错，因为 await 用在普通函数之中了。但是，如果将 forEach 方法的参数改成 async 函数，也有问题。\nasync function dbFuc(db) { let docs = [{}, {}, {}]; // 可能得到错误结果  docs.forEach(async function (doc) { await db.post(doc); }); } 上面代码可能不会正常工作，原因是这时三个 db.post 操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用 for 循环。\nasync function dbFuc(db) { let docs = [{}, {}, {}]; for (let doc of docs) { await db.post(doc); } } 如果确实希望多个请求并发执行，可以使用 Promise.all 方法。\nasync function dbFuc(db) { let docs = [{}, {}, {}]; let promises = docs.map((doc) =\u0026gt; db.post(doc)); let results = await Promise.all(promises); console.log(results); } // 或者使用下面的写法  async function dbFuc(db) { let docs = [{}, {}, {}]; let promises = docs.map((doc) =\u0026gt; db.post(doc)); let results = []; for (let promise of promises) { results.push(await promise); } console.log(results); } （完）\n文档信息 #   版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证） 发表日期： 2015年5月11日    本文转自：http://www.ruanyifeng.com/blog/2015/05/async.html\n "});index.add({'id':25,'href':'/history/2019-10-25-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E8%AF%A6%E7%BB%86/','title':"多人博客项目(详细)",'content':"Vue-Cli #  安装 #  可以使用下列任一命令安装这个新的包\nnpm install -g @vue/cli # OR yarn global add @vue/cli 安装后使用，以下命令查看版本\nvue --version  官方文档：Vue-Cli 安装\n 使用 Vue-2.x 模板 #  作用：使用旧版的 Vue 功能\nVue CLI \u0026gt;= 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具：\nnpm install -g @vue/cli-init # `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同 vue init webpack my-project 当前目录创建项目 #  执行以下命令，在当前目录下创建\nvue init webpack .  官方文档：拉取-2-x-模板-旧版本\n 项目文件目录 #  ├── src\r│ ├── api --- │ │ ├── auth.js --- 封装后台的请求路由\r│ │ └── blog.js --- 博客操作API封装\r│ ├── assets --- 公共 less 样式\r│ ├── components --- 页面组件\r│ ├── helpers --- 助手\r│ │ └── request.js --- 再封装的 axios\r│ ├── pages 页面组件\r│ ├── router Vue 路由管理器\r│ ├── store --- 使用 Vuex 获取修改同步博客信息文件夹\r│ │ ├── modules --- 封装API\r│ │ │ ├── auth.js --- 用户信息操作\r│ │ │ └── blog.js --- 博客内容操作\r│ │ └── index.js --- 路由\r配置路由 #  打开根目录下的 ./src/router/index.js 文件，其中\nimport HelloWorld from '@/components/HelloWorld' 表示引入 src 目录下的 /components/HelloWorld.vue 文件并命名为 HelloWorld\n@ 表示 src 目录下\nexport default new Router({ }) 输出 export default 后的对象\n案例：\nimport Vue from \u0026#39;vue\u0026#39; import Router from \u0026#39;vue-router\u0026#39; import HelloWorld from \u0026#39;@/components/HelloWorld\u0026#39; Vue.use(Router) export default new Router({ routes: [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;HelloWorld\u0026#39;, component: HelloWorld } ] }) 其中，new Router() 传入的对象中的 routes 表示\nexport default new Router({ routes: [ { path: \u0026#39;/\u0026#39;, /* 配置路由地址 */ name: \u0026#39;HelloWorld\u0026#39;, component: HelloWorld /* 对应显示的组件 */ } ] }) 组件目录 #  给当前项目 src 目录下创建 pages 目录 ( 组件目录 )，目录中每个组件路径下都包含一个 .css .js .vue 三个文件\n├── pages\r│ ├── Create # 创建 --- 创建博客\r│ │ ├── template.css\r│ │ ├── template.js\r│ │ └── template.vue\r│ ├── Detail # 详情 --- 博客详情\r│ ├── Edit # 编辑 --- 博客编辑\r│ ├── Index # 首页\r│ ├── Login # 登录\r│ ├── My # 我的 --- 我的个人主页\r│ ├── Register # 注册\r│ └── User # 用户\rCSS 样式独立 #  当我们修改每个组件目录下的 CSS 样式时，可能会生效与所有组件中，只要在 style 中添加 scoped 属性即可，如下：\n\u0026lt;style scoped src=\u0026#34;./template.css\u0026#34;\u0026gt;\u0026lt;/style\u0026gt; 使用 less 语法 #  less 可以声明变量，相比 css 语法会方便很多，所以在开发时可以使用 less 语法，发布时再做转换。\n引入时在 style 标签中添加 lang=\u0026quot;less\u0026quot; 属性即可，如下：\n\u0026lt;style scoped lang=\u0026#34;less\u0026#34; src=\u0026#34;./template.less\u0026#34;\u0026gt;\u0026lt;/style\u0026gt; 安装预处理器 #  添加后不能直接使用，需要安装一个预处理器\n在项目根目录执行以下命令安装 less 预处理器\nnpm install -D less-loader less  官方文档：引用静态资源\n 使用 CSS 公共属性 #  在 src/assets 目录下创建 base.less 文件(你也可以创建一个其他目录，但最好要在 src 下)。\n案例\n@themesRed: #ff3300;\r在主页中引入此样式：\n在 src/pages/Index/template.less 文件的头部添加以下内容(注意结尾必须加分号)\n@import \u0026quot;../../assets/base.less\u0026quot;;\rh2 {\rcolor: @themesRed;\r}\r使用 Element-UI #  查看官方文档，在 src/router/index.js 文件中引入：\nimport ElementUI from \u0026#39;element-ui\u0026#39;; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;; Vue.use(ElementUI);  官方文档：Element-UI\n 创建公共目录 #  目录列表\n├── src\r│ ├── api --- │ │ ├── auth.js --- 封装后台的请求路由\r│ │ └── blog.js --- 博客操作API封装\r│ ├── assets --- │ ├── components --- │ ├── helpers --- 助手\r│ │ └── request.js --- 再封装的 axios\r│ ├── pages # │ ├── router # │ ├── store --- 使用 Vuex 获取修改同步博客信息文件夹\r│ │ ├── modules --- 封装API\r│ │ │ ├── auth.js --- 用户信息操作\r│ │ │ └── blog.js --- 博客内容操作\r│ │ └── index.js --- 路由\r其中\n helpers 目录：存放一些公共方法，方便所有文件调用  request.js 文件：存放 axios (再封装的 axios)    测试后台 #  request.js 封装测试 #  在 src \u0026gt; pages \u0026gt; Index \u0026gt; template.js 文件的头部引入以下文件\nimport request from \u0026#39;@/helpers/request.js\u0026#39; /* 此处为例便于测试，将 request 存入全局变量 request 中 */ window.request = request 然后打开博客项目主页，进行以下测试\n/* 登录成功测试 */ request(\u0026#39;/auth/login\u0026#39;, \u0026#39;post\u0026#39;,{username: \u0026#39;hunger1\u0026#39;, password: \u0026#39;123456\u0026#39;}) .then(data=\u0026gt;{ console.log(data) }) /* 登录失败测试 */ request(\u0026#39;/auth/login\u0026#39;, \u0026#39;post\u0026#39;,{username: \u0026#39;hunger1\u0026#39;, password: \u0026#39;923456\u0026#39;}).then(data=\u0026gt;{ console.log(data) }).catch(()=\u0026gt;{ console.log(\u0026#39;数据错误\u0026#39;)} ) /* 这里数据出错可以使用.catch()再处理 */ /* 创建博客 */ request(\u0026#39;/blog\u0026#39;, \u0026#39;post\u0026#39;, { title: \u0026#39;我的第一篇博客\u0026#39;, content: \u0026#39;## 我的第一篇博客\u0026#39;, description: \u0026#39;简介\u0026#39; }).then(data=\u0026gt;{ console.log(data) }) /* 获取博客网站数据 */ request(\u0026#39;/blog\u0026#39;).then(data=\u0026gt;{ console.log(data) }) 控制台输出示例\n▼{status: \u0026quot;ok\u0026quot;, msg: \u0026quot;登录成功\u0026quot;, data: {/* … */}}\rdata: {\rid: 6, username: \u0026quot;hunger1\u0026quot;, avatar: \u0026quot;4.jpg\u0026quot;, createdAt: \u0026quot;2018-06-21T07:06:03.314Z\u0026quot;, updatedAt: \u0026quot;2018-06-21T07:06:03.314Z\u0026quot;\r}\rmsg: \u0026quot;登录成功\u0026quot;\rstatus: \u0026quot;ok\u0026quot;\r__proto__: Object\rauth.js封装测试 #  在 src \u0026gt; pages \u0026gt; Index \u0026gt; template.js 文件的头部追加以下文件\nimport auth from \u0026#39;@/api/auth.js\u0026#39; /* 为了便于测试 将 auth 变为全局变量 */ window.auth = auth 然后打开博客项目主页，进行以下测试\n/* 注册测试 */ auth.register({username: \u0026#39;hunger39e\u0026#39;, password: \u0026#39;123456\u0026#39;}).then(res=\u0026gt;console.log(res)) /* 登录测试 */ auth.login({username: \u0026#39;hunger\u0026#39;, password: \u0026#39;123456\u0026#39;}).then(res=\u0026gt;console.log(res)) /* 获取用户信息 */ auth.getInfo().then(res=\u0026gt;console.log(res)) /* 注销测试 */ auth.logout() 控制台输出示例\n▼{status: \u0026quot;ok\u0026quot;, msg: \u0026quot;操作提示\u0026quot;, total: 1782, totalPage: 179, page: 1, …}\rdata: (10) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]\rmsg: \u0026quot;操作提示\u0026quot;\rpage: 1\rstatus: \u0026quot;ok\u0026quot;\rtotal: 1782\rtotalPage: 179\r__proto__: Object\r创建模板 #  components 文件夹中创建以下文件\n├── src\r│ ├── api\r│ ├── assets\r│ │ ├── base.less --- CSS公共属性\r│ │ └── common.less --- CSS公共样式\r│ ├── components\r│ │ ├── footer.vue --- 页面底部组件\r│ │ └── header.vue --- 页面头部组件\r│ ├── helpers\r│ ├── pages │ ├── router │ ├── App.vue --- 在页面引入模板\r│ └── main.js 在 App.vue 中引入文件\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;Header id=\u0026#34;header\u0026#34;\u0026gt;\u0026lt;/Header\u0026gt; \u0026lt;main id=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;Footer id=\u0026#34;footer\u0026#34;\u0026gt;\u0026lt;/Footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import Header from \u0026#39;@/components/header\u0026#39; import Footer from \u0026#39;@/components/footer\u0026#39; export default { name: \u0026#39;App\u0026#39;, components: { Header, Footer } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; #app { font-size: 18px; } \u0026lt;/style\u0026gt; 其中 \u0026lt;router-view/\u0026gt; 在 src 目录下的 router 文件夹中引入\n使用 Grid 布局 #  html\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;header id=\u0026#34;header\u0026#34;\u0026gt;头部...\u0026lt;/header\u0026gt; \u0026lt;main id=\u0026#34;main\u0026#34;\u0026gt;内容...\u0026lt;/main\u0026gt; \u0026lt;footer id=\u0026#34;footer\u0026#34;\u0026gt;底部...\u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; CSS\n#app { display: grid; grid-template-columns: 12% auto 12%; grid-template-rows: auto 1fr auto; grid-template-areas: \u0026#34;header header header\u0026#34; \u0026#34;. main .\u0026#34; \u0026#34;footer footer footer\u0026#34; } #header{ grid-area: header; padding: 10px 12%; background-color: #f68f25; } #main{ grid-area: main; background-color: #4ba846; padding: 10px; } #footer{ grid-area: footer; padding: 10px 12%; background-color: #0476c2; }  预览效果 案例预览\n 添加宽度变小自适应\n当设备宽度小于 768px 时，页面 padding 变为固定 10px\n@media (max-width: 768px) { #app { grid-template-columns: 10px auto 10px; #header, #footer { padding-left: 10px; padding-right: 10px; } } } 添加Vuex #  作用 #  Vuex 主要用于同步不同模块之间的公共数据\n安装 #  NPM\nnpm install vuex --save Yarn\nyarn add vuex  官方文档：Vuex 安装\n 引入Vuex #  目录索引 #  ├── store --- 使用 Vuex 获取修改同步博客信息文件夹\r│ ├── modules --- 封装API\r│ │ ├── auth.js --- 用户信息操作\r│ │ └── blog.js --- 博客内容操作\r│ └── index.js --- 路由\r封装 Vuex #  在 src 目录下创建 store 文件夹，用于封装 Vuex 的状态数据。\n在 store 中创建 index.js 文件，用做引出文件的路由。\nindex.js 文件夹中添加以下内容：\nimport Vue from \u0026#39;vue\u0026#39; import Vuex from \u0026#39;vuex\u0026#39; import auth from \u0026#39;./modules/auth\u0026#39; import blog from \u0026#39;./modules/blog\u0026#39; Vue.use(Vuex) export default new Vuex.Store({ modules: { auth, blog } }) 在 store 中创建 modules 文件夹，用于存放分类的模块\n在 modules 文件夹中创建 auth.js 文件，用于封装用户登录注册相关的数据的一些操作。\nauth.js 文件内容\n/* 引入 api 路由 */ import auth from \u0026#39;@/api/auth\u0026#39; /* 默认下的 state 数据 */ const state = { /* 用户账号信息，比如用户名，密码之类 */ user: null, /* 用户登录状态 */ isLogin: false } /* 同步的变更用户登录状态 */ const getters = { user: state =\u0026gt; state.user, isLogin: state =\u0026gt; state.isLogin } /* 操作用户的账户数据 */ const mutations = { /* state (修改前的数据)，payload (需要传入的新数据) */ setUser(state, payload) { state.user = payload.user }, setLogin(state, payload) { state.isLogin = payload.isLogin } } /* 异步的操作 */ const actions = { /* === 登录 === * 语法说明：xxx({ commit }, { username, password }) * ES6语法，表示第二个参数传入的是一个对象，该对象必须有 username 和 password 属性 */ login({ commit }, { username, password }) { return auth.login({ username, password }) .then(res =\u0026gt; { commit(\u0026#39;setUser\u0026#39;, { user: res.data }) commit(\u0026#39;setLogin\u0026#39;, { isLogin: true }) }) }, /* === 注册 === */ async register({ commit }, { username, password }) { let res = await auth.register({ username, password }) /* 上面 mutations 中的 setUser(state, payload) 中传入的 payload 就代表下面的commit括号中的第二个参数 */ commit(\u0026#39;setUser\u0026#39;, { user: res.data }) commit(\u0026#39;setLogin\u0026#39;, { isLogin: true }) return res.data }, /* === 注销 === */ async logout({ commit }) { await auth.logout() commit(\u0026#39;setUser\u0026#39;, { user: null }) commit(\u0026#39;setLogin\u0026#39;, { isLogin: false }) }, /* === 检测用户登录状态 === * 如果未登录则设置用户数据为空，并返回 false * 如果登录则设置当前用户数据，并返回 true */ async checkLogin({ commit, state}) { /* 此处的 state 是上面的 const state */ if(state.isLogin) return true /* api 文件 中的 auth.getInfo 用来判断用户是否登录 */ let res = await auth.getInfo() commit(\u0026#39;setLogin\u0026#39;, { isLogin: res.isLogin }) if(!res.isLogin) return false commit(\u0026#39;setUser\u0026#39;, { user: res.data }) return true } } /* then 的使用方法 * this.logout().then( isLogin=\u0026gt;{} ) */ export default { state, getters, mutations, actions } ？actions 中的ES6语法\n普通写法\nlogin({ commit }, { username, password }) { return auth.login({ username, password }) .then(res =\u0026gt; { commit(\u0026#39;setUser\u0026#39;, { user: res.data }) commit(\u0026#39;setLogin\u0026#39;, { isLogin: true }) }) } ES6写法\nasync login({ commit }, { username, password }) { let res = await auth.login({ username, password }) commit(\u0026#39;setUser\u0026#39;, { user: res.data }) commit(\u0026#39;setLogin\u0026#39;, { isLogin: true }) return res.data } 在 modules  文件夹中创建 blog.js 文件夹，用于封装博客内容操作相关的数据。\nblog.js 的内容(暂未定)\nexport default { state:{}, getters:{}, mutations:{}, actions:{} } 主页中引入 #  在 src 目录下的 main.js 文件中引入\nimport store from \u0026#39;./store\u0026#39; 并在文件中的 Vue 对象中传入 store\nnew Vue({ el: \u0026#39;#app\u0026#39;, router, store, components: { App }, template: \u0026#39;\u0026lt;App/\u0026gt;\u0026#39; }) 打开控制台，在控制台的 Vue Devtools 中切换到时钟图标，可以看到一个 state 在 state 下有两个属性 分别是 auth 和 blog\n如下图所示\nxxximg.jpg\nmain.js 最终案例\nimport Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; Vue.config.productionTip = false new Vue({ el: \u0026#39;#app\u0026#39;, router, store, components: { App }, template: \u0026#39;\u0026lt;App/\u0026gt;\u0026#39; }) 实现登录/注册功能 #  打开 src \u0026gt; components \u0026gt; header.vue 文件\nJS 部分添加如下内容\n/* 引入 auth */ import auth from \u0026#39;@/api/auth\u0026#39; /* 为了测试登录注册将auth变为全局 */ window.auth = auth /* Vuex 提供的函数，经过处理映射到当前文件 */ import { mapGetters, mapActions } from \u0026#39;vuex\u0026#39; export default { data() { return { } }, computed: { /* 获取 vuex 中的 getters */ ...mapGetters([ \u0026#39;isLogin\u0026#39;, \u0026#39;user\u0026#39; ]) }, /* 每次加载都判断用户登录状态加载内容 */ created(){ /* 可以在函数后使用 then 的方式处理登录的结果，如.then(isLogin=\u0026gt;xxx) */ this.checkLogin() }, /* 获取 vuex 中的判断用户登录状态的方法，引入到当前组件中 * 当前组件中就可以直接使用该方法 */ methods: { ...mapActions([ \u0026#39;checkLogin\u0026#39;, \u0026#39;logout\u0026#39; ]), /* 注销函数 */ onLogout(){ this.logout() } } } created 生命周期\n作用：数据都加载完成，但组件未加载，页面未渲染时执行，作用是尽早的获取数据\n登录测试\nauth.login({username: \u0026#39;chen\u0026#39;, password: \u0026#39;123654\u0026#39;}).then(res=\u0026gt;console.log(res)) 添加路由链接\n\u0026lt;router-link to=\u0026#34;/login\u0026#34;\u0026gt;立刻登录\u0026lt;/router-link\u0026gt; Vue 事件绑定 #  回车事件绑定\n\u0026lt;input @keyup.enter=\u0026#39;onxxx\u0026#39;\u0026gt; 完善路由权限 #  官方文档：路由元信息 | Vue Router\n打开 src 目录下的 router \u0026gt; index.js 增加以下属性：\nimport Vue from \u0026#39;vue\u0026#39; import Router from \u0026#39;vue-router\u0026#39; import ElementUI from \u0026#39;element-ui\u0026#39;; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;; import store from \u0026#39;../store\u0026#39; window.store = store Vue.use(ElementUI); Vue.use(Router) /* 使用 component: ()=\u0026gt; import(\u0026#39;@/pages/Index/template.vue\u0026#39;) 的写法 * 每次打开对应页面才会加载页面的数据，不会一次性加载所有页面 */ const router = new Router({ routes: [ { path: \u0026#39;/\u0026#39;, component: ()=\u0026gt; import(\u0026#39;@/pages/Index/template.vue\u0026#39;) }, { // 创建博客页面  path: \u0026#39;/create\u0026#39;, component: ()=\u0026gt; import(\u0026#39;@/pages/Create/template.vue\u0026#39;), meta: { requiresAuth: true } }, { // 用户详情页面  path: \u0026#39;/detail/:blogId\u0026#39;, component: ()=\u0026gt; import(\u0026#39;@/pages/Detail/template.vue\u0026#39;) }, { // 编辑博客页面  path: \u0026#39;/edit/:blogId\u0026#39;, component: ()=\u0026gt; import(\u0026#39;@/pages/Edit/template.vue\u0026#39;), meta: { requiresAuth: true } }, { // 登录  path: \u0026#39;/login\u0026#39;, component: ()=\u0026gt; import(\u0026#39;@/pages/Login/template.vue\u0026#39;) }, { // 我的个人主页  path: \u0026#39;/my\u0026#39;, component: ()=\u0026gt; import(\u0026#39;@/pages/My/template.vue\u0026#39;), meta: { requiresAuth: true } }, { // 注册  path: \u0026#39;/register\u0026#39;, component: ()=\u0026gt; import(\u0026#39;@/pages/Register/template.vue\u0026#39;) }, { // 其他用户主页  path: \u0026#39;/user/:blogId\u0026#39;, component: ()=\u0026gt; import(\u0026#39;@/pages/User/template.vue\u0026#39;) } ] }) /* 此处遍历上面的每一项路由，然后获取路由信息 * to.matched.some(record=\u0026gt; record.meta.requiresAuth)获取路由中的 meta.requiresAuth 信息 * 如果匹配到存在 meta.requiresAuth 的路由，则执行里面的 if 否则继续下一步(next()) */ router.beforeEach((to, from, next)=\u0026gt;{ if(to.matched.some(record=\u0026gt; record.meta.requiresAuth)){ // 此处if判断，获取到 store \u0026gt; modules \u0026gt; auth.js 中的用户登录状态 (actions checkLogin)  store.dispatch(\u0026#39;checkLogin\u0026#39;).then(isLogin=\u0026gt;{ // 如果用户未登录则跳转到登录页面，如果用户登录就继续执行下一步  if(!isLogin){ next({ path: \u0026#39;/login\u0026#39;, query: { redirect: to.fullPath } }) } else { next() } }) } else { next() } }) export default router 打开 src 目录下的 pages \u0026gt; Login \u0026gt; template.js 修改其中的 onLogin 函数(登录后跳转操作)\nonLogin(){ this.login({username: this.username, password: this.password}) .then(()=\u0026gt;{ // 获取用户登录之前的其他页面信息，如果存在就跳转回去，不存在就跳转到主页  this.$router.push({path: this.$route.query.redirect || \u0026#39;/\u0026#39;}) }) } 添加创建博客功能 #  pages \u0026gt; create 文件夹中的文件\nvue\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;edit\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;创建文章\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;文章标题\u0026lt;span class=\u0026#34;msg\u0026#34;\u0026gt;( 限30个字 )\u0026lt;/span\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;el-input placeholder=\u0026#34;请输入文章标题\u0026#34; v-model=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;h3\u0026gt;内容简介\u0026lt;span class=\u0026#34;msg\u0026#34;\u0026gt;( 限30个字 )\u0026lt;/span\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;el-input type=\u0026#34;textarea\u0026#34; :autosize=\u0026#34;{ minRows: 2, maxRows: 10}\u0026#34; placeholder=\u0026#34;请输入文章简介\u0026#34; v-model=\u0026#34;description\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;h3\u0026gt;文章内容\u0026lt;span class=\u0026#34;msg\u0026#34;\u0026gt;( 限30个字 )\u0026lt;/span\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;el-input type=\u0026#34;textarea\u0026#34; :autosize=\u0026#34;{ minRows: 6, maxRows: 10}\u0026#34; placeholder=\u0026#34;请输入文章内容\u0026#34; v-model=\u0026#34;content\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-switch v-model=\u0026#34;atIndex\u0026#34; active-color=\u0026#34;#409EFF\u0026#34; active-text=\u0026#34;在首页展示\u0026#34;\u0026gt;\u0026lt;/el-switch\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;el-button size=\u0026#34;medium\u0026#34; type=\u0026#34;primary\u0026#34; plain @click=\u0026#34;onCreate\u0026#34;\u0026gt;确定\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;./template.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style scoped lang=\u0026#34;less\u0026#34; src=\u0026#34;./template.less\u0026#34;\u0026gt;\u0026lt;/style\u0026gt; js\nimport blog from \u0026#39;@/api/blog\u0026#39; export default { data () { return { title:\u0026#39;\u0026#39;, description:\u0026#39;\u0026#39;, content:\u0026#39;\u0026#39;, atIndex: false } }, methods: { onCreate(){ // 调用 API 中的 blog API 将新创建的博客添加到 多人共享博客的后台数据  blog.createBlog({ title: this.title, content: this.content, description: this.description, atIndex: this.atIndex }).then(res =\u0026gt; { // then处理数据 成功后提示创建成功  this.$message.success(res.msg) // 跳转到刚刚创建的指定文章详情下，文章 id 从传入的 res.data.id 中获取  this.$router.push({ path: `/detail/${res.data.id}`}) }) } } } 首页添加后台数据 #  代码\nvue\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;index\u0026#34;\u0026gt; \u0026lt;section class=\u0026#34;blog-posts\u0026#34;\u0026gt; \u0026lt;router-link class=\u0026#34;item\u0026#34; v-for=\u0026#34;blog in blogs\u0026#34; :to=\u0026#34;`/detail/${blog.id}`\u0026#34; :key=\u0026#34;blog.id\u0026#34;\u0026gt; \u0026lt;figure class=\u0026#34;avatar\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;blog.user.avatar\u0026#34; :alt=\u0026#34;blog.user.username\u0026#34;\u0026gt; \u0026lt;figcaption\u0026gt;{{blog.user.username}}\u0026lt;/figcaption\u0026gt; \u0026lt;/figure\u0026gt; \u0026lt;div class=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;{{blog.title}}\u0026lt;span\u0026gt;{{blog.createdAt}}\u0026lt;/span\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{{blog.description}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/router-link\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;blog-pages\u0026#34;\u0026gt; \u0026lt;el-pagination background :current-page.sync=\u0026#34;thisPage\u0026#34; layout=\u0026#34;prev, pager, next\u0026#34; :total=\u0026#34;total\u0026#34; @current-change=\u0026#34;onPagesChange\u0026#34;\u0026gt; \u0026lt;/el-pagination\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;./template.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style scoped lang=\u0026#34;less\u0026#34; src=\u0026#34;./template.less\u0026#34;\u0026gt;\u0026lt;/style\u0026gt; js\nimport blog from \u0026#39;@/api/blog.js\u0026#39; export default { data () { return { blogs: [], total: 0, page: 1 } }, created(){ this.page = parseInt(this.$route.query.page) || 1 blog.getIndexBlogs().then(res=\u0026gt;{ this.blogs = res.data this.total = res.total this.page = res.page }) }, methods: { onPagesChange(newPage){ blog.getIndexBlogs({ page: newPage}).then(res =\u0026gt;{ this.blogs = res.data this.total = res.total this.page = res.page this.$route.push({ path: \u0026#39;/\u0026#39;, query: { page:newPage }}) }) } } } 添加\n添加博客详情 #  代码\nvue\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;detail\u0026#34;\u0026gt; \u0026lt;section class=\u0026#34;user-info\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;photo\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;user.avatar\u0026#34; :alt=\u0026#34;user.username\u0026#34; :title=\u0026#34;user.username\u0026#34; class=\u0026#34;avatar\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;{{title}}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;\u0026lt;router-link :to=\u0026#34;`/user/${user.id}`\u0026#34;\u0026gt;{{user.username}}\u0026lt;/router-link\u0026gt;发布于{{friendlyDate(createdAt)}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;article\u0026#34; v-html=\u0026#34;markdown\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;./template.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style scoped lang=\u0026#34;less\u0026#34; src=\u0026#34;./template.less\u0026#34;\u0026gt;\u0026lt;/style\u0026gt; js\nimport marked from \u0026#39;marked\u0026#39; import blog from \u0026#39;@/api/blog\u0026#39; export default { data() { return { title: \u0026#39;\u0026#39;, rawContent: \u0026#39;\u0026#39;, user: {}, createdAt: \u0026#39;\u0026#39; } }, created() { this.blogId = this.$route.params.blogId blog.getDetail({ blogId: this.blogId }).then(res =\u0026gt; { console.log(\u0026#39;detail \u0026gt; res\u0026#39;) console.log(res) this.title = res.data.title this.rawContent = res.data.content this.createdAt = res.data.createdAt this.user = res.data.user }) }, computed: { markdown() { return marked(this.rawContent) } } } markdown 插件 #  安装\nnpm i marked --save 将 markdown 数据转换为 html 格式\n\u0026lt;section class=\u0026#34;article\u0026#34; v-html=\u0026#34;markdown\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; 时间格式化插件 #  在 src \u0026gt; helpers  中创建 util.js 文件\nfunction friendlyDate(datsStr) { let dateObj = typeof datsStr === \u0026#39;object\u0026#39; ? datsStr : new Date(datsStr) let time = dateObj.getTime() let now = Date.now() let space = now - time let str = \u0026#39;\u0026#39; switch (true) { case space \u0026lt; 60000: str = \u0026#39;刚刚\u0026#39; break case space \u0026lt; 1000*3600: str = Math.floor(space/60000) + \u0026#39;分钟前\u0026#39; break case space \u0026lt; 1000*3600*24: str = Math.floor(space/(1000*3600)) + \u0026#39;小时前\u0026#39; break default: str = Math.floor(space/(1000*3600*24)) + \u0026#39;天前\u0026#39; } return str } export default { install(Vue, options) { Vue.prototype.friendlyDate = friendlyDate } } 在 src \u0026gt; main.js 中引入插件\nimport Util from \u0026#39;@/helpers/util\u0026#39; Vue.use(Util) 页面中使用\n\u0026lt;span\u0026gt;{{friendlyDate(date)}}\u0026lt;/span\u0026gt; 用户详情页 #  添加时间格式化事件\nsplitDate(dataStr) { let dateObj = typeof dataStr === \u0026#39;object\u0026#39; ? dataStr : new Date(dataStr) return { date: dateObj.getDate(), month: dateObj.getMonth() + 1, year: dateObj.getFullYear() } } 使用到的 Vue 语句 #  绑定数据\n\u0026lt;img :src=\u0026#34;user.avatar\u0026#34; :alt=\u0026#34;user.username\u0026#34;\u0026gt; \u0026lt;router-link :to=\u0026#34;`/user/${user.id}`\u0026#34;\u0026gt;用户名称\u0026lt;/router-link\u0026gt; 数据转换为html格式\n\u0026lt;section class=\u0026#34;article\u0026#34; v-html=\u0026#34;markdown\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; input 输入框回车事件\n\u0026lt;input @keyup.enter=\u0026#34;onLogin\u0026#34; v-model=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; placeholder=\u0026#34;请输入密码\u0026#34;\u0026gt; 防止 @click 事件冒泡\n\u0026lt;router-link @click.prevent=\u0026#34;onDelete(blog.id)\u0026#34;\u0026gt;删除\u0026lt;/router-link\u0026gt; 预加载数据\nexport default { data() { return { } }, created() { }, computed: { } } router #  获取\n// 获取用户id案例 this.$route.params.blogId 链接\n\u0026lt;router-link to=\u0026#34;/register\u0026#34;\u0026gt;注册\u0026lt;/router-link\u0026gt; 页面跳转\nthis.$router.push({ path: `/detail/${res.data.id}`}) for in 循环获取数据\n\u0026lt;router-link class=\u0026#34;item\u0026#34; v-for=\u0026#34;blog in blogs\u0026#34; :to=\u0026#34;`/detail/${blog.id}`\u0026#34; :key=\u0026#34;blog.id\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt;  注意此处需要绑定 key 的值\n 使用到的 Element-UI 语句 #  绑定事件\n\u0026lt;el-link @click=\u0026#34;onLogout\u0026#34; :underline=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;/el-link\u0026gt; \u0026lt;el-button size=\u0026#34;medium\u0026#34; type=\u0026#34;primary\u0026#34; plain @click=\u0026#34;onCreate\u0026#34;\u0026gt;确定\u0026lt;/el-button\u0026gt; 多行输入框\n\u0026lt;el-input type=\u0026#34;textarea\u0026#34; :autosize=\u0026#34;{ minRows: 2, maxRows: 10}\u0026#34; placeholder=\u0026#34;请输入内容\u0026#34; v-model=\u0026#34;description\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt;  minRows 最小高度(行) maxRows 最大高度(行)\n 多页面切换按钮\n\u0026lt;el-pagination background :current-page.sync=\u0026#34;page\u0026#34; layout=\u0026#34;prev, pager, next\u0026#34; :total=\u0026#34;total\u0026#34; @current-change=\u0026#34;onPagesChange\u0026#34;\u0026gt; \u0026lt;/el-pagination\u0026gt; axios 的使用 #  应用的属性\nimport axios from \u0026#39;axios\u0026#39; /* 请求的数据类型约定 */ axios.defaults.headers.post[\u0026#39;Content-Type\u0026#39;] = \u0026#39;application/x-www-form-urlencoded\u0026#39; /* 后端接口域名地址(设置后请求时就可以不用写这部分 URL) */ axios.defaults.baseURL = \u0026#39;https://blog-server.hunger-valley.com\u0026#39; /* 前后端分离的项目，前端后端是在不同的服务器上，会涉及到跨域(默认情况跨域请求是不带 Cookie 数据的) * 此处设置异步请求(跨域)带 Cookie 数据 -- */ axios.defaults.withCredentials = true export default function request(url, type = \u0026#39;GET\u0026#39;, data = {}) { return new Promise((resolve, reject) =\u0026gt; { /* 声明一个变量，存储 url 和 type */ let option = { url, method: type } /* 判断请求类型，如果是 get 请求，就将 data 放到 option.params 中 * 如果是其他类型，就将 data 直接放入 option.data 中 */ if (type.toLowerCase() === \u0026#39;get\u0026#39;) { option.params = data } else { option.data = data } axios(option).then(res =\u0026gt; { /* 如果返回的数据 data.status = \u0026#39;ok\u0026#39; * - 如果成功返回数据格式：{ \u0026#34;status\u0026#34;: \u0026#34;ok\u0026#34;, \u0026#34;msg\u0026#34;: \u0026#34;注册成功\u0026#34;, \u0026#34;data\u0026#34;: { xxx } } * - 之后就可以.then()处理这个数据 */ if (res.data.status === \u0026#39;ok\u0026#39;) { /* 将数据传入 resolve() 函数中 */ resolve(res.data) /* 如果请求数据未成功 * - 如果错误返回数据格式：{\u0026#34;status\u0026#34;: \u0026#34;fail\u0026#34;, \u0026#34;msg\u0026#34;: \u0026#34;错误原因\u0026#34;} * - 其中 res.data.msg 表示返回错误的原因 */ } else { alert(\u0026#39;发现一个错误\u0026#39;) /* 把错误传入 reject() */ reject(res.data) } // 当发生网络异常的错误时，返回一个函数，执行以下内容  }).catch(err =\u0026gt; { alert(\u0026#39;网络异常\u0026#39;) /* 返回的数据中的msg属性为 \u0026#39;网络异常\u0026#39; */ reject({ msg: \u0026#39;网络异常\u0026#39; }) }) }) } "});index.add({'id':26,'href':'/posts/2020-06-09-window-json-use/','title':"window.JSON的使用",'content':"JSON.parse #  作用：将符合JSON语法的字符串转换成JS对应的数据类型\nJSON字符串 =\u0026gt; JS 数据\n注意事项：由于JSON只有6种类型，所以转成的数据也只有6种，如果不符合JSON的语法，则直接抛出一个Error对象，大部分时候我们用try catch捕获这个错误，如下：\nlet object try { object = JSON.parse(`{\u0026#39;name\u0026#39;:\u0026#39;frank\u0026#39;}`) }catch(error){ console.log(\u0026#39;出错了，错误详情是\u0026#39;) console.log(error) object = {\u0026#39;name\u0026#39;: \u0026#39;no name\u0026#39;} } 语法\nJSON.parse(value) JSON.stringify #  作用：JSON.parse的逆运算\nJS 数据 =\u0026gt; JSON字符串\n由于JS数据类型比JSON多，所以未必会转换成功，假如你在要转换的数据中加入了函数，那么很可能会报错，或者被浏览器忽略掉\n语法\nJSON.stringify(value) "});index.add({'id':27,'href':'/posts/2020-06-09-html5-label/','title':"HTML5标签总结",'content':"目录 #  脚本 \u0026lt;template\u0026gt; 通过 JavaScript 在运行时实例化内容的容器。 章节 \u0026lt;section\u0026gt; 文档中的一个章节。 \u0026lt;nav\u0026gt; 只包含导航链接的章节。 \u0026lt;article\u0026gt; 可以独立于内容其余部分的完整独立内容块。 \u0026lt;aside\u0026gt; 和页面内容关联度较低的内容——如果被删除，剩下的内容仍然很合理。 \u0026lt;header\u0026gt; 页面或章节的头部。 \u0026lt;footer\u0026gt; 页面或章节的尾部 \u0026lt;main\u0026gt; 文档中主要或重要的内容。 组织内容 \u0026lt;figure\u0026gt; 图片示例 \u0026lt;figcaption\u0026gt; 图片说明 文字形式 \u0026lt;time\u0026gt; 用于表示时间，兼容性较低 \u0026lt;mark\u0026gt; 高亮文字 \u0026lt;ruby\u0026gt; 注释文本，用于包裹rt，rp，用于显示如中文汉字和它的拼音等 \u0026lt;rt\u0026gt; ruby注释，如中文拼音 \u0026lt;rp\u0026gt; 不支持 ruby 注释显示的浏览器中提供友好的注释显示。 \u0026lt;bdi\u0026gt; 代表需要脱离 父元素文本方向的一段文本。它允许嵌入一段不同或未知文本方向格式的文本。 \u0026lt;wbr\u0026gt; 代表建议换行 (Word Break Opportunity) ，当文本太长需要换行时将会在此处添加换行符。 嵌入内容 \u0026lt;embed\u0026gt; 代表一个嵌入 的外部资源，如应用程序或交互内容。 \u0026lt;video\u0026gt; 代表一段视频 及其视频文件和字幕，并提供了播放视频的用户界面。 \u0026lt;audio\u0026gt; 代表一段声音 ，或音频流 。 \u0026lt;source\u0026gt; 为 \u0026lt;video\u0026gt; 或 \u0026lt;audio\u0026gt; 这类媒体元素指定媒体源 。 \u0026lt;track\u0026gt; 为 \u0026lt;video\u0026gt; 或 \u0026lt;audio\u0026gt; 这类媒体元素指定文本轨道（字幕） 。 \u0026lt;canvas\u0026gt; 代表位图区域 ，可以通过脚本在它上面实时呈现图形，如图表、游戏绘图等。 \u0026lt;svg\u0026gt; 定义一个嵌入式矢量图 。 \u0026lt;math\u0026gt; 定义一段数学公式 。 表单 \u0026lt;datalist\u0026gt; 代表提供给其他控件的一组预定义选项 。 \u0026lt;keygen\u0026gt; 代表一个密钥对生成器 控件。 \u0026lt;output\u0026gt; 代表计算值 。 \u0026lt;progress\u0026gt; 代表进度条 。 \u0026lt;meter\u0026gt; 代表滑动条 。 交互元素 \u0026lt;details\u0026gt; 代表一个用户可以(点击)获取额外信息或控件的小部件 。 \u0026lt;summary\u0026gt; 代表 \u0026lt;details\u0026gt; 元素的综述 或标题 。 \u0026lt;menuitem\u0026gt; 代表一个用户可以点击的菜单项。 \u0026lt;menu\u0026gt; 代表菜单。 "});index.add({'id':28,'href':'/posts/2020-06-07-async-use/','title':"async 的使用",'content':"async 的特点\n 它可以和 Promise 结合使用。 它能使异步函数更像是同步函数。 它的语法和结构会更像是标准的同步函数。  Promise 的使用 #  以一个摇色子案例为例：\n首先使用一个 Promise 函数封装一个三秒后返回 1 - 6 之间的随机数的函数，然后在调用时使用 .then() 方法获取返回的结果，如下：\nfunction fn(){ return new Promise((resolve, reject)=\u0026gt;{ setTimeout(()=\u0026gt;{ /* 产生一个 1-6之间的随机数 */ let n = parseInt(Math.random() * 6 + 1, 10) resolve(n) }) }) } fn().then( (data)=\u0026gt;{ console.log(\u0026#39;色子的点数是：\u0026#39;+data) }, ()=\u0026gt;{ console.log(\u0026#39;摇色子失败~\u0026#39;) } )  Math.random() 函数返回一个浮点, 从0到1，包含 0 但不包含 1\n 案例链接：https://codesandbox.io/s/icy-wildflower-29wpi?file=/src/index.js\nasync await 的使用 #  语法首先，await 只能在 async 中使用（强制规定），比如用以下两种方式调用上面的 fn 函数：\nlet n = await fn() // 语法错误 // 添加到async中: async function text() { let n = await fn() // 不会报错 } 将上面的 Promise 中的摇色子案例用 async await 的方式调用，如下：\nasync function text() { let n = await fn() // 注意这里要加括号才会有返回值  console.log(\u0026#39;色子的点数是：\u0026#39;+n) } text() // 色子的点数是：3 使用 try catch 获取错误 #  由于在上面的案例中，无法模拟失败，错误的信息，所以我们在摇色子的基础上添加一个猜大小的功能，猜大小函数每次都会判断摇到的筛子是否符合猜测的大小，符合就返回 resolve()，不符合就返回 reject()，如下：\nfunction 猜大小(猜测){ return new Promise((resolve, reject)=\u0026gt;{ setTimeout(()=\u0026gt;{ let n = parseInt(Math.random()*6+1, 10) if(n\u0026gt;3){ if(猜测===\u0026#39;大\u0026#39;){ resolve(n) }else{ reject(n) } }else{ if(猜测===\u0026#39;小\u0026#39;){ resolve(n) }else{ reject(n) } } }, 1000) }) } async function test() { try{ let n = await 猜大小(\u0026#39;大\u0026#39;) console.log(\u0026#39;猜对了，点数是\u0026#39;+n) } catch (error) { console.log(\u0026#39;猜错了，点数是\u0026#39;+error) } } test() 上面的代码，如果猜对，就会走 try{} 中的内容，如果猜错就会走 catch(e){} 中的内容，而错误内容就是 catch 的第一个参数\n Promise 与 async 的优缺点：Promise 的代码更简洁，async 的逻辑更清晰\n Promise.all 的使用 #  Promise.all 接收一个数组，数组里面的每一个函数都会返回一个 Promise。它也可以.then()，返回两个函数，第一个函数是必须所有函数都执行成功才会执行，后面一个函数是只要存在一个函数执行失败(或出错)立即执行。\n假如我们要调用两次上面的\u0026quot;猜大小\u0026quot;案例，可以使用如下的方法：\nPromise.all([猜大小(\u0026#39;大\u0026#39;), 猜大小(\u0026#39;大\u0026#39;)]).then( (data)=\u0026gt;{ console.log(\u0026#39;猜测成功：\u0026#39;+data) }, (e)=\u0026gt;{ console.log(\u0026#39;猜测失败：\u0026#39;+e) } ) await + Promise.all 的使用\n用 await 的方式多次调用上面的\u0026quot;猜大小\u0026quot;案例：\nasync function test() { try{ let n = await Promise.all([猜大小(\u0026#39;大\u0026#39;), 猜大小(\u0026#39;大\u0026#39;)]) console.log(\u0026#39;猜对了，点数是\u0026#39;+n) // 此处的n是一个数组  } catch (error) { console.log(\u0026#39;猜错了，点数是\u0026#39;+error) } } test() "});index.add({'id':29,'href':'/docs/2020-06-04-vuex-use/','title':"快速理解 Vuex 的方法（转载）",'content':"对于初学者，学 vue 简单，但是当第一次遇到 Vuex 概念的时候，理解难度往往骤然陡峭，会让人感到挫败感，挫败感来自于大多数教程文章用了大量篇幅来介绍Vuex较为复杂，却看完感觉没什么作用（不知道如何运用）的实现模式，本文就是要简而化之，让你秒懂。\n本质 #  Vuex 术语定义叫做『全局状态管理』，其实质就是一个全局变量，可以供不同组件间调用，更新，自动通知。 当然在具体实现的时候，这个全局变量其实是一个全局对象：this.$store,\n所以记住这个 store 对象，它就是 vuex。\n来龙去脉 #  facebook 以前在搞他的那个网页app的时候，尤其是在做消息模块的时候，各种全局通知和聊天信息，组件间互相通信非常混乱，老出bug，于是他们就发明了一种解决这个问题的设计模式，叫做 FLUX。\n这个设计模式是按照怎样的原则来解决通信混乱的问题呢？\n1. 单一数据源（Single Source of Truth） #  也就是说，store 是一个唯一全局变量（对象），不能搞多个，搞多个就乱了。\n2. 数据只读（Data is Read-Only） #  这个只读不是说完全不让读，而是不能让 store 外部直接操作数据，必须通过 store 内部方法（mutations）来操作数据。\n3. 数据更新必须是同步的（Mutations Are Synchronous） #  异步数据会很混乱，必须是同步操作模式。\n为什么是这3个原则，你不用管，反正 facebook 反复实验，按照这三个原则设计，问题就搞定了。\nfacebook 按照 FLUX 设计模式，开发了大名鼎鼎的 Redux库，React 必备搭配。Vue 看见此需求群众呼声很高，也配套了一个,也就是Vuex。\n所以，Redux 和 Vuex 都是对 Flux 这种设计模式的实现，别混为一谈。\nstore的内部 #  store 这个对象，肯定是挂载Vue上面的，就是按照下面这种方式挂：\nimport Vue from \u0026#39;vue\u0026#39; import Vuex from \u0026#39;vuex\u0026#39; Vue.use(Vuex) const store = new Vuex.Store({ state: { }, actions: { }, mutations: { }, getters: { }, modules: { } }) export default store 我们看到有这些 state，actions，mutations，modules 这些属性， 为啥一个实质是变量的对象搞这么复杂，这其实和Flux设计模式有关系，它的本质就是：「我的事情我自己来，你们（组件）别直接操作我，告诉我就行，我自己来」。\n下面一个一个讲：\nstate #  state，这个所谓的状态，其实就是数据，全局的数据。\n你在一个 vue 组件里，这样写，就可以获取这个数据：\ncomputed: { count () { return this.$store.state.count } } 这个count就是state下面定义的一个数据，怎么定义的呢：\nconst store = new Vuex.Store({ state: { count: 0 } }) 在那个挂载 store 对象的文件里，这样定义，非常符合直觉。 你这边写0，上面那边就读出0，你这边改成2了，上面就自动变成2，监听是默认的。\nmutations #  接着上面讲，你怎么把 count 改成2呢？\nthis.$store.state.count = 2 这样是不行的，前面讲过，你不要直接动 store 的数据，你需要告诉它，让他自己来处理。\n所以 store 自己先得有个处理方法，这就是 mutations:\nconst store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } } }) 这个方法就是 increment，很符合直觉。\n你在组件那里要做就是通知 store，激活这个 increment，怎么写呢：\nthis.$store.commit(\u0026#39;increment\u0026#39;) 注意，讲到这里，单词越来越多了，英语不好的同学需要记住对应关系，commit 就是触发一个事件，通知 store 执行 mutations 下的某个方法。\ngetters #  Vue 组件下面有个 computed 属性，一个组件自己用没问题，如果多个组件下都想使用一个共有的 computed 属性，那么这就是 store 里面的 getters。\n唉，英语不好真伤心啊，起那么多名字其实是一个东西。\nconst store = new Vuex.Store({ state: { todos: [ { id: 1, text: \u0026#39;...\u0026#39;, done: true }, { id: 2, text: \u0026#39;...\u0026#39;, done: false } ] }, getters: { doneTodos: state =\u0026gt; { return state.todos.filter(todo =\u0026gt; todo.done) } } }) 看到没，上面 getters 动态属性 doneTodos，就是拿 state 静态属性 todos 放进一个函数算了一遍。\nactions #  actions 很简单，就是异步的 mutations，咦？不对啊，前面我们讲 flux 三原则的时候，说过数据更新必须是同步的，这个还是英文的问题，Mutations Are Synchronous，说的是 mutation，但是有时候我们需要异步去请求数据，这个时候就需要 actions。\nconst store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { increment:function ({ commit }) { axios.get(\u0026#39;/add\u0026#39;).then((response) =\u0026gt; { commit(\u0026#39;increment\u0026#39;) }, (err) =\u0026gt; { console.log(err) }) } } }) 怎么触发 actions 里的 increment 呢？\nthis.$store.dispatch(\u0026#39;increment\u0026#39;) 我的天，又多了一个单词：dispatch， 知道为啥新手会觉得困难了吧？\n官方文档给的那个示例其实不是很好，官方只是说 action 必须 commit，但理解 actions 的关键在于它的使用场景是异步，因为 flux 的实质是同步，所以异步拿到数据后，必须通过 mutation 去更新数据，所以必须 commit；\nModules #  很多组件都共用 store 里面 state 来存数据，组件多了，时间久了，不利于管理。 于是就有这个 modules 模块\nconst moduleA = { state: { ... }, mutations: { ... }, actions: { ... }, getters: { ... } } const moduleB = { state: { ... }, mutations: { ... }, actions: { ... } } const store = new Vuex.Store({ modules: { a: moduleA, b: moduleB } }) store.state.a // -\u0026gt; `moduleA`\u0026#39;s state store.state.b // -\u0026gt; `moduleB`\u0026#39;s state 主要观察\nmodules: { a: moduleA, b: moduleB } 在调用的时候,就可以分别调用\nstore.state.a // -\u0026gt; `moduleA`\u0026#39;s state store.state.b // -\u0026gt; `moduleB`\u0026#39;s state 小结 #  看完这篇文章，你再去看官方文档，应该没问题了，但是如果我把官方文档的例子和其他信息全搬过来，你肯定会晕。\nvuex很简单，难就难在那几个设计原则你不知道，还有就是单词有点多，记不过来。\n看完文档后，你实验几次就知道怎么运用了。\n 本文转载自：\n   博客：larabase.com/post/193     掘金：https://juejin.im/post/5d452b50f265da03bd04ff34   "});index.add({'id':30,'href':'/posts/2020-06-04-wlfjscywv/','title':"JavaScript达到什么水平，可以写类似Vue的框架？",'content':"今天在看方方老师的课程时，看到一个很赞的回答，顺便记录下来鼓励一下自己。\n提问：JavaScript达到什么水平，可以写类似Vue的框架？ #  答：\n在编程界没有什么水平的定义，而是你先定一个目标，去实现它。要么实现了，要么实现不了。\n学习方式不是达到什么水平才去写什么，而是你写了什么才能达到什么水平。\n你要先去做，才能达到那个水平，而不是达到那个水平再去做，因为你没有做过是永远达不到那个水平的。\n先做在达到，做的时候去搜各种知识，不停的去迭代它，完善它。\n"});index.add({'id':31,'href':'/history/2020-06-04-vue-plugin-int/','title':"Vue插件安装",'content':"创建项目 #  # 指定目录下创建 vue create demo # 当前目录下创建 vue create . 分析\n? Please pick a preset: Manually select features ? Check the features needed for your project: (*) Babel ( ) TypeScript ( ) Progressive Web App (PWA) Support (*) Router (*) Vuex (*) CSS Pre-processors (*) Linter / Formatter \u0026gt;( ) Unit Testing ( ) E2E Testing ? Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n) ? Pick a linter / formatter config: (Use arrow keys) \u0026gt; ESLint with error prevention only ESLint + Airbnb config ESLint + Standard config ESLint + Prettier ? Pick additional lint features: (Press \u0026lt;space\u0026gt; to select, \u0026lt;a\u0026gt; to toggle all, \u0026lt;i\u0026gt; to invert selection) \u0026gt;(*) Lint on save ( ) Lint and fix on commit Sass 安装 #  安装sass的依赖包\nnpm install --save-dev sass-loader # sass-loader 依赖于 node-sass npm install --save-dev node-sass vue 中使用\nnew webpack.ProvidePlugin({ Vue: [\u0026#39;vue/dist/vue.esm.js\u0026#39;, \u0026#39;default\u0026#39;] }); "});index.add({'id':32,'href':'/history/2020-06-04-css-selector/','title':"CSS选择器总结",'content':"文章 #    思否：https://segmentfault.com/a/1190000009887677\n  知乎：https://zhuanlan.zhihu.com/p/89314067\n  "});index.add({'id':33,'href':'/posts/2020-06-01-js-mouse-event/','title':"JS 拖曳事件总结",'content':"常用的三个事件 #  mousedown #  当指针(鼠标)在元素上按下时触发\nmousemove #  当指针(鼠标)在元素上移动时触发\nmouseup #  当指针(鼠标)在元素上抬起时触发\n使用案例 #  demo.onmousedown = function(){ console.log(\u0026#39;鼠标已按下\u0026#39;) } demo.addEventListener(\u0026#39;mousedown\u0026#39;, function(e){ console.log(\u0026#39;鼠标已按下\u0026#39;) }) "});index.add({'id':34,'href':'/posts/2020-05-29-ajax-use/','title':"AJAX 的封装",'content':"原生 JS 实现 AJAX #  let request = new XMLHttpRequest() request.open(\u0026#39;get\u0026#39;, \u0026#39;http://jack.com:8002/xxx\u0026#39;) request.send() request.onreadystatechange = ()=\u0026gt;{ if(request.readyState === 4){ if(request.status \u0026gt;= 200 \u0026amp;\u0026amp; request.status \u0026lt; 300){ let string = request.responseText let object = window.JSON.parse(string) console.log(\u0026#39;请求成功!\u0026#39;) }else if(request.status \u0026gt;= 400){ console.log(\u0026#39;请求失败!\u0026#39;) } } } 封装一个 jQuery.ajax #  window.jQuery.ajax = function(url, method, body, successFn, failFn){ let request = new XMLHttpRequest() request.open(method, url) request.onreadystatechange = ()=\u0026gt;{ if(request.readyState === 4){ if(request.status \u0026gt;= 200 \u0026amp;\u0026amp; request.status \u0026lt; 300){ successFn.call(undefined, request.responseText) }else if(request.status \u0026gt;= 400){ failFn.call(undefined, request) } } } request.send(body) } 使 jQuery.ajax 满足 Promise 规则 #  window.jQuery.ajax = function({url, method, body, headers}){ return new Promise(function(resolve,reject){ let request = new XMLHttpRequest() request.open(method, url) for(let key in headers){ let value = headers[key] request.setRequestHeader(key, value) } request.onreadystatechange = ()=\u0026gt;{ if(request.readyState === 4){ if(request.status \u0026gt;= 200 \u0026amp;\u0026amp; request.status \u0026lt; 300){ resolve.call(undefined, request.responseText) }else if(request.status \u0026gt;= 400){ reject.call(undefined, request) } } } request.send(body) }) } "});index.add({'id':35,'href':'/history/dd3e7bbd/','title':"常用的HTML5标签",'content':"\u0026lt;canvas\u0026gt; 画布绘制长方形 #  Html\n\u0026lt;canvas id=\u0026#34;canvas\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; JavaScript\nDocument.getElementById() 方法获取HTML \u0026lt;canvas\u0026gt; 元素的引用。接着，HTMLCanvasElement.getContext() 方法获取这个元素的context——图像稍后将在此被渲染。\n由 CanvasRenderingContext2D 接口完成实际的绘制。fillStyle 属性让长方形变成绿色。fillRect() 方法将它的左上角放在(10, 10)，把它的大小设置成宽150高100。\nconst canvas = document.getElementById(\u0026#39;canvas\u0026#39;); // 获取 canvas 的 2d 上下文 const ctx = canvas.getContext(\u0026#39;2d\u0026#39;); ctx.fillStyle = \u0026#39;green\u0026#39;; ctx.fillRect(10, 10, 150, 100); \u0026lt;video\u0026gt; 的常用属性 #  src：视频的地址\nautoplay：设置自动播放（默认值为false）\nposter：视频的封面\n\u0026lt;!-- Simple video example --\u0026gt; \u0026lt;video src=\u0026#34;videofile.ogg\u0026#34; autoplay poster=\u0026#34;posterimage.jpg\u0026#34;\u0026gt; 抱歉，您的浏览器不支持内嵌视频，不过不用担心，你可以 \u0026lt;a href=\u0026#34;videofile.ogg\u0026#34;\u0026gt;下载\u0026lt;/a\u0026gt; 并用你喜欢的播放器观看! \u0026lt;/video\u0026gt; \u0026lt;!-- Video with subtitles --\u0026gt; \u0026lt;video src=\u0026#34;foo.ogg\u0026#34;\u0026gt; \u0026lt;!-- 设置视频字幕 --\u0026gt; \u0026lt;track kind=\u0026#34;subtitles\u0026#34; src=\u0026#34;foo.en.vtt\u0026#34; srclang=\u0026#34;en\u0026#34; label=\u0026#34;English\u0026#34;\u0026gt; \u0026lt;track kind=\u0026#34;subtitles\u0026#34; src=\u0026#34;foo.sv.vtt\u0026#34; srclang=\u0026#34;sv\u0026#34; label=\u0026#34;Svenska\u0026#34;\u0026gt; \u0026lt;/video\u0026gt; \u0026lt;audio\u0026gt; 的常用属性 #  src：可选属性，设置播放地址。你可以在audio元素中使用 \u0026lt;source\u0026gt; 元素来替代该属性指定嵌入的音频。\ncontrols：显示控制面板。如果设置了该属性，浏览器将提供一个包含声音，播放进度，播放暂停的控制面板，让用户可以控制音频的播放。\nvolume：播放的音量。值从0.0 (无声) 到 1.0 (最大声).\nloop：循环播放\nautoplay：设置自动播放（默认值为false）\nmuted：是否静音（默认值为false）\nHTML \u0026lt;audio\u0026gt; 元素用于在文档中表示音频内容。 \u0026lt;audio\u0026gt; 元素可以包含多个音频资源， 这些音频资源可以使用 src 属性或者\u0026lt;source\u0026gt; 元素来进行描述； 浏览器将会选择最合适的一个来使用。\n\u0026lt;section\u0026gt; 的使用 #  表示一个包含在 HTML 文档中的独立部分，它没有更具体的语义元素来表示，一般来说会有包含一个标题。有点类似于 div。\n"});index.add({'id':36,'href':'/docs/7bcd3815/','title':"科班 与 培训 的区别",'content':"科班生（术） #  科班生：一个本科生四年，学习计算机专业或软件专业\n学习路线\n 大一： 高数、线性代数、离散数学、概率论 大二：C语言/VB(二选一)、数据结构、算法 大三：面向对象、操作系统、网络  将计算机领域未来10到20年的知识入门\n培训生（技） #  培训生：通过培训学习专业知识\n技能：HTML、CSS、JavaScript、Vue\n只学技能只能保证你 5 年成长。\n推荐学习：数据结构、算法（算法读解）\n你永远都没有不那么有压力的时间，需要学习的技能太多\n"});index.add({'id':37,'href':'/posts/a0000001/','title':"Document API",'content':"Class 类名添加与删除 #  当点击 id 为 xxx 的元素时，如果 id 为 yyy 元素存在 active 的 class 样式就删除该 class 名，不存在就添加该 class 名\nxxx.onclick = function(){ yyy.classList.toggle(\u0026#39;active\u0026#39;) } 案例链接：https://jsbin.com/xoxelaj/1/edit?html,css,js,output\nString #  获取某一个索引对应的字符 (String.prototype.charAt()) #  var str = \u0026#39;wobuzaiyi\u0026#39; // 获取某一个索引对应的字符 str.charAt(0) // \u0026#34;w\u0026#34; // 获取某一个索引对应的字符的编码 -- String.prototype.charCodeAt() str.charCodeAt(0) // 119 -- \u0026#34;w\u0026#34;对应的字符编码 去掉字符串两边的空格 (String.prototype.trim()) #  \u0026#39; username \u0026#39;.trim() // \u0026#34;username\u0026#34; 字符串拼接 (Array.prototype.concat()) #  var s1 = \u0026#39;Hello\u0026#39; var s2 = \u0026#39;World\u0026#39; s1.concat(s2) // \u0026#34;HelloWorld\u0026#34; 截取字符串 (Array.prototype.slice()) #  从索引为 0 开始截取至索引为 2 不包括索引为 2\n\u0026#39;Hello\u0026#39;.slice(0, 2) // He 字符串生成 a 标签 #  var str = \u0026#39;wobuzaiyi\u0026#39; str.anchor() // \u0026#34;\u0026lt;a name=\u0026#34;undefined\u0026#34;\u0026gt;wobuzaiyi\u0026lt;/a\u0026gt;\u0026#34; Number #  // 获取 100 的 16 进制 (100).toString(16) // \u0026#34;64\u0026#34; Boolean #  在 boolean 中 new Boolean() 与普通的布尔值可能会有所不同，如下：\nvar b1 = false var b2 = new Boolean(false) if(b1){ console.log(\u0026#39;我是b1\u0026#39;) } if(b2){ console.log(\u0026#39;我是b2\u0026#39;) } // 由于b2是一个对象，所以它还是会执行 // 我是b2 "});index.add({'id':38,'href':'/posts/a0000007/','title':"字符串",'content':".charCodeAt() #  charCodeAt() 方法返回0到65535之间的整数，表示给定索引处的UTF-16代码单元 (在 Unicode 编码单元表示一个单一的 UTF-16 编码单元的情况下，UTF-16 编码单元匹配 Unicode 编码单元。但在——例如 Unicode 编码单元 \u0026gt; 0x10000 的这种——不能被一个 UTF-16 编码单元单独表示的情况下，只能匹配 Unicode 代理对的第一个编码单元) 。如果你想要整个代码点的值，使用 codePointAt()。\n"});index.add({'id':39,'href':'/posts/a0000006/','title':"字面量增强",'content':"字面量的含义 #  它写出来就代表它所展示的意思，例如：1, 2, 3, true, false, {}，很直观的量。\n相反的，像构造函数，或者复杂的对象，就不是字面量。\n新版进制区分 #  如之前的写法\n二进制\n1010101 // 85 八进制\n0777 // 511 ES6 的写法\n二进制\n0b1010101 // 85 八进制\n0o777 // 511 字符串支持 Unicode #  获取字符编码\n以获取16进制的 \u0026quot;你\u0026quot; 的字符串编码为例：\n\u0026#34;你\u0026#34;.charCodeAt().toString(16) // \u0026#34;4f60\u0026#34; \u0026quot;你\u0026quot; 使用的字节：\n这里的 \u0026quot;你\u0026quot; 只需要 1 个字符表示，如下\n\u0026#34;你\u0026#34;.length // 1 而 \u0026quot;𝌆\u0026quot; 的则需要两个字符表示\n\u0026#34;𝌆\u0026#34;.length // 2 也就是，\u0026quot;𝌆\u0026quot; === \u0026quot;\\uD834\\uDF06\u0026quot; 如下：\n\u0026#34;𝌆\u0026#34;.charCodeAt(0).toString(16) // \u0026#34;d834\u0026#34; \u0026#34;𝌆\u0026#34;.charCodeAt(1).toString(16) // \u0026#34;df06\u0026#34; \u0026quot;𝌆\u0026quot; 使用的字节：\n\u0026quot;d834\u0026quot;\n\u0026quot;df06\u0026quot;\n可以看到，之前只能用两个字符表示这类字节。而在ES6新添加了对 Unicode 编码的全面支持，可以通过一个字符编码来表示该字节了\n例如，表示日文的你\nString.fromCodePoint(0x2F804) // \u0026#34;你\u0026#34; \u0026#34;你\u0026#34;.length // 2 \u0026#34;你\u0026#34;.codePointAt(0) // 194564 \u0026#34;你\u0026#34;.codePointAt(0).toString(16) // \u0026#34;2f804\u0026#34; MDN 文档：String.fromCodePoint()\n"});index.add({'id':40,'href':'/posts/a0000002/','title':"新版变量声明：let 和 const",'content':"ES 6 新特性一览：https://frankfang.github.io/es-6-tutorials/\n教程：es6.ruanyifeng.com\n先学 ES 5 还是 ES 6 #  无聊的问题，ES 6 包含 ES 5，你无论如何都必须先学 ES 5，才能看懂 ES 6\nES 6 如何学 #   快速通览，然后使用 边使用边加深印象  自学的问题 #  你不知道一个语法为什么要存在\n 触类旁通，去看看其他语言有没有这个语法，怎么用的 反证法，如果不用这个语法，该怎么实现需求  let \u0026amp; const #  我用了两个月的时间才理解 let\n let 和 var 的区别 const 和 let 的区别 相关面试题  "});index.add({'id':41,'href':'/history/2020-04-25-%E7%AE%80%E5%8E%86%E6%80%8E%E4%B9%88%E5%86%99/','title':"简历怎么写",'content':"xxx\n目的 #  展示自己的优点，长处\n内容 #  基本信息 #  年龄、姓名、性别、目标职位（文件名格式：方方-应聘前端工程师.pdf）、学校\n联系方式（PDF可以写手机，网页版不要写手机，搜索引擎会搜到）：手机、邮箱、QQ、微信\n技能描述\n小程序制作：可以独立进行小程序开发，熟悉AAA，BBB，CCC相关API\n教育经历\n工作经历\n项目展示\n链接：博客链接、GitHub链接\n其他\n"});index.add({'id':42,'href':'/docs/2020-04-22-2020-interview-outline/','title':"2020年前端面试提纲",'content':"押题内容来自：https://xiedaimala.com/tasks/e67878e4-ef45-4545-9cad-a1946c6e21f1\n说明：\n  代码：答案直接展示相关代码\n  举例：举一个实际使用的案例\n  阐述：阐述问题的概念\n  HTML #    必考：你是如何理解 HTML 语义化的？\n举例\n  meta viewport 是做什么用的，怎么写？\n举例\n  你用过哪些 HTML 5 标签？\n举例\n  H5 是什么？\n阐述\n  CSS #    必考：两种盒模型分别说一下。\n举例\n  必考：如何垂直居中？\n分情况讨论\n  必考：flex 怎么用，常用属性有哪些？\n举例\n  必考：BFC 是什么？\n举例\n  CSS 选择器优先级\n举例\n  清除浮动说一下\n代码\n  原生 JS #    必考：ES 6 语法知道哪些，分别怎么用？\n举例\n  必考 Promise、Promise.all、Promise.race 分别怎么用？\n举例\n  必考：手写函数防抖和函数节流\n举例\n  必考：手写AJAX\n代码\n  必考：这段代码里的 this 是什么？\n看调用\n  必考：闭包/立即执行函数是什么？\n阐述\n  必考：什么是 JSONP，什么是 CORS，什么是跨域？\n举例\n  常考：async/await 怎么用，如何捕获异常？\n举例\n  常考：如何实现深拷贝？\n代码\n  常考：如何用正则实现 trim()？\n代码\n  常考：不用 class 如何实现继承？用 class 又如何实现？\n代码\n  常考：如何实现数组去重？\n代码\n  放弃：== 相关题目（反着答）\n（举例）性价比极低，可放弃\n  送命题：手写一个 Promise\n代码\n  DOM #   必考：事件委托 曾考：用 mouse 事件写一个可拖曳的 div  HTTP #   必考：HTTP 状态码知道哪些？分别什么意思？ 大公司必考：HTTP 缓存有哪几种？ 必考：GET 和 POST 的区别 Cookie V.S. LocalStorage V.S. SessionStorage V.S. Session  框架 Vue #   必考：watch 和 computed 和 methods 区别是什么？ 必考：Vue 有哪些生命周期钩子函数？分别有什么用？ 必考：Vue 如何实现组件间通信？ 必考：Vue 数据响应式怎么做到的？ 必考：Vue.set 是做什么用的？ Vuex 你怎么用的？ VueRouter 你怎么用的？ 路由守卫是什么？  框架 React #   必考：受控组件 V.S. 非受控组件 必考：React 有哪些生命周期函数？分别有什么用？（Ajax 请求放在哪个阶段？） 必考：React 如何实现组件间通信？ 必考：shouldComponentUpdate 有什么用？ 必考：虚拟 DOM 是什么？ 必考：什么是高阶组件？ React diff 的原理是什么？ 必考 Redux 是什么？ connect 的原理是什么？  TypeScript #   never 类型是什么？ TypeScript 比起 JavaScript 有什么优点？  Webpack #   必考：有哪些常见 loader 和 plugin，你用过哪些？ 英语题：loader 和 plugin 的区别是什么？ 必考：如何按需加载代码？ 必考：如何提高构建速度？ 转义出的文件过大怎么办？ 上面五题请看这个不错的参考：https://zhuanlan.zhihu.com/p/44438844  安全 #   必考：什么是 XSS？如何预防？ 必考：什么是 CSRF？如何预防？  开放题目 #   必考：你遇到最难的问题是怎样的？ 你在团队的突出贡献是什么？ 最近在关注什么新技术 有没有看什么源码，看了后有什么记忆深刻的地方，有什么收获  刁钻题目 #   代码 代码 (a ==1 \u0026amp;\u0026amp; a== 2 \u0026amp;\u0026amp; a==3) 可能为 true 吗？  超纲题 #   JS 垃圾回收机制 Eventloop 说一下  个性化题目 #   PWA echarts.js / d3.js three.js flutter SSR  注意事项 #    『很多』公司面试题都是常年不更新的，『可能』你搜该公司往年的面经，就能猜到今年的题目。\n  很多面试官的知识也是常年不更新的，你不要答得太『偏激』，应该了解大众的想法。\n  本押题主要强调答题思路，具体答案都可以搜到（不要用百度）\n  技巧 #   遇到比较抽象的题目就具体化（举例），遇到比较具体的题目就抽象化（阐述）\n  抽象题目搜知乎，代码题目搜 Stackoverflow 或博客\n  『XXX 的原理』这种题目一般都是说源代码思路，但你不需要看源码，直接看别人的博客即可（再次强调，不要用百度）\n  "});index.add({'id':43,'href':'/docs/2020-04-18-guanyuzhihu-naxiezhishi/','title':"关于知乎 \"哪些知识越了解越觉得『对这个世界很绝望』？\"",'content':"今天偶然在知乎上看到的一篇回答，刷新了我对90后现状的认识，以及资本主义的含义。\n引用文中的一张图，90后新名词：\n原文链接：哪些知识越了解越觉得『对这个世界很绝望』？ - Mushroobby的回答 - 知乎\n"});index.add({'id':44,'href':'/history/2020-04-12-lx%E4%B8%BB%E9%A2%98%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/','title':"lx主题中文文档",'content':"Hexo-Theme-Lx #   如果你喜欢本主题，请点击star收藏\n Live Demo:https://lx.js.org\n该子域名由 JS.ORG 提供。\n作者的博客:https://freezing.cool\nTelegram频道-hexo-theme-lx:https://t.me/themelx\n有任何疑问和建议请提交issue\n最近更新 #  V0.3.9 #   改善评论框 改善段间距  使用： #  获取最稳定的版本： #  https://github.com/blleng/hexo-theme-lx/releases\n解压后将文件夹命名为lx放在themes文件夹中。\n 推荐使用稳定版本(请勿使用V0.3.3和V0.3.5！！)\n 获取具有最新特性的版本： #  在博客根目录:\n$ git clone https://github.com/blleng/hexo-theme-lx themes/lx  不推荐这种方式。虽然我尽量保证没有bug后再推送至GitHub仓库，但正在开发中的版本仍可能有bug。\n 启用本主题： #  更改站点设置文件_config.yml:\ntheme: lx 主题的配置将在themes/lx/_config.yml中进行。\n功能配置 #   这里的说明并不完整，请参考themes/lx/_config.yml中的注释信息。\n 统计 #  引入了百度统计和谷歌统计。\n启用：在themes/lx/_config.yml填写:\ngoogle_analytics: ... ##谷歌统计ID baidu_analytics: ... ##百度统计ID 本地搜索 #  先下载插件hexo-generator-searchdb:\n$ npm install hexo-generator-searchdb -s 在themes/lx/_config.yml中配置:\nlocal_search: enable: true 更多配置详见themes/lx/_config.yml。\n评论 #  评论使用valine，官网：https://valine.js.org\n启用：在themes/lx/_config.yml填写:\ncomment: enable: true # true:启用 | false:停用 appid: ... #leancloud appid appkey: ... #leancloud appkey notify: false verify: false placeholder: 此处留言 #评论框文字 avatar: identicon #游客默认头像 guest_info: nick,mail,link #评论时需填写的内容（均为选填） pageSize: 10 #一次性展示的评论数 language: zh-cn 在文章头填入comment: true即可在该页面启用评论:\n--- date: ... title: ... categories: ... tags: ... comment: true //启用评论 mathjax: ... --- appid和appkey在leancloud创建应用后即可获取。\nSocial Links #  社交媒体链接，在themes/lx/_config.yml配置:\nsocial: enable: true links: Github: icon: gihub //font-awesmome图标名称 link: ... //链接地址 Mathjax #  支持数学公式和化学方程式。\n启用：在themes/lx/_config.yml填写:\nmathjax: enable: true ##true:启用 | false:停用 cdn: //cdn.bootcss.com/mathjax/2.7.5/latest.js?config=TeX-MML-AM_SVG 在文章头填入mathjax: true即可在该页面启用评论:\n--- date: ... title: ... categories: ... tags: ... comment: ... mathjax: true //启用Mathjax --- 字体设置 #  font: enable: true host: //fonts.googleapis.com codes: ##代码字体 enable: true family: Fira Code else: ##文字字体 enable: false family: 文章写作样式 #  文章摘要 #  在`\n`标签之前的内容将作为文章摘要在首页展示。\nNote tag #  可选用default、info、primary、success、warning、danger。\n示例：\n{%note default%} ### title content {%endnote%} Label tag #  可选用default、info、primary、success、warning、danger。\n示例：\n{%label default@content%} Button tag #  标准样式：\n{%btn url,content,hand-o-right fa-fw,title%} 说明：\nurl：指向的链接\ncontent：内容\nhand-o-right fa-fw：图标，可换成其他图标。fa-fw：fix width\ntitle：title\ncenter-quote tag #  示例：\n{%cq%} 人类的悲欢并不相通，我只觉得他们吵闹。\u0026lt;br\u0026gt;\u0026lt;strong\u0026gt;——鲁迅\u0026lt;/strong\u0026gt; {%endcq%} video tag #  示例：\n{% video url %} 说明：\nurl：视频链接\n文章截断 #  在文章中添加\u0026lt;!-- more --\u0026gt;即可在首页不显示该标签后的内容\n"});index.add({'id':45,'href':'/history/2019-10-27-css-grid-%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/','title':"CSS Grid 网格布局",'content':"案例 #  基础布局案例 #  语法\ndiv { display: grid; } 代码\nhtml \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS Bin\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;span\u0026gt;foo\u0026lt;/span\u0026gt; \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item item-1\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item-2\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item-3\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item-4\u0026#34;\u0026gt;4\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item-5\u0026#34;\u0026gt;5\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item-6\u0026#34;\u0026gt;6\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item-7\u0026#34;\u0026gt;7\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item-8\u0026#34;\u0026gt;8\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item-9\u0026#34;\u0026gt;9\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;span\u0026gt;bar\u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; CSS span { font-size: 2em; } #container{ display: grid; grid-template-columns: 50px 50px 50px; grid-template-rows: 50px 50px 50px; } .item { font-size: 2em; text-align: center; border: 1px solid #e5e4e9; } .item-1 { background-color: #ef342a; } .item-2 { background-color: #f68f26; } .item-3 { background-color: #4ba946; } .item-4 { background-color: #0376c2; } .item-5 { background-color: #c077af; } .item-6 { background-color: #f8d29d; } .item-7 { background-color: #b5a87f; } .item-8 { background-color: #d0e4a9; } .item-9 { background-color: #4dc7ec; }  效果：案例预览\n默认情况下，容器元素都是块级元素，但也可以设成行内元素。如下\ndiv { display: inline-grid; } 上面代码指定 div 是一个行内元素，该元素内部采用网格布局。效果：案例预览\n 注意，设为网格布局以后，容器子元素（项目）的 float、display: inline-block、display: table-cell、vertical-align 和 column-* 等设置都将失效。\n 布局宽高 #  容器指定了网格布局以后，接着就要划分行和列\n grid-template-columns 属性定义每一列的列宽。 grid-template-rows 属性定义每一行的行高。  案例\n.container { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; } 效果：案例预览\n也可以使用百分比单位\n.container { display: grid; grid-template-columns: 33.33% 33.33% 33.33%; grid-template-rows: 33.33% 33.33% 33.33%; } repeat()\n有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用 repeat() 函数，简化重复的值。上面的代码用 repeat() 改写如下。\n.container { display: grid; grid-template-columns: repeat(3, 33.33%); grid-template-rows: repeat(3, 33.33%); } 使用说明\n repeat() 接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。 repeat() 重复某种模式也是可以的。  案例\ngrid-template-columns: repeat(2, 100px 20px 80px); 这段代码定义了 6 列，第一列和第四列的宽度为 100px，第二列和第五列为 20px，第三列和第六列为 80px。\n预览：案例效果\n 本文部分内容摘自：CSS Grid 网格布局教程 - 阮一峰  "});index.add({'id':46,'href':'/history/2019-10-17-jquery%E5%B8%B8%E7%94%A8api%E6%80%BB%E7%BB%93/','title':"jQuery常用API总结",'content':".CSS\n获取指定CSS属性值\n$(element).css(\u0026#34;background-color\u0026#34;); 修改指定CSS属性值\n$(element).css(\u0026#34;color\u0026#34;,\u0026#34;red\u0026#34;) 修改多个属性值\n$(element).css({\u0026#39;background-color\u0026#39;:\u0026#39;red\u0026#39;,\u0026#39;color\u0026#39;:\u0026#39;blue\u0026#39;}) jQuery 中两个不合理的 API\n .hide() .show()  当你给一个本来就 display: none 的元素添加 .hide() 然后再 .show() 的时候，会发现它的 display 变成了 block\n这说明 jQuery 无法真正还原你原本的 display 属性，它只是猜测你的 display 属性\n获取父元素的子元素\n$(element).children() 克隆当前元素\n.clone(true) // 默认 false 添加 true 表示克隆当前元素所有内容，包含它的子元素， 添加，删除 class 样式\n$(element).addClass(\u0026#39;active\u0026#39;) $(element).removeClass(\u0026#39;active\u0026#39;) 动画执行完毕后执行事件\n.one(\u0026#39;transitionend\u0026#39;, (e)=\u0026gt;{ console.log(\u0026#39;当前动画执行完毕\u0026#39;) }) 返回当前元素在父元素的第 n 个位置的索引\nlet index = $(element).index() 获取存放元素的伪数组中索引为 index 的元素\n$(elements).eq(index) 给当前元素绑定执行指定事件\n.trigger(\u0026#39;click\u0026#39;) 获取当前兄弟元素中的所有除了当前元素以外 指定选择器 的元素\n.siblings(\u0026#39;.blue\u0026#39;) 鼠标进入元素事件\n$(element).on(\u0026#39;mouseenter\u0026#39;, function(){ }) 鼠标离开元素事件\n$(element).on(\u0026#39;mouseleave\u0026#39;, function(){ }) "});index.add({'id':47,'href':'/history/2019-10-17-js%E5%B8%B8%E7%94%A8api%E6%80%BB%E7%BB%93/','title':"JS 常用API总结",'content':"获取元素 #  根据 id 或 class 获取元素\ndocument.querySelector(\u0026#39;#demo\u0026#39;) 文档对象模型Document引用的querySelector()方法返回文档中与指定选择器或选择器组匹配的第一个 html元素Element。 如果找不到匹配项，则返回null。\n根据 id 或 class 获取元素列表\n与上面的区别是返回的是多个元素组成的伪数组\ndocument.querySelectorAll(\u0026#39;#demo\u0026#39;) 判断类型 #  instanceof #  instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。\n语法\nobject instanceof constructor MDN 文档 instanceof\ntoString #  toString() 方法返回一个表示该对象的字符串。例如：\n判断当前变量是元素还是数组\nvar obj = { } var arr = []; console.log(Object.prototype.toString.call(arr)); 创建元素 #  创建标签并添加到元素中\n// 创建一个新的段落p元素,然后添加到body的最尾部 var p = document.createElement(\u0026#34;p\u0026#34;); document.body.appendChild(p); 给元素设置 class 名\nelement.className = \u0026#39;demo\u0026#39; 处理事件 #  请求成功处理函数\nelement.onload = function(){ alert(\u0026#39;打钱成功\u0026#39;) } 请求失败处理函数\nelement.onerror = function(){ alert(\u0026#39;打钱失败\u0026#39;) } 触发事件 #  事件函数\n点击事件案例\n两个参数：事件类型、回调函数\nelement.addEventListener(\u0026#39;click\u0026#39;, (e)=\u0026gt;{ // 点击事件的回调函数内容 }) 获取当前事件的API\nelement.onclick = function(e){ e.currentTarget.remove() // 表示删除当前事件的element } 数据格式转换 #  string 转 number\n语法：\nparseInt(string, radix)  上面的案例将一个字符串 string 转换为 radix 进制的整数， radix 为介于2-36之间的数。\n 浏览器相关 #  当前窗口是否显示\n浏览器 标签页被隐藏或显示的时候会触发 visibilitychange 事件\ndocument.addEventListener(\u0026#34;visibilitychange\u0026#34;, function() { console.log( document.visibilityState ); }); 所以当 document.hidden 值为 false 时，表示当前窗口正在显示，当它的值为 true 时，表示当前窗口已隐藏。可以使用这个值判断当前窗口是否隐藏，如下：\ndocument.addEventListener(\u0026#39;visibilitychange\u0026#39;, function(){ if(document.hidden) { console.log(\u0026#39;当前窗口被隐藏\u0026#39;) }else { console.log(\u0026#39;当前窗口没有被隐藏\u0026#39;) } }) 其他 #  伪随机数\n函数返回一个浮点, 伪随机数在范围[0，1)，也就是说，从0（包括0）往上，但是不包括1（排除1），然后您可以缩放到所需的范围\nMath.random() 案例：\n获取一个十进制的number类型的随机数\nconsole.log(parseInt(Math.random()*100000, 10)) 定时器 #  每秒打出 一个 n\nsetInterval(()=\u0026gt;{ n += 1; console.log(n) }, 1000) 清除定时器\nwindow.clearInterval(time)  循环 #  forEach() 方法对数组的每个元素执行一次提供的函数。\n语法\narr.forEach(callback[, thisArg]); MDN 文档 arr.forEach\n追加 #  push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。\n语法\narr.push(element1, ..., elementN) MDN 文档 arr.push\n"});index.add({'id':48,'href':'/history/2019-10-17-yarn%E5%85%A5%E9%97%A8/','title':"yarn 入门",'content':"yran 命令使用\n初始化\nyarn init 添加依赖\nyarn add [package] yarn add [package]@[version] yarn add [package]@[tag] 将依赖添加到不同类别的依赖项中\n添加到 devDependencies, peerDependencies, 或 optionalDependencies 的方法：\nyarn add [package] --dev yarn add [package] --peer yarn add [package] --optional 升级依赖\nyarn upgrade [package] yarn upgrade [package]@[version] yarn upgrade [package]@[tag] 删除依赖\nyarn remove [package] 安装项目的所有依赖项\nyarn 或\nyarn install "});index.add({'id':49,'href':'/history/2019-10-17-npm%E5%85%A5%E9%97%A8/','title':"npm 入门",'content':"npm常用命令 #  npm更新 #  npm install npm@latest -g # 最新稳定版全局安装 npm install npm@4.2.1 -g # 指定版本全局安装 包安装 #  首先初始化，在需要安装的目录下输入\nnpm init -y # 默认配置 安装\nnpm install xxx # 安装 npm i xxx # 简写 # 安装一些常用库: npm i jquery npm i vue npm i bootstrap # 安装指定版本 npm i jquery@3.1.0 在根目录下的 package.json 中有每个库的版本号，如\n\u0026#34;dependencies\u0026#34;: { \u0026#34;bootstrap\u0026#34;: \u0026#34;^4.3.1\u0026#34;, \u0026#34;jquery\u0026#34;: \u0026#34;^3.4.1\u0026#34;, \u0026#34;vue\u0026#34;: \u0026#34;^2.6.10\u0026#34; } 当移动当前根目录的项目时，即时删除掉 node_modules 文件夹，只要在当前目录下执行：\nnpm i # 注意命令后不要加任何其他的东西 即可恢复之前所有的库，版本也是之前对应的。\n如何搜索每个库 npm 安装指令，谷歌搜索，库名称 npm 即可\n卸载包\nnpm uninstall xxx # 卸载指定包 更新\nnpm update xxx # 更新指定包 配置信息 #  自定义配置信息初始化\nnpm init 配置信息\npackage name: (npm-1.0) npm-demo # 包的名称(npm-demo) version: (1.0.0) # 包的版本号，默认(1.0.0)，回车选择默认 description: xxx # 添加说明 entry point: (index.js) # 包的入口文件，默认(index.js) # 接下来的配置也可以直接回车即可 配置信息文件\n{ \u0026#34;name\u0026#34;: \u0026#34;npm-demo\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { // 指定命令  \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;keywords\u0026#34;: [], \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, // 作者  \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, // 许可证  \u0026#34;dependencies\u0026#34;: { // 安装的库以及版本  \u0026#34;bootstrap\u0026#34;: \u0026#34;^4.3.1\u0026#34;, \u0026#34;jquery\u0026#34;: \u0026#34;^3.4.1\u0026#34;, \u0026#34;vue\u0026#34;: \u0026#34;^2.6.10\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { // 不会在生产环境下使用的库  \u0026#34;webpack\u0026#34;: \u0026#34;^4.41.2\u0026#34; } }  注：Json 格式数据是不支持注释的，如果要更改配置信息，请勿添加类似上面的注释\n 其中 \u0026ldquo;scripts\u0026rdquo; 表示指定命令，比如运行上面 scripts 中的 test 命令\nnpm run test # 执行 \u0026#34;test\u0026#34; 属性中的命令 如果只希望该包在开发环境下使用，而不是在生产环境下使用，以安装 webpack 为例\nnpm i webpack --save-dev 命令总结 #  常用 #  初始化 npm init\n安装项目的所有依赖 npm install\n查看 xxx 的命令及帮助信息 npm help xxx\n搜索\nnpm search xxx # 搜索 xxx 安装\nnpm install xxx # 在 npm 中搜索并安装 npm install xxx -g # 在 npm 中搜索并安装 xxx (全局) npm install xxx -D # 安装并将依赖信息添加到 package.json 的 devDependencies 属性中 npm install xxx@1.0.2 # 安装指定版本，不指定默认安装最新认稳定版 卸载\nnpm uninstall -D # 卸载并将指定信息从 package.json 的 devDependencies 属性中移除 更新\nnpm updata xxx # 更新 npm updata xxx -g # 全局更新 查看安装路径( node_modules  文件的安装路径)\nnpm root # 查看局部安装路径 npm root -g # 查看全局安装路径 查看已安装依赖\nnpm list # 默认列出所有依赖 npm list -g # 列出全局已安装依赖 查看模块 (依赖) 注册信息\nnpm view xxx versions # 查看 xxx 的所有版本 npm view xxx dependencies # 列出 xxx 的所有依赖信息 "});index.add({'id':50,'href':'/history/2019-10-04-es6%E6%96%B0%E7%89%B9%E6%80%A7/','title':"ES6新特性",'content':"记录学习 ES6 语法的过程\n本文部分内容摘自：http://es6.ruanyifeng.com/\nvar 的缺陷 #  变量会提升，很难控制变量的作用域\n案例1\nfunction fn(){ if(true){ console.log(a) }else{ var a console.log(2) } } fn()  会打出 undefined，理论上应该报错，但因为变量声明在 if 语句前，所以值变成了 undefine\n 案例2\n{ var a = 2 } console.log(a)  依然会打出 2\n let #  let 的优点 #   let 的作用域只在最近的 {} 内 let 无法在声明之前使用该变量 let 已经声明的变量无法再次声明  作用域 #  for 循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。\nfor (let i = 0; i \u0026lt; 3; i++) { let i = \u0026#39;abc\u0026#39;; console.log(i); } 案例1\n{ let a = 2 } console.log(a)  会报错，因为 let 不会变量提升，只会作用在当前 {} 内的作用域\n 案例2\n{ let a = 2 console.log(a) { let a = 3 console.log(a) { let a = 4 console.log(a) } } }  只会打出当前作用域内的 a 的值\n 案例3\nif(true){ let a = 2; console.log(\u0026#39;true\u0026#39;) }else { console.log(\u0026#39;false\u0026#39;) } console.log(a)  依然会报错，let 的作用域只看 {}\n 案例4\n{ let a = 1 console.log(a) let a = 2 console.log(a) }  报错，已经声明的变量无法再次声明\n 声明 #  { console.log(a) let a = 2 }  会报错，不能在未声明时使用该变量 ( 英文含义 Temp Dead Zone )\n 声明变量\nlet {a, b, c, d, e} = fn() function fn(){ return { a: 1, b: 2, c: 3, d: 4, e: 5 } } console.log(a, b, c, d, e) 函数传参\nfunction fn({a, b, c, d, e}){ console.log(a, b, c, d, e) } fn({ a: 1, b: 2, c: 3, d: 4, e: 5 }) 变量转换\nlet a = 1; let b = 3; [a, b] = [b, a]; console.log(a); // 3 console.log(b); // 1 箭头函数\nlet fn = ()=\u0026gt;{} 现在有了块级作用域，就可以不用匿名函数自调用的方法防止全局变量了\n// IIFE 写法 (function () { var tmp = ...; ... }()); // 块级作用域写法 { let tmp = ...; ... } 由于浏览器限制，块级作用域声明函数会类似 var 变量提升，例如：\n{ { function fn(){ console.log(3) } } fn() } fn() 但是使用函数表达式就不会提升，所以建议优先使用函数表达式\n// 块级作用域内部的函数声明语句，建议不要使用 { let a = \u0026#39;secret\u0026#39;; function f() { return a; } } // 块级作用域内部，优先使用函数表达式 { let a = \u0026#39;secret\u0026#39;; let f = function () { return a; };  ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。\n const #   const 的作用域和 let 相同 const 声明必须赋一个值 const 声明的是常量，无法重新赋值  const 声明的常量内的值并不是无法改变，而是const 声明的容器本身无法改变无法重新赋值。\n案例\nlet b = { name: \u0026#39;demo\u0026#39; } const a = b b = { cos: \u0026#39;jj\u0026#39; } console.log(a) 案例\n{ const a = 3 a = 4 }  报错，无法重新赋值\n Class #  传统的方法构造函数\nfunction Point(x, y) { this.x = x; this.y = y; } Point.prototype.toString = function () { return \u0026#39;(\u0026#39; + this.x + \u0026#39;, \u0026#39; + this.y + \u0026#39;)\u0026#39;; }; var p = new Point(1, 2); 使用 Class 创建构造函数\nclass Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return \u0026#39;(\u0026#39; + this.x + \u0026#39;, \u0026#39; + this.y + \u0026#39;)\u0026#39;; } } 使用\nclass Bar { doStuff() { console.log(\u0026#39;stuff\u0026#39;); } } var b = new Bar(); b.doStuff() // \u0026#34;stuff\u0026#34; 分割线\n 以下是教程内容\nECMAScript 和 JavaScript 到底是什么关系？\n  规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，版本号就是 X.X 版等。\n  该标准从一开始就是针对 JavaScript 语言制定的，但由于商标问题以及语言标准制定者想保持中立，所以名称叫 ECMAScript\n  简单来说就是 ECMAScript 表示 JavaScript 的版本\n  "});index.add({'id':51,'href':'/history/2019-10-03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/','title':"面向对象",'content':"面向对象以及命名空间\n面向对象 #  OO 编程 全称 Object Oriented 编程 \u0026mdash; 也就是面向对象编程\n命名空间 #  // 全局命名空间 var MYAPP = MYAPP || {}; 式子的原理\n或 a || b 与 且 a \u0026amp;\u0026amp; b ，的值基本上不可能是 true 或 false 本身，他们的值只能从一个为 true 或者为 false 的值中选一个\n复习知识\n五个 false 值：0, NaN, '', null, undefined\n且 a \u0026amp;\u0026amp; b\n案例`：\n1 \u0026amp;\u0026amp; 0 // 返回值是 0 1 \u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 2 // 返回值是 0 1 \u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 2 \u0026amp;\u0026amp; 3 \u0026amp;\u0026amp; 4 // 返回值是 0 结论：在 \u0026amp;\u0026amp; 中，只要第一 false 值出现，那就返回这个 false 对应的值。不会再查看后面对应的值为真或为假，因为只要出现一个false值就说明整个式子都是假\n案例2：\n1 \u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 2 \u0026amp;\u0026amp; console.log(3) // 返回 0 console.log(2) \u0026amp;\u0026amp; 1 \u0026amp;\u0026amp; 0 // 返回 undefined 并在控制台输出 2  此处 console.log(2) 的值是 undefined ，console.log() 中不论传入什么值，它的值都是 undefined\n 案例3：\n1 \u0026amp;\u0026amp; 2 // 返回的值是 2 1 \u0026amp;\u0026amp; 2 \u0026amp;\u0026amp; 3 // 返回的值是 3 或 a || b\n案例1：\n0 || undefined || null || 1 // 返回 1 0 || undefined || 1 || 0 || 2 // 返回 1 或 || 的值如果存在为 true 的值，只会返回第一个为 true 的值\n案例2：\n0 || undefined // 返回 undefined 0 || undefined || null // 返回 null 由上面的案例推出\n判断 b 的值是否存在(是否为false)，如果存在 a = b 如果不存在 a = {}\nvar a = b || {} // 原理 if(b){ a = b }else{ a = {} } 再将 b 换为 a\n那就是 判断 a 的值是否存在(是否为false)，如果存在 a = a 如果不存在 a = {}\nvar a = a || {} // 原理 if(b){ a = a }else{ a = {} }  由此可推出 var MYAPP = MYAPP || {}; 的原理\n "});index.add({'id':52,'href':'/history/2019-10-03-jquery%E5%88%B6%E4%BD%9C%E8%BD%AE%E6%92%AD/','title':"jQuery制作轮播",'content':"jQuery 中两个不合理的 API\n .hide() .show()  当你给一个本来就 display: none 的元素添加 .hide() 然后再 .show() 的时候，会发现它的 display 变成了 block\n这说明 jQuery 无法真正还原你原本的 display 属性，它只是猜测你的 display 属性\n使用的 API #  添加，删除 class 样式\n$(element).addClass(\u0026#39;active\u0026#39;) $(element).removeClass(\u0026#39;active\u0026#39;) 返回当前元素在父元素的第几个位置的索引\nlet index = $(element).index() 获取存放元素的伪数组中索引为 index 的元素\n$(elements).eq(index) 给当前元素执行指定绑定事件\n.trigger(\u0026#39;click\u0026#39;) 获取当前兄弟元素中的所有 指定选择器 的元素\n.siblings(\u0026#39;.blue\u0026#39;) 鼠标进入元素事件\n$(element).on(\u0026#39;mouseenter\u0026#39;, function(){ }) 鼠标离开元素事件\n$(element).on(\u0026#39;mouseleave\u0026#39;, function(){ }) 定时器\n每秒打出 一个 n\nsetInterval(()=\u0026gt;{ n += 1; console.log(n) }, 1000) 清除定时器\nwindow.clearInterval(time) 轮播自动播放原理 #  利用余数，不断循环的打出 0 1 2\nlet n = 0; console.log(n%3) setInterval(()=\u0026gt;{ n += 1; console.log(n%3) }, 1000)  利用这个方法就可以把对应的按钮打出\n 自动点击 button\n获取对应按钮 ( 使用 jQuery 的 .eq(index) ) 然后执行点击事件\nelements.eq(index).trigger(\u0026#39;click\u0026#39;) "});index.add({'id':53,'href':'/history/jquery%E8%BD%AE%E6%92%AD%E6%A1%88%E4%BE%8B/','title':"jQuery制作轮播",'content':"使用 jQuery 写轮播\n写代码要讲究 内容，样式，行为的分离\n  html - 内容\n  css - 样式\n  js - 行为\n  "});index.add({'id':54,'href':'/history/2019-10-03-%E8%87%AA%E5%88%B6jquery/','title':"自制jQuery",'content':"原生 JS 实现 jQuery\njQuery 官网的三个下载文件\n 压缩的 未压缩的 搜索 阮一峰 source map  用到的API #  arr.forEach #  forEach() 方法对数组的每个元素执行一次提供的函数。\n语法\narr.forEach(callback[, thisArg]); MDN 文档 arr.forEach\narr.push #  push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。\n语法\narr.push(element1, ..., elementN) MDN 文档 arr.push\ninstanceof #  instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。\n语法\nobject instanceof constructor MDN 文档 instanceof\n封装两个函数 #  首先在 html 中添加一个无序列表\n\u0026lt;body\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li id=\u0026#34;item1\u0026#34;\u0026gt;选项1\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026#34;item2\u0026#34;\u0026gt;选项2\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026#34;item3\u0026#34;\u0026gt;选项3\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026#34;item4\u0026#34;\u0026gt;选项4\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026#34;item5\u0026#34;\u0026gt;选项5\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; 排他方式获取子元素 #  获取除了当前元素以外的所有兄弟姐妹元素\nfunction getSiblings(node){ let allChildren = node.parentNode.children let array = { length: 0 } for (let i = 0; i \u0026lt; allChildren.length; i++) { if (allChildren[i] !== node) { array[array.length] = allChildren[i] array.length += 1 } } return array } console.log(getSiblings(item3)) 操作 class 样式 #  添加多个 class 样式\nfunction addClass(node, classes){ classes.forEach( (value) =\u0026gt; node.classList.add(value) ) } addClass() 添加移除 class\nfunction setClass(node, classes){ for( let key in classes){ if(classes[key]){ node.classList.add(key) }else { node.classList.remove(key) } } } /* 给 id 为 item3 的元素添加 a b class名，移除 c */ setClass( item3, {a: true, b: false, c: true} ) 优化\nfunction setClass(node, classes){ for(let key in classes){ let value = classes[key] let methodName = value ? \u0026#39;add\u0026#39; : \u0026#39;remove\u0026#39; node.classList[methodName](key) } } setClass( item3, {a: true, b: false, c: true} ) 给两个函数添加命名空间 #  在 window 上添加命名空间\n/* --------------- 命名空间 --------------- */ window.cndom = {} cndom.getSiblings = function (node) { let allChildren = node.parentNode.children let array = { length: 0 } for (let i = 0; i \u0026lt; allChildren.length; i++) { if (allChildren[i] !== node) { array[array.length] = allChildren[i] array.length += 1 } } return array } cndom.setClass = function (node, classes) { for (let key in classes) { let value = classes[key] let methodName = value ? \u0026#39;add\u0026#39; : \u0026#39;remove\u0026#39; node.classList[methodName](key) } } console.log(cndom.getSiblings(item2)) cndom.setClass(item2, { a: true, b: false, c: true }) 将函数添加到 Node 的原型链\nNode.prototype.getSiblings = function () { let allChildren = this.parentNode.children let array = { length: 0 } for (let i = 0; i \u0026lt; allChildren.length; i++) { if (allChildren[i] !== this) { array[array.length] = allChildren[i] array.length += 1 } } return array } Node.prototype.setClass = function (classes) { for (let key in classes) { let value = classes[key] let methodName = value ? \u0026#39;add\u0026#39; : \u0026#39;remove\u0026#39; this.classList[methodName](key) } } console.log(item2.getSiblings()) item2.setClass({ a: true, b: false, c: true }) 自己创建一个函数，返回两个方法\nwindow.Node2 = function(node){ return { getSiblings () { let allChildren = node.parentNode.children let array = { length: 0 } for (let i = 0; i \u0026lt; allChildren.length; i++) { if (allChildren[i] !== node) { array[array.length] = allChildren[i] array.length += 1 } } return array }, setClass (classes) { for (let key in classes) { let value = classes[key] let methodName = value ? \u0026#39;add\u0026#39; : \u0026#39;remove\u0026#39; node.classList[methodName](key) } } } } let node2 = Node2(item3) console.log(node2.getSiblings()) node2.setClass({ a: true, b: false, c: true }) 添加一个 if 判断，如果是字符串就使用 querySelector 方法获取 元素\nwindow.Node2 = function(nodeOrSelector){ let node if(typeof nodeOrSelector === \u0026#39;string\u0026#39;){ node = document.querySelector(nodeOrSelector) }else{ node = nodeOrSelector } return { getSiblings () { let allChildren = node.parentNode.children let array = { length: 0 } for (let i = 0; i \u0026lt; allChildren.length; i++) { if (allChildren[i] !== node) { array[array.length] = allChildren[i] array.length += 1 } } return array }, setClass (classes) { for (let key in classes) { let value = classes[key] let methodName = value ? \u0026#39;add\u0026#39; : \u0026#39;remove\u0026#39; node.classList[methodName](key) } } } } let node2 = Node2(\u0026#39;#item3\u0026#39;) console.log(node2.getSiblings()) node2.setClass({ a: true, b: false, c: true }) jQuery的由来 #  优化代码，去除之前的方法，添加两个新的示例方法\nwindow.jQuery = function(nodeOrSelector){ let nodes = {} /* -- if 判断变量是否为 字符串(string) 如果是，则声明一个变量，变量中存的就是 通过 querySelectorAll 获取的伪数组集合， 然后将这个伪数组集合放到事先声明的 nodes 伪数组中 -- */ if(typeof nodeOrSelector === \u0026#39;string\u0026#39;){ let temp = document.querySelectorAll(nodeOrSelector) for(let i = 0; i \u0026lt; temp.length; i++){ nodes[i] = temp[i] } nodes.length = temp.length /* -- else if 判断是否为节点，也就是单个元素， 如果是单个元素，也把它放到 nodes伪数组中，并将 length 改为 1 -- */ }else if(nodeOrSelector instanceof Node){ nodes = { 0: nodeOrSelector, length: 1 } } /* -- 传入一个数组，然后使用 forEach() 遍历数组, 将数组的每一项的值 (value) 作为参数传入 forEach() 方法中的箭头函数中, 然后使用 for 循环遍历伪数组 nodes 给 nodes 的每一个元素都添加传入的数组值 (value) 遍历多少次由数组值的数量决定, -- */ nodes.addClass = function(classes){ classes.forEach((value)=\u0026gt;{ for (let i = 0; i \u0026lt; nodes.length; i++){ nodes[i].classList.add(value) } }) } /* -- 通过 if 判断是否传入了参数， 如果没有传入参数则创建一个数组，然后for循环遍历nodes 使用 .push 方法将nodes中每一项元素的文本内容存入 texts 中 如果传入了参数，就遍历nodes每一项元素，然后将每一项的文本内容都改为传入的 text -- */ nodes.text = function(text){ if(text === undefined){ let texts = [] for(let i = 0; i \u0026lt; nodes.length; i++){ texts.push(nodes[i].textContent) } return texts }else { for(let i = 0; i \u0026lt; nodes.length; i++){ nodes[i].textContent = text } } } return nodes } let node2 = jQuery(\u0026#39;ul \u0026gt; li\u0026#39;) console.log(node2.text()) node2.text(\u0026#39;hi\u0026#39;) node2.addClass([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]) 使用jQuery #   注意 如果存储通过 jQuery 获取的元素，最好在变量前加 $ 这样更容易区分\n 首先要引入一个 jQuery 库，可以引入 cdn ，也可以引入本地文件\n添加 class 样式 #  以数组的方式分别给对应元素添加 class 样式\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS Bin\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://code.jquery.com/jquery-3.0.0.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;选项1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;选项2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;选项3\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;选项4\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;选项5\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; css 部分\n.red { background-color: red; } .blue { background-color: blue; } .yellow { background-color: yellow; } js\nlet $node = jQuery(\u0026#39;ul \u0026gt; li\u0026#39;) let classes = [\u0026#39;red\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;] $node.addClass(function(index, currentClass){ return classes[index] }) JSBin 链接：https://jsbin.com/qosedohafa/3/edit?html,css,js,output\n链式操作 #  批量删除当前 class 样式，再批量追加 class 样式\nhtml\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS Bin\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://code.jquery.com/jquery-3.0.0.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li class=\u0026#34;red\u0026#34;\u0026gt;选项1\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;red\u0026#34;\u0026gt;选项2\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;red\u0026#34;\u0026gt;选项3\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;red\u0026#34;\u0026gt;选项4\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;red\u0026#34;\u0026gt;选项5\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;button id=\u0026#34;demo\u0026#34;\u0026gt;点击\u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; css\n.red { background-color: red; } .blue { background-color: blue; } .yellow { background-color: yellow; } js\nlet $node = jQuery(\u0026#39;ul \u0026gt; li\u0026#39;) demo.onclick = function(){ $node.removeClass(\u0026#39;red\u0026#39;) .addClass(\u0026#39;blue\u0026#39;) } JSBin 链接：https://jsbin.com/xeziwafasi/1/edit?html,css,js,output\n"});index.add({'id':55,'href':'/history/2019-10-01-mvvm/','title':"MVVM",'content':"复习 MVC 以及使用 MVVM\naxios #  cdn\nbootcdn: https://www.bootcdn.cn/\n引入axios #  \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/axios/0.19.0/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  在 bootcdn 中搜索 axios\n 使用axios #  基本用法可以查看文档\naxios 项目地址 https://github.com/axios/axios\n发送请求案例\naxios.get(\u0026#39;/books/1\u0026#39;).then(function ({data}) { let originalHtml = $(\u0026#39;#app\u0026#39;).html() let newHtml = originalHtml.replace(\u0026#39;__name__\u0026#39;,data.name) .replace(\u0026#39;__number__\u0026#39;,data.number) $(\u0026#39;#app\u0026#39;).html(newHtml) }) axios.put(\u0026#39;/books/1\u0026#39;).then(function(){ $(\u0026#39;#number\u0026#39;).text(result) }) ES6 新语法 #  声明 #  之前\nlet response = { config:{ method:\u0026#39;methodxxx\u0026#39;, url:\u0026#39;urlxxx\u0026#39;, data:\u0026#39;dataxxx\u0026#39; } } let config = response.config let method = config.method let url = config.url let data = config.data console.log(config) console.log(method) console.log(url) console.log(data) 简化\nlet response = { config:{ method:\u0026#39;methodxxx\u0026#39;, url:\u0026#39;urlxxx\u0026#39;, data:\u0026#39;dataxxx\u0026#39; } } let config = response.config let {method, url, data} = config console.log(config) console.log(method) console.log(url) console.log(data) 再简化\nlet response = { config:{ method:\u0026#39;methodxxx\u0026#39;, url:\u0026#39;urlxxx\u0026#39;, data:\u0026#39;dataxxx\u0026#39; } } function fn(response){ let {config:{method, url, data}} = response console.log(method) console.log(url) console.log(data) } fn(response) jQuery #  事件委托\n$(\u0026#39;#app\u0026#39;).on(\u0026#39;click\u0026#39;,\u0026#39;#addOne\u0026#39;,function(){ let text = $(\u0026#39;#number\u0026#39;).text() let result = text - 0 + 1 $(\u0026#39;#number\u0026#39;).text(result) })  表示在点击#app中的元素时，只要有符合 #addOne 的元素被点击，则执行下面的事件\n 给元素添加 html 内容\n$(element).html(content) 给元素绑定this\naddOne.bind(this) 复习MVC #  代码链接 #  未封装代码：https://github.com/ChenNing02/git-hunger/tree/master/MVVM/1_books\nMVC封装：https://github.com/ChenNing02/git-hunger/tree/master/MVVM/2_MVC-a\nMVC封装添加MVC函数：https://github.com/ChenNing02/git-hunger/tree/master/MVVM/3_MVC-b\nVue 使用 #  引入Vue #  在bootcdn 搜索 Vue：https://www.bootcdn.cn/\n选择压缩版，例：\n\u0026lt;script src=\u0026#34;https://cdn.bootcss.com/vue/2.6.10/vue.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; Vue 相对MVC的变化 #   在 Vue 中标记要用 {{name}} 而不是 __name__ Vue 需要使用 data ，所以要将 data 放在 Vue 中 template 必须只有一个根元素，如果存在多个，Vue 只会作用第一个 Vue 中 element 变量简写为 el 有了 Vue 就可以不再 render 数据，Vue 会帮你 render 你只需要将对应的数据传入  语法 #  绑定点击事件 \u0026lt;button v-on:click=\u0026#34;id\u0026#34;\u0026gt;点击\u0026lt;/button\u0026gt; 点击 button 会使 selected = 1 \u0026lt;button v-on:click=\u0026#34;selected = 1\u0026#34;\u0026gt; 如果 selected === 0 的结果为 true 就显示 div \u0026lt;div v-show=\u0026#34;selected === 0\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 如果 selected === 0 的结果为 true 就给 div 添加 class=active \u0026lt;div v-bind:class=\u0026#34;{ active:selected === 0}\u0026#34;\u0026gt; 案例 #  图书管理 #  获取数据\n有了 Vue 就可以不再 render 数据，Vue 会帮你 render 你只需要将对应的数据传入，如下：\n注意：Vue 中的 data 会 自动将 data 中的属性升级 Vue 的属性 ，也就是 this.view.data.name = this.view.name\n/* --------------- Vue --------------- */ let view = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ name: \u0026#39;\u0026#39;,number: 0,id: \u0026#39;\u0026#39; }, template: `xxx` }) /* --------- template --------- \u0026lt;div\u0026gt; 名称：{{name}} 数量：\u0026lt;span id=\u0026#34;number\u0026#34;\u0026gt;{{number}}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; --------- template-end --------- */ /* --------------- controller.init --------------- */ this.bindEvents() this.model.fetch(1).then(()=\u0026gt;{ this.view.name = this.model.data.name this.view.number = this.model.data.number this.view.id = this.model.data.id }) 优化：\n/* --------------- Vue --------------- */ let view = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ book:{name: \u0026#39;\u0026#39;,number: 0,id: \u0026#39;\u0026#39;} }, template: `xxx` }) /* --------- template --------- \u0026lt;div\u0026gt; 名称：{{book.name}} 数量：\u0026lt;span id=\u0026#34;number\u0026#34;\u0026gt;{{book.number}}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; --------- template-end --------- */ /* --------------- controller.init --------------- */ this.bindEvents() this.model.fetch(1).then(()=\u0026gt;{ this.view.book = this.model.data }) 初始化事件\n将所有初始化事件放到 Vue 的 methods 属性中\n/* --------- template --------- \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; 名称：{{book.name}} 数量：\u0026lt;span id=\u0026#34;number\u0026#34;\u0026gt;{{book.number}}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button v-on:click=\u0026#34;addOne\u0026#34;\u0026gt;加一\u0026lt;/button\u0026gt; \u0026lt;button v-on:click=\u0026#34;minusOne\u0026#34;\u0026gt;减一\u0026lt;/button\u0026gt; \u0026lt;button v-on:click=\u0026#34;reset\u0026#34;\u0026gt;归零\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; --------- template-end --------- */ /* new Vue 中添加属性: */ methods:{ addOne(){ let text = this.model.data.number let result = text - 0 + 1 this.model.update(\u0026#39;1+\u0026#39;,this.model.data).then(function(){ $(\u0026#39;#number\u0026#39;).text(result) }) }, minusOne(){ let text = this.model.data.number let result = text - 0 - 1 this.model.update(\u0026#39;1-\u0026#39;,this.model.data).then(function(){ $(\u0026#39;#number\u0026#39;).text(result) }) }, reset(){ this.model.update(\u0026#39;1x\u0026#39;,this.model.data).then(function(){ $(\u0026#39;#number\u0026#39;).text(0) }) } } Vue 中初始化数据\n/* new Vue 中添加属性: */ created(){ this.book = model.data } 点击显示/关闭浮层 #  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/axios/0.19.0/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/vue/2.6.10/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .demo{ width:200px; height:100px; background-color: #ccc; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let view = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ open: false }, template:` \u0026lt;div\u0026gt; \u0026lt;button v-on:click=\u0026#34;toggle\u0026#34;\u0026gt;点我\u0026lt;/button\u0026gt; \u0026lt;div class=\u0026#34;demo\u0026#34; v-if=\u0026#34;open\u0026#34;\u0026gt;你好\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; `, methods:{ toggle(){ this.open = !this.open } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JSbin预览：https://jsbin.com/yajucerojo/1/edit?html,output\n简单的轮播 #  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;简单的轮播\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/axios/0.19.0/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/vue/2.6.10/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .main { margin: 50px 200px; } .slides { width: 300px; background: rgba(0, 0, 255, 0.4); height: 100px; transition: all 1s; } .window { width: 100px; height: 100px; border: 2px solid #333; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let view = new Vue({ el: \u0026#39;#app\u0026#39;, data:{ transformValue:\u0026#39;\u0026#39; }, template:` \u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;window\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;slides\u0026#34; v-bind:style=\u0026#34;{ transform: transformValue }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button v-on:click=\u0026#34;go(0)\u0026#34;\u0026gt;1\u0026lt;/button\u0026gt; \u0026lt;button v-on:click=\u0026#34;go(1)\u0026#34;\u0026gt;2\u0026lt;/button\u0026gt; \u0026lt;button v-on:click=\u0026#34;go(2)\u0026#34;\u0026gt;3\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; `, methods: { go(index){ this.transformValue = `translateX(${-100*index}px)` } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JSbin预览：https://jsbin.com/likawuseke/edit?html,output\n排他列表 #  普通方式\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;简单的轮播\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/axios/0.19.0/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/vue/2.6.10/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; ol { list-style: none; margin: 0;} ol li { display: inline-block; margin: 2px; padding: 5px 10px; width: 100px; height: 30px; border: 1px solid blue; cursor: pointer; } .main { margin: 50px 0 0 0; text-align: center; } .content li { width: 322px; } .main li.active { background-color: #ccc; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let view = new Vue({ el: \u0026#39;#app\u0026#39;, data:{ selected:0 }, template:` \u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li v-on:click=\u0026#34;selected = 0\u0026#34; v-bind:class=\u0026#34;{active:selected === 0}\u0026#34;\u0026gt;1\u0026lt;/li\u0026gt; \u0026lt;li v-on:click=\u0026#34;selected = 1\u0026#34; v-bind:class=\u0026#34;{active:selected === 1}\u0026#34;\u0026gt;2\u0026lt;/li\u0026gt; \u0026lt;li v-on:click=\u0026#34;selected = 2\u0026#34; v-bind:class=\u0026#34;{active:selected === 2}\u0026#34;\u0026gt;3\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;ol class=\u0026#39;content\u0026#39;\u0026gt; \u0026lt;li v-show=\u0026#34;selected === 0\u0026#34;\u0026gt;内容1\u0026lt;/li\u0026gt; \u0026lt;li v-show=\u0026#34;selected === 1\u0026#34;\u0026gt;内容2\u0026lt;/li\u0026gt; \u0026lt;li v-show=\u0026#34;selected === 2\u0026#34;\u0026gt;内容3\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; ` }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JSbin 预览：https://jsbin.com/tubeposawi/1/edit?html,output\nfor循环列表添加自定义数据\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;简单的轮播\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/axios/0.19.0/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/vue/2.6.10/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; ol { list-style: none; margin: 0;} ol li { display: inline-block; margin: 2px; padding: 5px 10px; border: 1px solid blue; cursor: pointer; } .main { margin: 50px 200px; } .content li { width: 118px; text-align: center; } .main li.active { background-color: #ccc; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let view = new Vue({ el: \u0026#39;#app\u0026#39;, data:{ selected:\u0026#39;a\u0026#39;, tabs: [ {name: \u0026#39;a\u0026#39;, content: \u0026#39;aaa\u0026#39;}, {name: \u0026#39;b\u0026#39;, content: \u0026#39;bbb\u0026#39;}, {name: \u0026#39;c\u0026#39;, content: \u0026#39;ccc\u0026#39;}, ] }, template:` \u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li v-for=\u0026#34;tab in tabs\u0026#34; v-on:click=\u0026#34;selected = tab.name\u0026#34; v-bind:class=\u0026#34;{active: tab.name === selected}\u0026#34; \u0026gt;{{ tab.name }}\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;ol class=\u0026#39;content\u0026#39;\u0026gt; \u0026lt;li v-for=\u0026#34;tab in tabs\u0026#34; v-show=\u0026#34;selected === tab.name\u0026#34; \u0026gt;{{ tab.content }}\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; ` }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JSbin预览：https://jsbin.com/baqasuqehu/1/edit?html,output\n课后题 #  Vue 自测题\n第 5 题\n正确答案 4 个：\nv-bind:title=\u0026#34;message\u0026#34; v-bind:title=\u0026#39;message\u0026#39; v-bind:title=\u0026#34;this.message\u0026#34; v-bind:title=message 代码\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;demo\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/axios/0.19.0/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/vue/2.6.10/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app-2\u0026#34;\u0026gt; \u0026lt;span v-bind:title=\u0026#34;this.message\u0026#34;\u0026gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var app2 = new Vue({ el: \u0026#39;#app-2\u0026#39;, data: { message: \u0026#39;悬浮提示\u0026#39; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 第6题\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app-2\u0026#34;\u0026gt; \u0026lt;p v-if=\u0026#34;seen\u0026#34;\u0026gt;现在你看到我了\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var app2 = new Vue({ el: \u0026#39;#app-2\u0026#39;, data: { seen:true } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 第7题\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { tabs: [1,2,3,4,5] }, template:` \u0026lt;ol\u0026gt; \u0026lt;li v-for=\u0026#34;tab in tabs\u0026#34;\u0026gt;hi\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; ` }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 第8题\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var app = new Vue({ el: \u0026#39;#app\u0026#39;, data: {x: \u0026#39;frank\u0026#39;}, template:` \u0026lt;div\u0026gt;\u0026lt;input v-model=\u0026#34;x\u0026#34;/\u0026gt;{{x}}\u0026lt;/div\u0026gt; ` }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; "});index.add({'id':56,'href':'/history/2019-09-28-this%E6%98%AF%E4%BB%80%E4%B9%88/','title':"this是什么",'content':"this 只是一个参数，并不是什么特殊的东西\n附方方老师的原文链接\n知乎：https://zhuanlan.zhihu.com/p/23804247\nthis 是什么 #  this 就是 call() 的第一个参数，如果想要知道 this 是什么，就要去查看源代码的文档，如 MDN、jQuery 等\n例如：\nonclick 的 this\n  在MDN搜索 onclick 或者 直接搜索 MDN onclick\n  MDN链接：https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onclick#%E8%AF%AD%E6%B3%95\n  addEventListener 的 this\n  在 MDN 搜索 addEventListener 或者 直接搜索 MDN addEventListener\n  MDN链接：https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#The_value_of_this_within_the_handler\n  jQuery 中 .on('click') 的 this\n  搜索 jQuery 文档中的 .on()\n  jQuery 链接：https://www.jquery123.com/on/\n  练习题 #     function X(){ return object = { name: \u0026#39;object\u0026#39;, f1(x){ x.f2() }, f2(){ console.log(this) } } } let options = { name: \u0026#39;options\u0026#39;, f1(){}, f2(){ console.log(this) } } let x = X() x.f1(options) 打出的是 name: 'options' 的 this\n  function X(){ return object = { name: \u0026#39;object\u0026#39;, options: null, f1(x){ this.options = x this.f2() }, f2(){ this.options.f2.call(this) } } } let options = { name: \u0026#39;options\u0026#39;, f1(){}, f2(){ console.log(this) } } let x = X() x.f1(options) 打出的是 name: \u0026quot;object\u0026quot; 的 this\n"});index.add({'id':57,'href':'/history/2019-09-27-new%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/','title':"New做了什么",'content':"New 一个函数或对象时会添加哪些默认属性\nnew 做了什么 #  案例代码\nfunction 士兵(id){ /* let temp = {} */ /* this = temp */ /* this.__proto__ = 士兵.prototype */ this.ID = id, this.生命值 = 42 /* 自有属性 */ /* return this */ } 士兵.prototype = { /* 共有属性 */ 兵种:\u0026#34;美国大兵\u0026#34;, 攻击力: a, 行走:function(){/* 行走的代码 */} 奔跑:function(){/* 奔跑的代码 */} 死亡:function(){/* 死亡的代码 */} } 总结 new 一个函数时做了什么\n 创建一个临时对象 让 this 指向这个临时对象 让 this.__proto__ = create士兵.prototype 返回 return this   这些行为，俗称语法糖 ( 语法糖，就是很贴心的意思 )\n 优化上面案例的代码\n由于在new的时候会在 士兵.prototype 中自动添加一个对象，并在对象中加入一个含有函数名的默认属性，如下，所以最好不要直接士兵.prototype = {} 的方法添加默认的共有属性，这样会覆盖，而是在当前对象的基础上 . 去添加属性\nfunction 士兵(id){ /* let temp = {} --1 */ /* this = temp --2 */ /* this.__proto__ = 士兵.prototype --3 */ /* 士兵.prototype = { constructor: 士兵 } --5 */ this.ID = id, this.生命值 = 42 /* 自有属性 */ /* return this --4 */ } 士兵.prototype.兵种 = \u0026#34;美国大兵\u0026#34; 士兵.prototype.兵种 = a 士兵.prototype.兵种 = function(){/* 行走的代码 */} 士兵.prototype.兵种 = function(){/* 奔跑的代码 */} 士兵.prototype.兵种 = function(){/* 死亡的代码 */} 关于原型链 #  Object\nvar object = new Object() 当执行上面的话时做了哪些事: 1. 添加一个自有属性 2. 指向 Object 的共有属性 Object.__proto__ === Object.prototype Array\nvar array = new Array(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;) 当执行上面的话时做了哪些事: 1. 添加一个自有属性 2. 指向 Array 的共有属性 Array.__proto__ === Array.prototype Array.prototype.__proto__ === Object.prototype Function\nvar fn = new Function(\u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;return x+y\u0026#39;) 当执行上面的话时做了哪些事: 1. 添加一个自有属性 2. 指向 Array 的共有属性 Function.__proto__ === Function.prototype Array.prototype.__proto__ === Object.prototype Array.__proto__ 指向哪\n即时是 new Array() 也是由函数创建: Array = funciotn(){xxx} 所以它的 __proto__ 依然指向 Function Array.__proto__ === Function.prototype 推理 #  Array.__proto__ === Function.prototype 结果为: true Array.__proto__.__proto__ === Object.prototype Function.__proto__ === Function.prototype 结果为: true Object.__proto__ === Function.prototype 结果为: true 结论 #  当我们 new Array()  new Object() 等的时候，其实只是在函数的基础上添加了一些私有属性，然后再指向一个共有属性。\nArray 对象\n当 new Array()  会创建一个Array的函数，并且添加一些私有的属性，然后将 __proto__ 指向 Function.prototype ，Function.prototype 再指向 Object.prototype ，代码：\nArray.__proto__ === Function.prototype true Function.prototype.__proto__ === Object.prototype true Function对象\n当 new Function() 也会添加一些自己的私有属性，然后它的 __proto__ 指向，Function.prototype ，Function.prototype 再指向 Object.prototype\nFunction.__proto__ === Function.prototype true Function.prototype.__proto__ === Object.prototype true  部分内容摘自\n掘金链接 (https://juejin.im/post/584e1ac50ce463005c618ca2)\n知乎链接 (https://zhuanlan.zhihu.com/p/23987456)\n "});index.add({'id':58,'href':'/history/2019-09-21-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9D%97%E5%8C%96/','title':"代码模块化",'content':"代码模块化以及闭包的使用\n模块化 #  每个功能都单独存放在一个文件中并给文件起一个合适的名字，\n然后每个文件的所有代码都用一个自调用的匿名函数包起来 function(){}.call() 但是这个方法浏览器会报错\n经过前人不断尝试，可以给函数前加一个 ! 表示取反，虽然会改变这个函数的 return 结果，但我们不需要结果，只需要执行这个函数就可以，所以这是最佳的方案\n!function(){ let xxx = \u0026#39;xxxx\u0026#39; let aaa = \u0026#39;xwww\u0026#39; }.call() 闭包 #  在不同文件下调用 #  html\n\u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;m1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;m2.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; m1.js\n!function(){ let person = { name: \u0026#39;chen\u0026#39;, age: 20 } window.fn = function(){ person.age +=1 return person.age } }.call() m2.js\n!function(){ let a = window.fn() console.log(a) }.call() 在同一个文件下调用 #  var accessor = function(){ var person = { name: \u0026#39;chen\u0026#39;, age: 20 } return function(){ person.age += 1 return person.age } } var growUp = accessor.call() var result = growUp.call() console.log(result) 闭包总结 #  立即执行函数使得 person 无法被外部访问\n闭包使得匿名函数可以操作 person\n声明一个 window.xxx 保存匿名函数的地址\n任何地方都可以使用 window.xxx 操作 person 但不能访问 person\n"});index.add({'id':59,'href':'/history/2019-09-20-mvc%E6%80%9D%E6%83%B3/','title':"MVC思想",'content':"MVC 封装一个简单的个人简历\n预览链接：https://chenning02.github.io/git-hunger/course-demo/bio/bio-d-MVC/index.html\nMVC 封装之 VC #  第一步\n创建两个变量，分别来存储 View 和 Controller\n!function(){ // 导航栏根据滚轮改变  let view = document.getElementById(\u0026#39;topNavBar\u0026#39;) let controller = { view: null, init: function(view){ window.addEventListener(\u0026#39;scroll\u0026#39;, function(x){ if(window.scrollY \u0026gt; 0){ view.classList.add(\u0026#39;sticky\u0026#39;) }else { view.classList.remove(\u0026#39;sticky\u0026#39;) } }) } } controller.init(view) }.call() 第二步\n添加一个 bindEvents 方法 用来绑定执行所用事件\n!function(){ // 导航栏根据滚轮改变  let view = document.getElementById(\u0026#39;topNavBar\u0026#39;) let controller = { view: null, init: function(view){ // 这里是将 传入的外部 view 的值赋给 controller 对象的 view  this.view = view this.bindEvents() // this.bindEvents.call(this)  }, bindEvents: function(){ let view = this.view window.addEventListener(\u0026#39;scroll\u0026#39;, function(x){ if(window.scrollY \u0026gt; 0){ view.classList.add(\u0026#39;sticky\u0026#39;) }else { view.classList.remove(\u0026#39;sticky\u0026#39;) } }) } } controller.init(view) // controller.init.call(controller, view) }.call()  如果你是用一个对象来调用函数的，那么就相当于这个对象就是函数里面的this\n 然后将每个操作都作为一个 controller 的方法，使用时 this. 调用即可\n!function(){ // 导航栏根据滚轮改变  let view = document.getElementById(\u0026#39;topNavBar\u0026#39;) let controller = { view: null, init: function(view){ this.view = view this.bindEvents() }, bindEvents: function(){ let view = this.view window.addEventListener(\u0026#39;scroll\u0026#39;, ()=\u0026gt;{ if(window.scrollY \u0026gt; 0){ this.active() }else { this.deactive() } }) }, active: function(){ this.view.classList.add(\u0026#39;sticky\u0026#39;) }, deactive: function(){ this.view.classList.remove(\u0026#39;sticky\u0026#39;) } } controller.init(view) }.call() 注意上面的代码中将 window.addEventener 的第二个参数的函数变为了箭头函数\n原因如下\nwindow.addEventListener(\u0026#39;scroll\u0026#39;, function(x){ if(window.scrollY \u0026gt; 0){ view.classList.add(\u0026#39;sticky\u0026#39;) }else { view.classList.remove(\u0026#39;sticky\u0026#39;) } }) 因为这里的 window.addEventListener 参数中匿名函数的this是被操作的元素，可能并不是我们想要的，所以需要将匿名函数改为箭头函数，箭头函数并没有this，所以它会向上一级作用域找我们需要的 this\n由于箭头函数是不存在 this 的 (无法操作修改箭头函数的 this 因为箭头函数是没有 this 这一属性的)，所以这里箭头函数的 this 就像变量一样。\nwindow.addEventListener(\u0026#39;scroll\u0026#39;, ()=\u0026gt;{ if(window.scrollY \u0026gt; 0){ view.classList.add(\u0026#39;sticky\u0026#39;) }else { view.classList.remove(\u0026#39;sticky\u0026#39;) } }) 如果需要使用匿名函数调用上一级的 this 可以使用 .bind(this) 绑定一下 this\n如：\nanimate: function(time){ requestAnimationFrame(this.animate.bind(this)); TWEEN.update(time); } 轮播封装\n第一步\n将整个事件放到 bindEvents 里 调用时直接调用 bindEvents 方法即可\n!function(){ let view = document.querySelector(\u0026#39;#mySlides\u0026#39;) let controller = { view: null, init: function(view){ this.view = view this.bindEvents() }, bindEvents: function(){ let view = this.view let mySwiper = new Swiper (view.querySelector(\u0026#39;.swiper-container\u0026#39;), { direction: \u0026#39;horizontal\u0026#39;, loop: true, pagination: { el: \u0026#39;.swiper-pagination\u0026#39;, }, navigation: { nextEl: \u0026#39;.swiper-button-next\u0026#39;, prevEl: \u0026#39;.swiper-button-prev\u0026#39;, } }) } } controller.init(view) }.call() 第二部\n首先初始化需要的属性，\n然后添加 init 属性初始化需要执行的事件\n然后将事件所用的变量单独存放到一个属性中，\n然后创建一个新的方法用来操作 view 执行所需要的操作，在 init 中调用这个方法，\n最后调用 controller.init() 方法\n!function(){ let view = document.querySelector(\u0026#39;#mySlides\u0026#39;) let controller = { view: null, swiper: null, init: function(view){ this.view = view this.initSwiper() }, swiperOptions: { direction: \u0026#39;horizontal\u0026#39;, loop: true, pagination: { el: \u0026#39;.swiper-pagination\u0026#39;, }, navigation: { nextEl: \u0026#39;.swiper-button-next\u0026#39;, prevEl: \u0026#39;.swiper-button-prev\u0026#39;, } }, initSwiper: function(){ this.swiper = new Swiper ( this.view.querySelector(\u0026#39;.swiper-container\u0026#39;), this.swiperOptions )} } controller.init(view) }.call() this.bindEvents() 绑定事件函数\n添加留言 #  使用 LeanCloud 数据库\n在 帮助 中选择 快速文档\n引入数据库 #  前三步基本查看文档即可\n  安装与引用 SDK\n  初始化\n  在页面中打 log 查看运行的代码是否成功\n  验证 (验证本地网络是否可以使用) #  开始验证，要注意文档中 ping 的地址\nping 一下本地域名\n本地域名格式：\n查看文档：https://leancloud.cn/docs/rest_api.html#hash-1550543791\nVUWVoraj.api.lncld.net API使用过程 #  监听 form 表单事件，如果它 submit 了，就阻止默认的事件刷新页面，如果不阻止 submit 就会刷新页面\npostMessage.addEventListener(\u0026#39;submit\u0026#39;, function(e){ e.preventDefault() }) 为什么监听 form 表单而不监听 submit 按钮，因为用户可能会直接回车提交，而不是直接点击提交按钮。\n在 form 表单的 submit 事件中，包含 form 表单内的 任意 input 回车和 submit 点击提交。\n但监听 submit 按钮，如果用户回车提交的话可能需要监听所有的 input 的回车事件 以及 submit 的点击提交事件，所以最便捷的方案还是监听 form 表单\n获取提交的文本内容并存入数据库的 content 属性中 (其中大部分API来自 LeanCloud 数据库)\nlet myFor = document.querySelector(\u0026#39;#postMessageForm\u0026#39;) console.log(myFor) myFor.addEventListener(\u0026#39;submit\u0026#39;, function(e){ e.preventDefault() let content = myFor.querySelector(\u0026#39;input[name=content]\u0026#39;).value let Message = AV.Object.extend(\u0026#39;Message\u0026#39;) let message = new Message() message.save({ \u0026#39;content\u0026#39;: content }).then(function (Object) { console.log(\u0026#39;保存成功。\u0026#39;) console.log(Object) }) }) 在 LeanCloud 官网 依次选择以下选项\n API文档  JavaScript 数据存储 SDK API  使用文档  对象  批量操作          通过查看文档如何批量操作的 API 就可以获取所有历史数据\n// 获取数据 let query = new AV.Query(\u0026#39;Message\u0026#39;) query.find().then(function(messages){ console.log(messages) console.log(messages[0].attributes) console.log(messages[1].attributes) let array = messages.map((item)=\u0026gt; item.attributes) console.log(array) }, function(error){ console.log(\u0026#39;错误\u0026#39;) }) 获取后创建一个 ol 列表，将每个数据 forEach 遍历，存入 ol 列表的 li 中\nlet query = new AV.Query(\u0026#39;Message\u0026#39;) query.find().then(function(messages){ let array = messages.map((item)=\u0026gt; item.attributes) array.forEach((item)=\u0026gt;{ let li = document.createElement(\u0026#39;li\u0026#39;) li.innerText = item.content let messageList = document.querySelector(\u0026#39;#messageList\u0026#39;) messageList.appendChild(li) }) }, function(error){ console.log(error) }) 每次提交数据都将 form 表单中的数据存到数据库的 content 属性下，成功后自动刷新页面\nlet myFor = document.querySelector(\u0026#39;#postMessageForm\u0026#39;) myFor.addEventListener(\u0026#39;submit\u0026#39;, function(e){ e.preventDefault() let content = myFor.querySelector(\u0026#39;input[name=content]\u0026#39;).value let Message = AV.Object.extend(\u0026#39;Message\u0026#39;) let message = new Message() message.save({ \u0026#39;content\u0026#39;: content }).then(function (Object) { window.location.reload() }) }) 添加评论名称，并设置无刷新留言\n首先在获取数据时添加获取 name 属性 然后将 名称和内容用 : 拼接起来 使用 ${} 的方法\n// 获取数据 let query = new AV.Query(\u0026#39;Message\u0026#39;) query.find().then(function(messages){ let array = messages.map((item)=\u0026gt; item.attributes) array.forEach((item)=\u0026gt;{ let li = document.createElement(\u0026#39;li\u0026#39;) li.innerText = `${item.name}:${item.content}` let messageList = document.querySelector(\u0026#39;#messageList\u0026#39;) messageList.appendChild(li) }) }, function(error){ console.log(error) }) 然后在添加数据时添加一个 name 属性，name 属性值从 input 属性值为 name='name'  标签中获取。\n如果在数据库中添加成功，那么不刷新网页，而是直接在页面中添加一个 li 标签 直接添加刚刚的评论\n// 修改数据 let myFor = document.querySelector(\u0026#39;#postMessageForm\u0026#39;) myFor.addEventListener(\u0026#39;submit\u0026#39;, function(e){ e.preventDefault() let content = myFor.querySelector(\u0026#39;input[name=content]\u0026#39;).value let name = myFor.querySelector(\u0026#39;input[name=name]\u0026#39;).value let Message = AV.Object.extend(\u0026#39;Message\u0026#39;) let message = new Message() message.save({ \u0026#39;name\u0026#39;:name, \u0026#39;content\u0026#39;: content }).then(function (Object) { let li = document.createElement(\u0026#39;li\u0026#39;) li.innerText = `${Object.attributes.name}:${Object.attributes.content}` let messageList = document.querySelector(\u0026#39;#messageList\u0026#39;) messageList.appendChild(li) }) }) 在 .then 后添加清除form表单输入内容\nmyFor.querySelector(\u0026#39;input[name=name]\u0026#39;).value = \u0026#39;\u0026#39; 封装留言 #  首先按照MVC思想封装，封装后将M、V、C 单独作为函数封装：\nM\n封装\nwindow.Model = function(options){ let resourceName = options.resourceName return { init:function(){ var APP_ID = \u0026#39;VUWVorajTr3ePKWkr9vRtpQe-gzGzoHsz\u0026#39;; var APP_KEY = \u0026#39;TOmsGDTwsNCSC6utMnTR8Bfg\u0026#39;; AV.init({ appId: APP_ID, appKey: APP_KEY }); }, /* 获取数据 */ fetch: function(){ let query = new AV.Query(resourceName) return query.find() /* Promise 对象 */ }, /* 新建数据 */ save: function(object){ let AMessage = AV.Object.extend(resourceName) let amessage = new AMessage() return amessage.save(object) } } } 调用\nlet model = Model({resourceName:\u0026#39;Message\u0026#39;}) this.model.save({ name:name, content:content }) V\n封装\nwindow.View = function(selector){ return document.querySelector(selector) } 调用\nlet view = document.querySelector(\u0026#39;section.message\u0026#39;) C\n其中 init.call(this, view, model)  的 this 就是 retrun 回去的 object ，也就是 controller\n Controller() 的 return 是 controller ，所以 controller === object 也就是 controller.init.call(controller, view, model) 所以 controller.init 里面的 this 是 controller ，也就是 最上面的 object  归根结底就是，由于需要调用封装的函数 Controller() 中的 this 的属性，所以需要将它的 this 传出一次\nMVC 代码组织形式 #  v\n视图\nm\n数据，操作数据\nc\n控制器，用来控制其他的所有代码\n"});index.add({'id':60,'href':'/history/2019-09-18-%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-ajax/','title':"自己实现 AJAX",'content':"设置请求 #  案例\nrequest.open(\u0026#39;POST\u0026#39;, \u0026#39;/xxx\u0026#39;) // 第一部分 配置 request request.setRequestHeader(\u0026#39;chen\u0026#39;,\u0026#39;16\u0026#39;) // 第二部分 属性配置 request.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;x-www-form-urlencoded\u0026#39;) // 第二部分 属性配置 request.send(\u0026#39;a=1\u0026amp;b=2\u0026#39;) // 第四部分 请求第二部分\nXMLHttpRequest.setRequestHeader() 是设置HTTP请求头部的方法。此方法必须在 open() 方法和 send() 之间调用。如果多次对同一个请求头赋值，只会生成一个合并了多个值的请求头。\nrequest.setRequestHeader(header, value); 效果图\n设置响应 #  if(path === \u0026#39;/\u0026#39;){ let string = fs.readFileSync(\u0026#39;./index.html\u0026#39;,\u0026#39;utf8\u0026#39;) // 响应第四部分内容格式  response.statusCode = 200 // 设置响应第一部分响应码  response.setHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;text/html;charset=utf-8\u0026#39;) // 设置响应第二部分属性  response.write(string) // 设置响应第四部分  response.end() // 响应结束 } 获取响应 #  获取响应的状态\nresponse.statusText; 获取响应的第二部分\nrequest.getAllResponseHeaders() 获取响应的第二部分指定信息\nrequest.getResponseHeader(\u0026#39;Content-Type\u0026#39;) 获取响应的第四部分\nrequest.responseText 案例\nif(request.status \u0026gt;= 200 \u0026amp;\u0026amp; request.status \u0026lt; 300){ let string = request.responseText // 使用浏览器提供的API将应该符合JSON语法的字符串转换为JS对应类型的值  let object = window.JSON.parse(string) console.log(object) console.log(\u0026#39;---获取响应---\u0026#39;) console.log(\u0026#39;响应状态：\u0026#39;) console.log(request.statusText) console.log(\u0026#39;响应的第二部分\u0026#39;) console.log(request.getAllResponseHeaders()) console.log(\u0026#39;获取响应的第二部分指定信息\u0026#39;) console.log(request.getResponseHeader(\u0026#39;Content-Type\u0026#39;)) console.log(\u0026#39;获取响应的第四部分\u0026#39;) console.log(request.responseText) } 源代码链接\nhttps://github.com/ChenNing02/git-hunger/tree/master/course-demo/Made-AJAX/Obtain\nAJAX 的功能 #   客户端的JS发起请求（浏览器上的） 服务端的JS发送响应（Node.js上的）   JS 可以设置任意请求 header 吗 第一部分 request.open('get', '/xxx') 第二部分 request.setRequestHeader('content-type','x-www-form-urlencoded') 第四部分 request.send('a=1\u0026amp;b=2') JS 可以获取任意响应 header 吗？ 第一部分 request.status / request.statusText 第二部分 request.getResponseHeader() / request.getAllResponseHeaders() 第四部分 request.responseText  jQuery-Promise #  源代码链接\nhttps://github.com/ChenNing02/git-hunger/tree/master/course-demo/Made-AJAX/jQuery-Promise\n首先需要在主页引入 jQuery 库，可以使用 cdnjs 也可以使用本地的文件\n成功返回 .then 的第一个参数，失败返回 .then 的第二个参数\nfunction success(responseText){ console.log(responseText)} function fail(request){ console.log(request)} buttons.addEventListener(\u0026#39;click\u0026#39;, (e)=\u0026gt;{ window.jQuery.ajax({ url: \u0026#39;/xxx\u0026#39;, method: \u0026#39;POST\u0026#39;, method: \u0026#39;get\u0026#39;, }).then(success, fail) }) 简化：\nbuttons.addEventListener(\u0026#39;click\u0026#39;, (e)=\u0026gt;{ window.jQuery.ajax({ url: \u0026#39;/xxx\u0026#39;, method: \u0026#39;POST\u0026#39;, method: \u0026#39;get\u0026#39;, }).then( (responseText)=\u0026gt;{ console.log(responseText)}, (request)=\u0026gt;{{ console.log(request)}} ) }) 使用xxx可以返回两个处理函数\nbuttons.addEventListener(\u0026#39;click\u0026#39;, (e)=\u0026gt;{ window.jQuery.ajax({ url: \u0026#39;/xxx\u0026#39;, method: \u0026#39;POST\u0026#39;, method: \u0026#39;get\u0026#39;, }).then( (responseText)=\u0026gt;{ console.log(responseText) return responseText }, (request)=\u0026gt;{ console.log(request) return request } ).then( (responseText)=\u0026gt;{ console.log(responseText) }, (request)=\u0026gt;{ console.log(request) } ) }) 其中第一个 .then 中的函数的 return 返回值会作为后面的 .then 的对应的函数中的参数。\n自制的Promise #  源代码链接\nhttps://github.com/ChenNing02/git-hunger/tree/master/course-demo/Made-AJAX/Promise-z\n封装方式 #    就是在原来的基础上 return new Promise(function(resolve,reject){})\n  将要做的事都放到Promise传入的函数中\n  函数的两个参数分别表示 成功调用的函数 和 失败调用的函数\n  then 的作用 #  封装的函数在调用时可以 .then 传入两个函数，这两个函数对应封装时的两个参数 resolve, reject ，分别表示 成功后执行的函数 和 失败后执行的函数。\n.then() 是 Promise 对象特有的\n案例 #  封装\nwindow.jQuery.ajax = function ({url, method, body, headers}){ return new Promise(function(resolve,reject){ let request = new XMLHttpRequest() request.open(method, url) // 配置 request  for(let key in headers){ let value = headers[key] request.setRequestHeader(key,value) } request.setRequestHeader(\u0026#39;chen\u0026#39;,\u0026#39;16\u0026#39;) request.onreadystatechange = ()=\u0026gt;{ if(request.readyState === 4){ if(request.status \u0026gt;= 200 \u0026amp;\u0026amp; request.status \u0026lt; 300){ // 这里传入获取到的响应第四部分内容，当函数使用这个参数时，这就是回调函数  resolve.call(undefined,request.responseText) }else if(request.status \u0026gt;= 400){ reject.call(undefined, request) } } } request.send(body) }) } 调用\nbuttons.addEventListener(\u0026#39;click\u0026#39;, (e)=\u0026gt;{ window.jQuery.ajax({ url: \u0026#39;/xxx\u0026#39;, method: \u0026#39;POST\u0026#39;, body: \u0026#39;a=1\u0026amp;b=2\u0026#39;, headers: { \u0026#39;content-type\u0026#39;:\u0026#39;application/x-www-form-urlencoded\u0026#39;, \u0026#39;chen\u0026#39;:\u0026#39;16\u0026#39; } }).then( (text)=\u0026gt;{console.log(text)}, (request)=\u0026gt;{console.log(request)} ) }) 更易懂的调用方式\nbuttons.addEventListener(\u0026#39;click\u0026#39;, (e)=\u0026gt;{ let promise = window.jQuery.ajax({ url: \u0026#39;/xxx\u0026#39;, method: \u0026#39;POST\u0026#39;, body: \u0026#39;a=1\u0026amp;b=2\u0026#39;, headers: { \u0026#39;content-type\u0026#39;:\u0026#39;application/x-www-form-urlencoded\u0026#39;, \u0026#39;chen\u0026#39;:\u0026#39;16\u0026#39; } }) promise.then( (text)=\u0026gt;{console.log(text)}, (request)=\u0026gt;{console.log(request)} ) }) API 参考文档 #  XMLHttpRequest #   XMLHttpRequest XMLHttpRequest.setRequestHeader() XMLHttpRequest.onreadystatechange XMLHttpRequest.readyState XMLHttpRequest.status XMLHttpRequest.statusText  "});index.add({'id':61,'href':'/history/2019-09-17-ajax/','title':"AJAX",'content':"案例源代码地址：https://github.com/ChenNing02/git-hunger/tree/master/AJAX\n各种请求方式 #  form 表单\n\u0026lt;form action=\u0026#34;/xxx\u0026#34; method=\u0026#34;GET\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; link\nvar link = document.createElement(\u0026#39;link\u0026#39;) link.rel = \u0026#39;stylesheet\u0026#39; link.href = \u0026#39;/xxx\u0026#39; document.head.appendChild(link) a 标签\n\u0026lt;a id=x href=\u0026#34;/xxx\u0026#34;\u0026gt;click\u0026lt;/a\u0026gt; \u0026lt;script\u0026gt; x.click() \u0026lt;/script\u0026gt; script\nvar script = document.createElement(\u0026#39;script\u0026#39;) script.src = \u0026#39;/yyy\u0026#39; document.head.appendChild(script) img\nvar image = document.createElement(\u0026#39;img\u0026#39;) image.src = \u0026#39;/xxx\u0026#39; image.onload = function(){ console.log(\u0026#39;success\u0026#39;) } image.onerror = function(){ console.log(\u0026#39;fail\u0026#39;) } 自制的AJAX请求 #  首先设置 server.js 的判断条件\nif (path === \u0026#39;/xxx\u0026#39;) { response.statusCode = 400 response.setHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;text/xml\u0026#39;) response.write(` \u0026lt;note\u0026gt; \u0026lt;to\u0026gt;Tove\u0026lt;/to\u0026gt; \u0026lt;from\u0026gt;Jani\u0026lt;/from\u0026gt; \u0026lt;heading\u0026gt;Reminder\u0026lt;/heading\u0026gt; \u0026lt;body\u0026gt;Don\u0026#39;t forget me this weekend!\u0026lt;/body\u0026gt; \u0026lt;/note\u0026gt; `) response.end() } 设置按钮点击时 new 一个 XMLHttprequest\nbuttons.addEventListener(\u0026#39;click\u0026#39;, (e)=\u0026gt;{ let request = new XMLHttpRequest() request.open(\u0026#39;GET\u0026#39;, \u0026#39;/xxx\u0026#39;) // 配置 request  request.send() console.log(request.readyState) }) request.readyState 表示请求的状态\n此时点击 button 查看 GET 请求所用的时间 ，也就是控制台 Network 中的 Time 一栏\n再次更改代码，每隔一毫秒问一次请求的状态：\nbuttons.addEventListener(\u0026#39;click\u0026#39;, (e)=\u0026gt;{ let request = new XMLHttpRequest() request.open(\u0026#39;GET\u0026#39;, \u0026#39;/xxx\u0026#39;) // 配置 request  request.send() setInterval(()=\u0026gt;{ console.log(request.readyState) },1) // 每隔一毫秒执行一次箭头函数 }) 在上述代码中1与4之间可能不存在 2 3 ，因为 2 3 太快，快过了1毫秒\n如果请求，响应全部执行完成 (也就是响应下载完毕)，它的状态码就是4\n捕获状态 0\nbuttons.addEventListener(\u0026#39;click\u0026#39;, (e)=\u0026gt;{ let request = new XMLHttpRequest() console.log(request.readyState) request.open(\u0026#39;GET\u0026#39;, \u0026#39;/xxx\u0026#39;) // 配置 request  request.send() }) 此时状态为 0，每个状态的含义请查看MDN文档 (也可以看本文最后的 XMLHttpRequest.readyState )\n捕获每个状态的变化\n使用onreadystatechange\nbuttons.addEventListener(\u0026#39;click\u0026#39;, (e)=\u0026gt;{ let request = new XMLHttpRequest() request.onreadystatechange = ()=\u0026gt;{ console.log(request.readyState) } request.open(\u0026#39;GET\u0026#39;, \u0026#39;/xxx\u0026#39;) // 配置 request  request.send() }) 尽量把事件放在open前，这样可以捕获每个状态\n判断响应状态\n通过readyState判断状态码状态\n然后再通过 status 判断响应类型 如 200 400 等\nbuttons.addEventListener(\u0026#39;click\u0026#39;, (e)=\u0026gt;{ let request = new XMLHttpRequest() request.onreadystatechange = ()=\u0026gt;{ if(request.readyState === 4){ console.log(\u0026#39;请求响应已完成\u0026#39;) if(request.status \u0026gt;= 200 \u0026amp;\u0026amp; request.status \u0026lt; 300){ console.log(\u0026#39;请求成功\u0026#39;) }else if(request.status \u0026gt;= 400){ console.log(\u0026#39;请求失败\u0026#39;) } } } request.open(\u0026#39;GET\u0026#39;, \u0026#39;/xxx\u0026#39;) // 配置 request  request.send() })  如果出现返回 300 类的响应，服务器会再次发出请求，所以正常情况下不会出300类的状态\n 读取响应第四部分\n使用 responseText 即可获取响应的第4部分文本内容\nbuttons.addEventListener(\u0026#39;click\u0026#39;, (e)=\u0026gt;{ let request = new XMLHttpRequest() request.onreadystatechange = ()=\u0026gt;{ if(request.readyState === 4){ console.log(\u0026#39;请求响应已完成\u0026#39;) if(request.status \u0026gt;= 200 \u0026amp;\u0026amp; request.status \u0026lt; 300){ console.log(\u0026#39;请求成功\u0026#39;) console.log(request.responseText) }else if(request.status \u0026gt;= 400){ console.log(\u0026#39;请求失败\u0026#39;) } } } request.open(\u0026#39;GET\u0026#39;, \u0026#39;/xxx\u0026#39;) // 配置 request  request.send() }) JS 和 JSON 的区别 #  JS 和 JSON 是两门语言，JSON 抄袭了 JS 的部分语法\n语法区别：\n   JS JSON     undefined 没有   null null   [\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;] [\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;]   {name: \u0026lsquo;frank\u0026rsquo;} {\u0026ldquo;name\u0026rdquo;: \u0026ldquo;frank\u0026rdquo;}   \u0026lsquo;frank\u0026rsquo; \u0026ldquo;frank\u0026rdquo;   function fn(){} 没有   var a = {} JSON没有变量   {__proto__} JSON没有原型链    JSON 中 没有 function 和 undefined\nJSON 的字符串首尾必须用 \u0026quot; 包裹\n使用 JSON 格式的数据 #  在 server 中添加JSON格式内容\nif(path === \u0026#39;/xxx\u0026#39;){ response.statusCode = 200 response.setHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;text/json;charset=utf-8\u0026#39;) response.write(` { \u0026#34;note\u0026#34;:{ \u0026#34;to\u0026#34;:\u0026#34;Chen\u0026#34;, \u0026#34;from\u0026#34;:\u0026#34;lh\u0026#34;, \u0026#34;heading\u0026#34;:\u0026#34;fa\u0026#34;, \u0026#34;content\u0026#34;:\u0026#34;hi\u0026#34; } } `) response.end() } 注意，添加后控制台返回的是 string 类型\n获取 JSON 格式数据\nbuttons.addEventListener(\u0026#39;click\u0026#39;, (e)=\u0026gt;{ let request = new XMLHttpRequest() request.onreadystatechange = ()=\u0026gt;{ if(request.readyState === 4){ console.log(\u0026#39;请求响应已完成\u0026#39;) if(request.status \u0026gt;= 200 \u0026amp;\u0026amp; request.status \u0026lt; 300){ console.log(\u0026#39;请求成功\u0026#39;) console.log(request.responseText) let string = request.responseText // 使用浏览器提供的API将应该符合JSON语法的字符串转换为JS对应类型的值  let object = window.JSON.parse(string) console.log(typeof object) console.log(object) // 获取对象中note属性的内容  console.log(\u0026#39;object.note\u0026#39;) console.log(object.note) }else if(request.status \u0026gt;= 400){ console.log(\u0026#39;请求失败\u0026#39;) } } } request.open(\u0026#39;GET\u0026#39;, \u0026#39;/xxx\u0026#39;) // 配置 request  request.send() }) 源代码链接\nhttps://github.com/ChenNing02/git-hunger/tree/master/course-demo/AJAX/b\n同源策略 #  使用form 表单向百度发GET请求\n\u0026lt;form action=\u0026#34;https://www.baidu.com\u0026#34; method=\u0026#34;GET\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 使用ajax 向百度发送请求\nrequest.open(\u0026#39;GET\u0026#39;, \u0026#39;https://www.baidu.com\u0026#39;) // 配置 request 虽然会请求成功，但无法返回内容，因为百度没有相应的响应\n这时查看 status 状态码为 0\nconsole.log(request.status) 如果你的域名不相同就无法发送 ajax 请求，但是其他请求却可以，比如上面的 form img 等\n只有 协议+端口+域名 一模一样才允许发送 AJAX 请求\nCORS跨域 #  Cross-Origin Read Blocking (CORB)\n使用CORS可以告诉浏览器，是否允许指定域名访问\n案例\n打开 c 目录下的文件\n在 chen 和 ning 目录下分别开两个 server\nnode server 8001 // chen node server 8002 // ning 在 chen 目录下的 main.js 中配置请求路径\nrequest.open(\u0026#39;GET\u0026#39;, \u0026#39;http://ning.com:8002/xxx\u0026#39;) // 配置 request 然后在 ning 目录下的 server.js 文件中添加一句话，表示允许 chen.com:8001 访问，即可请求成功\nresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;http://chen.com:8001\u0026#39;) 案例源代码\nhttps://github.com/ChenNing02/git-hunger/tree/master/course-demo/AJAX/c\n使用原生JS发送AJAX请求 #  let request = new XMLHttpRequest() request.open(\u0026#39;get\u0026#39;, \u0026#39;http://xxx.com\u0026#39;) request.send() request.onreadystatechange = ()=\u0026gt;{ if(request.readyState === 4){ if(request.status \u0026gt;= 200 \u0026amp;\u0026amp; request.status \u0026lt; 300){ let string = request.responseText let object = window.JSON.parse(string) } } } MDN 文档内容 #  下面是MDN 文档中的内容\nXMLHttpRequest.readyState #  原文链接：https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState\nXMLHttpRequest.readyState 属性返回一个 XMLHttpRequest 代理当前所处的状态。一个 XHR 代理总是处于下列状态中的一个：\n   值 状态 描述     0 UNSENT 代理被创建，但尚未调用 open() 方法。   1 OPENED open() 方法已经被调用。   2 HEADERS_RECEIVED send() 方法已经被调用，并且头部和状态已经可获得。   3 LOADING 下载中； responseText 属性已经包含部分数据。   4 DONE 下载操作已完成。      UNSENT\nXMLHttpRequest 代理已被创建， 但尚未调用 open() 方法。\n  OPENED\nopen() 方法已经被触发。在这个状态中，可以通过 setRequestHeader() 方法来设置请求的头部， 可以调用 send() 方法来发起请求。\n  HEADERS_RECEIVED\nsend() 方法已经被调用，响应头也已经被接收。\n  LOADING\n响应体部分正在被接收。如果 responseType 属性是“text”或空字符串， responseText 将会在载入的过程中拥有部分响应数据。\n  DONE\n请求操作已经完成。这意味着数据传输已经彻底完成或失败。\n  XMLHttpRequest.open() #  原文链接：https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/open\nXMLHttpRequest.open() 方法初始化一个请求。该方法要从JavaScript代码使用；从原生代码初始化一个请求，使用openRequest()替代。\n**注意：**为已激活的请求调用此方法（open()或openRequest()已被调用）相当于调用abort()。\n语法 #  xhrReq.open(method, url); xhrReq.open(method, url, async); xhrReq.open(method, url, async, user); xhrReq.open(method, url, async, user, password); 参数 #    method\n要使用的HTTP方法，比如「GET」、「POST」、「PUT」、「DELETE」、等。对于非HTTP(S) URL被忽略。\n  url\n一个DOMString表示要向其发送请求的URL。\n  async 可选\n一个可选的布尔参数，默认为true，表示要不要异步执行操作。如果值为false，send()方法直到收到答复前不会返回。如果true，已完成事务的通知可供事件监听器使用。如果multipart属性为true则这个必须为true，否则将引发异常。**注意：**从Gecko 30.0 (Firefox 30.0 / Thunderbird 30.0 / SeaMonkey 2.27)开始，由于对用户体验的负面影响，主线程上的同步请求已不赞成。\n  user 可选\n可选的用户名用于认证用途；默认为null。\n  password 可选\n可选的密码用于认证用途，默认为null。\n  打出当前代码执行所需的时间：\nconsole.time(); var a = 1; console.timeEnd() "});index.add({'id':62,'href':'/history/2019-09-16-jsonp/','title':"JSONP",'content':"所有案例源代码链接 https://github.com/ChenNing02/git-hunger/tree/master/course-demo/JSONP\n请求方式 #  使用 iframe 提交 #  代码：\nindex.html\n\u0026lt;p\u0026gt;你的账户余额为\u0026lt;span id=\u0026#34;amount\u0026#34;\u0026gt;\u0026amp;\u0026amp;\u0026amp;amount\u0026amp;\u0026amp;\u0026amp;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;form action=\u0026#34;/pay\u0026#34; method=\u0026#34;POST\u0026#34; target=\u0026#34;result\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;付款\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;iframe name=\u0026#34;result\u0026#34; src=\u0026#34;about:blank\u0026#34; frameborder=\u0026#34;0\u0026#34; height=\u0026#34;50\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; server.js\nif (path === \u0026#39;/pay\u0026#39; \u0026amp;\u0026amp; method.toUpperCase() === \u0026#39;POST\u0026#39;) { let amount = fs.readFileSync(\u0026#39;./db\u0026#39;, \u0026#39;utf8\u0026#39;) let newAmount = amount - 1 // 随机成功或失败，这样可以查看成功或失败的效果  if (Math.random() \u0026gt; 0.5) { // 修改存储数据的文件  fs.writeFileSync(\u0026#39;./db\u0026#39;, newAmount) response.write(\u0026#39;success\u0026#39;) } else { response.write(\u0026#39;fail\u0026#39;) } response.end() }  使用iframe代替打开新窗口，这样就可以不打开新窗口来显示成功或失败\n 源代码链接\nhttps://github.com/ChenNing02/git-hunger/tree/master/course-demo/JSONP/1_iframe\n使用image发请求 #  index.html\n\u0026lt;p\u0026gt;你的账户余额为\u0026lt;span id=\u0026#34;amount\u0026#34;\u0026gt;\u0026amp;\u0026amp;\u0026amp;amount\u0026amp;\u0026amp;\u0026amp;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;button id=\u0026#34;button\u0026#34;\u0026gt;打钱\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; button.addEventListener(\u0026#39;click\u0026#39;, (e)=\u0026gt;{ let image = document.createElement(\u0026#39;img\u0026#39;) image.src = \u0026#39;/pay\u0026#39; image.onload = function(){ alert(\u0026#39;打钱成功\u0026#39;) amount.innerText = amount.innerText - 1 } image.onerror = function(){ alert(\u0026#39;打钱失败\u0026#39;) } }) \u0026lt;/script\u0026gt; server.js\nif (path === \u0026#39;/pay\u0026#39;/* \u0026amp;\u0026amp; method.toUpperCase() === \u0026#39;POST\u0026#39; */) { let amount = fs.readFileSync(\u0026#39;./db\u0026#39;, \u0026#39;utf8\u0026#39;) let newAmount = amount - 1 if (Math.random() \u0026gt; 0.5) { fs.writeFileSync(\u0026#39;./db\u0026#39;, newAmount) response.setHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;image/jpg\u0026#39;) response.statusCode = 200 response.write(fs.readFileSync(\u0026#39;./thg.jpg\u0026#39;)) // 返回一个图片  } else { response.statusCode = 400 response.write(\u0026#39;fail\u0026#39;) } response.end() } 可以做到不刷新页面的方法发送请求并返回数据\n但是还是需要刷新当前页面\n源代码链接\nhttps://github.com/ChenNing02/git-hunger/tree/master/course-demo/JSONP/2_image\n跨域请求 #  打开 C:\\Windows\\System32\\drivers\\etc 目录下的 hosts 文件，添加以下内容\n表示访问 chen.com 和 ning.com 即代表访问 127.0.0.1\n127.0.0.1 chen.com 127.0.0.1 ning.com 修改 chen 中的 script 的 src 路径为：\nscript.src = \u0026#39;http://ning.com:8002/pay\u0026#39; 然后重新开两个服务器\n在 chen 文件夹中开启\nnode server 8001 使用 chen.com:8001 访问\n在 ning 文件夹中开启\nnode server 8002 使用 ning.com:8002 访问\n在 chen 的域名中的网站点击打钱则会向 ning 域名下的存储文件扣钱\n也就是 chen 网站向 ning 网站发出请求，请求修改了 ning 网站的数据存储文件\nchen 网站的前端页面还是 chen 文件夹下的 index.html，但是发出的请求在 ning 文件夹下的 server.js 中处理，所以修改的存储文件也是 ning 文件夹下的 db 文件\n源代码链接\nhttps://github.com/ChenNing02/git-hunger/tree/master/course-demo/JSONP/4_cross-domain\n处理耦合 #  在之前的基础上在 ning 文件夹中的 server.js 的 path === \u0026lsquo;/pay\u0026rsquo; 条件下修改 response.write 的内容：\nresponse.write(` ${query.callbackName}.call(undefined,\u0026#39;success\u0026#39;) `) 将返回的函数名以 ${query.callbackName} 形式写入， 表示 script 的 src 地址中 ? 后的参数，这样前端的页面即可以在请求中加入一个含函数名的参数，后端即使不知道参数名称也可以调用这个函数\nchen 文件夹中 前端页面的 src 地址\nscript.src = \u0026#39;http://ning.com:8002/pay?callbackName=xxx\u0026#39; 源代码链接\nhttps://github.com/ChenNing02/git-hunger/tree/master/course-demo/JSONP/5_cross-domain-decoupling\nJSONP的由来 #  创造一个随机数组成的函数名\nlet functionName = \u0026#39;chen\u0026#39;+parseInt(Math.random()*100000,10) 放到被调用的函数名上\nwindow[functionName] = function(result){ if(result === \u0026#39;success\u0026#39;){ amount.innerText = amount.innerText - 1 } } 在 src 地址中添加这个函数名的参数\nscript.src = \u0026#39;http://ning.com:8002/pay?callback=\u0026#39; + functionName  server.js 中的 ${query.callbackName}.call(undefined,'success') 就是 JSONP\n JSONP案例 #  index.html\n\u0026lt;p\u0026gt;你的账户余额为\u0026lt;span id=\u0026#34;amount\u0026#34;\u0026gt;\u0026amp;\u0026amp;\u0026amp;amount\u0026amp;\u0026amp;\u0026amp;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;button id=\u0026#34;button\u0026#34;\u0026gt;打钱\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; button.addEventListener(\u0026#39;click\u0026#39;, (e)=\u0026gt;{ let script = document.createElement(\u0026#39;script\u0026#39;) let functionName = \u0026#39;chen\u0026#39;+parseInt(Math.random()*100000,10) window[functionName] = function(result){ if(result === \u0026#39;success\u0026#39;){ amount.innerText = amount.innerText - 1 } } script.src = \u0026#39;http://ning.com:8002/pay?callback=\u0026#39; + functionName document.body.appendChild(script) script.onload = function(e){ e.currentTarget.remove() delete window[functionName] } script.onerror = function(e){ alert(\u0026#39;fail\u0026#39;) e.currentTarget.remove() delete window[functionName] } }) \u0026lt;/script\u0026gt; server.js\nif(path === \u0026#39;/pay\u0026#39;/* \u0026amp;\u0026amp; method.toUpperCase() === \u0026#39;POST\u0026#39; */){ let amount = fs.readFileSync(\u0026#39;./db\u0026#39;, \u0026#39;utf8\u0026#39;) let newAmount = amount - 1 fs.writeFileSync(\u0026#39;./db\u0026#39;, newAmount) response.setHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/javascript\u0026#39;) response.statusCode = 200 response.write(` ${query.callback}.call(undefined,\u0026#39;success\u0026#39;) `) response.end() } 源代码链接\nhttps://github.com/ChenNing02/git-hunger/tree/master/course-demo/JSONP/6_JSONP\n在 jQuery 中使用 JSONP #  只需要将button中的代码换为以下代码\nbutton.addEventListener(\u0026#39;click\u0026#39;, (e)=\u0026gt;{ $.ajax({ url: \u0026#34;http://ning.com:8002/pay\u0026#34;, dataType: \u0026#39;jsonp\u0026#39;, success: function(response){ if(response === \u0026#39;success\u0026#39;){ amount.innerText = amount.innerText - 1 } } }) })  functionName 不需要传入，jQuery 会帮你做 一个随机函数名\n 源代码链接\nhttps://github.com/ChenNing02/git-hunger/tree/master/course-demo/JSONP/7_jQuery-ajax\n使用的API #  请求成功处理函数\nelement.onload = function(){ alert(\u0026#39;打钱成功\u0026#39;) } 请求失败处理函数\nelement.onerror = function(){ alert(\u0026#39;打钱失败\u0026#39;) } 点击事件函数\n两个参数：事件类型、回调函数\nelement.addEventListener(\u0026#39;click\u0026#39;, (e)=\u0026gt;{ // 点击事件的回调函数内容 }) 获取当前事件的API\nelement.onerror = function(e){ e.currentTarget.remove() // 表示删除当前事件的element } 字符串转数字类型\n语法：\nparseInt(string, radix) 将一个字符串 string 转换为 radix 进制的整数， radix 为介于2-36之间的数。\n伪随机数\n函数返回一个浮点, 伪随机数在范围[0，1)，也就是说，从0（包括0）往上，但是不包括1（排除1），然后您可以缩放到所需的范围\nMath.random() 案例：\n获取一个十进制的number类型的随机数\nconsole.log(parseInt(Math.random()*100000, 10)) 为什么JSONP无法发送POST请求 #  因为JSONP是通过动态创建script实现的，动态创建script时只能用GET 没办法用POST\n"});index.add({'id':63,'href':'/history/2019-09-14-vim-get-started/','title':"vim 入门",'content':"退出vim #    不保存强制退出：:q!\n  强制退出：:qa!\n  区别：使用 :q! 会退出并且抛出一个错误，而使用 :qa! 会直接退出不抛出错误\n查看官方文档 vimtutor\n使用到的单词\nquit 退出 write/read 写入/读取 copy(yank) 拷贝(把...拽到) paste 粘贴 delete 删除 change 改变 line 行 find 查找文字 word 查找单词 forward/backward 向前/向后 up/down 向上/向下 insert/append 插入/ insert 模式(编辑模式) 普通模式(normal模式) do/undo/redo 做/撤销/还原 默认模式 (普通模式)\n按 x 删除光标所在字母\n按 u 撤销\n按 ctrl + r 重做\n按 i 在光标前插入\n按 a 在光标后插入\n按 Shift + i 移至当前行尾\n按 Shift + a 移至当前行首\n:wq 保存并退出 (write)\nCtrl + d 向下翻半页\nCtrl + u 向上翻半页\ndd 删除当前行\ndw 删除光标后的单词 (delete a word)\nShift + d 删除当前行光标后的所有内容\ndb 删除光标前的单词 (delete backward)\ndi() 只删除括号内的内容，不包括括号\nda() 删除括号内的内容，包括括号\ndi{} 删除大括号内的内容\ndit 删除 html 标签内的内容 (delet in tag)\ncit 删除html标签的内容并开启编辑模式\n"});index.add({'id':64,'href':'/history/2019-09-14-vim%E7%9A%84%E4%BD%BF%E7%94%A8/','title':"vim 的使用",'content':"退出vim #    不保存强制退出：:q!\n  强制退出：:qa!\n  区别：使用 :q! 会退出并且抛出一个错误，而使用 :qa! 会直接退出不抛出错误\n查看官方文档 vimtutor\n使用到的单词\nquit 退出 write/read 写入/读取 copy(yank) 拷贝(把...拽到) paste 粘贴 delete 删除 change 改变 line 行 find 查找文字 word 查找单词 forward/backward 向前/向后 up/down 向上/向下 insert/append 插入/ insert 模式(编辑模式) 普通模式(normal模式) do/undo/redo 做/撤销/还原 默认模式 (普通模式)\n按 x 删除光标所在字母\n按 u 撤销\n按 ctrl + r 重做\n按 i 在光标前插入\n按 a 在光标后插入\n按 Shift + i 移至当前行尾\n按 Shift + a 移至当前行首\n:wq 保存并退出 (write)\nCtrl + d 向下翻半页\nCtrl + u 向上翻半页\ndd 删除当前行\ndw 删除光标后的单词 (delete a word)\nShift + d 删除当前行光标后的所有内容\ndb 删除光标前的单词 (delete backward)\ndi() 只删除括号内的内容，不包括括号\nda() 删除括号内的内容，包括括号\ndi{} 删除大括号内的内容\ndit 删除 html 标签内的内容 (delet in tag)\ncit 删除html标签的内容并开启编辑模式\n"});index.add({'id':65,'href':'/history/2019-09-10-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/','title':"命令行常用技巧",'content':"目录跳转 #  跳转至用户目录 cd ~/\n查看当前目录 pwd\n打开指定文件 start 路径\n快速跳转 #  安装\n 注：如果觉得文字过多步骤繁琐，下面有简化版\n 在用户目录下创建一个文件夹进入这个目录\nmkdir ~/GitHub/rupa cd ~/GitHub/rupa 下载 z 命令的文件：\ngit clone https://github.com/rupa/z.git 进入 z 目录 cd z\n使用 pwd 查看当前目录路径，复制 pwd 显示的路径并在路径后添加 /z.sh\n/c/Users/xxx/GitHub/rupa/z/z.sh 可以用 ~ 代替用户目录，如下：\n~/GitHub/rupa/z/z.sh 用 VSCode (其他编辑器也可以，但是不要使用记事本等打开) 打开 用户目录下的 .bashrc 文件\n然后把上面的路径复制添加在用户目录 ( cd ~/ ) 下的 .bashrc 文件中：\n在前面加一个 . 并用空格隔开\n. ~/GitHub/rupa/z/z.sh  . 是 source 的缩写 所以也可以写作 source\n 在 .bashrc 文件中添加一行以下内容，就可以使用 j  键代替 z 键了\nalias j='z' 使用\n使用 j + 任何文件名可以快速跳转至该文件目录，可以不写全称。\n只输入 j 可显示历史目录\n 注：快速跳转只支持去过的历史目录\n 文中的 git clone https://github.com/rupa/z.git 来源：\n  在 GitHub 仓库搜索 z ，选择 rupa/z，如图：\n  之后就可以下载啦\n   简化版快速跳转 #  打开命令行工具\n  mkdir ~/repos\n  cd ~/repos\n  git clone https://github.com/rupa/z.git\n  touch ~/.bashrc\n  start ~/.bashrc\n在文件中写入\n. ~/repos/z/z.sh alias j='z'   重启 Git Bash\n  你去过的所有目录都会被记录了！使用 j XXX 就可以快速到达之前去过的目录了！\n  使用 j 可以查看所有去过的目录\n  配置.bashrc #  简洁的 git 命令 #  在 ~/.bashrc 中添加如下\nalias gst=\u0026quot;git status -sb\u0026quot; alias ga=\u0026quot;git add\u0026quot; alias gc=\u0026quot;git commit -v\u0026quot; alias gcc=\u0026quot;git commit . -m update\u0026quot; alias gp=\u0026quot;git push\u0026quot; alias gl=\u0026quot;git pull\u0026quot; 再执行 . ~/.bashrc (或者重启命令行)，就可以使用更简洁的 git 命令\n . ~/.bashrc 是 source ~/.bashrc 命令的简称\n 打开文件 #  首先在 ~/.bashrc 文件中添加：\nalias open=\u0026#39;start\u0026#39; 然后在命令行执行 . ~/.bashrc\n即可用 open 代替 start 执行打开文件命令\n历史 #  在 ~/.bashrc 中添加，查看历史 log 更直观\nalias glog=\u0026quot;git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset' --abbrev-commit -- | less\u0026quot; 然后在命令行执行 . ~/.bashrc\n添加后就可以使用 glog 命令查看当前 git 仓库的历史的提交了\n 注：退出按 q\n 打开当前仓库\n安装\nnpm i -g git-open 安装后在当前仓库运行以下命令，即可打开对应仓库GItHub链接\ngit open 装一个好看的字体 #  先下载：https://github.com/powerline/fonts/tree/master/SourceCodePro\n最好把每个 .otf 后缀的文件都下载，这样字体的样式很多，下载后全选右键选择安装即可\n然后重启命令行在设置中选择该字体即可\n添加tree命令 #  安装tree #  官网：http://gnuwin32.sourceforge.net/packages/tree.htm\n选择 Complete package, except sources 那一行下载完整包，如图：\n安装成功后在用户目录下的  .bashrc 输入\nexport PATH=\u0026quot;$PATH:/C/Software/GnuWin32/bin\u0026quot; 其中 $PATH: 后的路径为 tree 安装路径下的 bin 路径 (注意路径中的 \\ 要修改为 / 格式)\n然后 . ~/.bashrc 一下\n然后运行 which tree  如果出现了安装路径就说明成功了\n使用 tree . 即可查看当前目录\n这篇教程的原文来自方方老师一篇博客：https://xiedaimala.com/bbs/topics/184#/\n翻译工具 #  安装 npm i -g fanyi\n使用 fy hi\n命令行中的快捷键 #  搜索历史 #  首先按一下 ctrl + R 然后输入命令 的一部分\n然后会显示历史命令，然后按住 ctrl 再按 R 切换历史命令，直到切换到自己想要的，按方向键左右键即可退出\n如果是需要的命令 按方向键左右即可在当前行显示该命令\n如果不想搜索 使用 Ctrl + Go 退出搜索\n删除当前行 #  按下 ctrl + a 到达命令首字母，然后再按下 ctrl + k 删除本行命令\n其他快捷键 #   光标移至行首 Ctrl + A  光标移至行尾 Ctrl + E  光标退后 Ctrl + B  光标前进 Ctrl + F  删一个单词 Ctrl + W 中断命令 Ctrl + Cancel  使用上一条命令的最后一个参数 Alt + .  查看更多快捷键\n谷歌搜索 bash 快捷键，推荐网址：https://linuxtoy.org/archives/bash-shortcuts.html\n安装Ubuntu #  在 Win10 的 Microsoft Store 搜索 Ubuntu 下载安装\nwindows目录\n在 Ubuntu 中 windows 目录在 /mnt/ 下\n如 c 盘 /mnt/c/\n设置快捷打开目录\nln -s /mnt/c/xxx/GitHub/ 设置后直接使用 cd 当前目录 即可\n打开当前目录文件夹\nexplorer.exe . 你可以将 explorer.exe 设置为 start ，用 vim 打开 vi ~/.bashrc\n按 i 然后在最下方插入 alias start=\u0026quot;explorer.exe\u0026quot;\n然后 :wq 保存\n然后就可以使用 start . 打开目录了\n一个报错\nerror: 0x8007019e 解决方法\n键盘行按键win+x，选择Windows PowerShell（管理员）\n输入：\nEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 回车输入Y并重启。 重启打开Ubuntu的命令窗口，等几分钟，输入账户和密码即可。\n以 root 方式进入 Ubuntu\n使用 sudo passwd root 设置 root 的密码 (默认情况下密码在命令行不会显示)\n设置后输入 su root 输入密码进入\n在Cmder中添加Ubuntu\n首先打开设置，在启动中设置以下选项\n然后就可以在 Cmder 中新建 Ubuntu 窗口了\n也可以把 Ubuntu 设置为默认启动\n拓展 #  复制粘贴快捷键\nGit Bash 粘贴：按住鼠标中键，或者 Shift + Ins 是复制\ncmd 复制：选中然后按回车键\nnpm 命令卸载插件\nnpm uninstall 插件名 -g "});index.add({'id':66,'href':'/history/2019-09-09-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/','title':"浏览器缓存",'content':"Cookie #   服务器通过 Set-Cookie 头给客户端一串字符串 客户端每次访问相同域名的网页时，必须带上这段字符串 客户端要在一段时间内保存这个Cookie Cookie 默认在用户关闭页面后就会失效 (后台代码可以任意设置 Cookie 的过期时间) Cookie 存储的大小一般在 4kb 以内 Cookie存在的问题：用户可以随意篡改 Cookie 的内容  请求优化\nresponse.setHeader(\u0026#39;Cache-Control\u0026#39;, \u0026#39;max-age=30\u0026#39;) // 意思是30秒内同样的URL不在重复访问，直接从本地缓存获取  注：首页无法设置，因为浏览器不允许。\n 更新缓存：\n可以通过更改主页引入的URL地址来更新缓存：\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./css/default.css?v=2\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;./js/main.js?v=2\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  更多API搜索： http set cookie\n Expire #    作用与Cache-Control 类似，但计算时间的方法不一样，Expire 是通过类似闹钟的设置，到了某个固定的时间点更新请求 (固定时间指的是本地时间)\n  但是这种方法有个缺点就是用户的系统时间错乱了容易误判时间 (比如用户将时间设定在未来的时间点，那这种方法的时间就会缩短或无效)。\n  两种方法同时存在时优先使用 Cache-Control\n  Cache-Control 与 Expire 的区别\n一个是多久过期，一个是什么时间过期\nSession #   将 SessionID (随机数) 通过 Cookie 发给客户端 客户端访问服务器时，服务器读取 SessionID 服务器有一块内存 (哈希表) 保存了所有 session 通过 SessionID 我们可以得到对应用户的隐私信息，如 id、email 这块内存 (哈希表) 就是服务器上的所有 session   概况：Session 就是给每个用户一个随机数组成的ID，每个ID对应一个用户名，用户第一次登陆后下次每次登录只需要通过用户的ID查找用户名即可，即使有人篡改ID，由于ID是由随机数组成，所以很难破解。\n LocalStorage #  html5 所有新的web技术统称为 html5技术 包括，新的标签，新的\u0026hellip;\nLocalStorage 是 HTML5 技术 提供的API\nLocalStorage 本质是一个浏览器上的一个哈希表\nAPI用法：\n//在内存中存储一个key并且对应一个value localStorage.setItem(\u0026#39;a\u0026#39;,\u0026#39;1\u0026#39;) //object类型不能直接存储，需要通过JSON转换 localStorage.setItem(\u0026#39;jsonString\u0026#39;, JSON.stringify({name:\u0026#39;obj\u0026#39;})) //获取存储的值 localStorage.getItem(\u0026#39;a\u0026#39;) //获取\u0026#39;a\u0026#39;对应的value \u0026#39;1\u0026#39; localStorage.getItem(\u0026#39;jsonString\u0026#39;) //获取\u0026#39;jsonString\u0026#39;对应的value \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;obj\u0026#34;}\u0026#39; //清除所有存储的值 localStorage.clear() //清除内存中存储的所有值  用来操作当前页面的哈希\n LocalStorage 可以存储在本地C盘的一个文件中，所以即使页面刷新它的值也不会消失\n案例：a每次刷新后都会加一并存储在本地C盘文件中\nlet a = localStorage.getItem(\u0026#39;a\u0026#39;) if(!a){ a = 0 }else { a = (+a) + 1 //这里也可看写作 a = parseInt(a,10) + 1 表示将a转换为数字再加一 } console.log(\u0026#39;a\u0026#39;) console.log(a) localStorage.setItem(\u0026#39;a\u0026#39;, a) 用途\n典型案例：网页改版提示，使用 localStorage 可以使网页改版后的页面只会在用户第一次刷新时提示\nlet already = localStorage.getItem(\u0026#39;已提示\u0026#39;) if(!already){ alert(\u0026#39;你好，我们的网页已经改版，来看看有哪些新功能吧~\u0026#39;) localStorage.setItem(\u0026#39;已提示\u0026#39;, true) } LocalStorage 的特点：\n  LocalStorage 与 HTTP 无关\n  HTTP 不会带有 LocalStorage 的值\n  只有相同域名的网页才可以互相读取 LocalStorage (但没有同源策略那么严格)\n  每个域名 LocalStorage 最大存储量为 5Mb 左右 (每个浏览器都不一样)\n//如何测试浏览器 LocalStorage 的最大存储: let a = \u0026#39;\u0026#39; for(let i = 0; i \u0026lt; 1000000; i++){ a += \u0026#39;嘤嘤嘤嘤嘤嘤嘤嘤嘤\u0026#39; } console.log(a.lenght) localStorage.setItem(\u0026#39;xxx\u0026#39;, a)   常用场景: 记录一些没有提示过用户 (比如只需要提示用户一次的更新信息)，以及一些没有用的信息 (不涉及隐私敏感信息的普通信息)\n  LocalStorage 理论上永久有效，除非你将浏览器的缓存清理\n  SessionStorage #  中文：会话存储\n常用API与 LocalStorage 类似:\nsessionStorage.setItem(\u0026#39;a\u0026#39;,1) //添加 sessionStorage.getItem(\u0026#39;b\u0026#39;) //获取  除了 SessionStorage 在用户关闭页面 (会话结束) 后就会失效。其他特点与 LocalStorage 的特点基本一致\n 课题 #  Cookie 和 Session 的区别 #  一般来说Session 是基于Cookie实现的，因为Session 必须将 SessionID放在 Cookie中再发送给客户端(Session 依赖于Cookie)\nCookie 与 LocalStorage 的区别 #    Cookie每次请求都会被浏览器带到服务器上 (HTTP会带上Cookie的值) ，但LocalStorage不会，因为LocalStorage 与 HTTP 无关。\n  Cookie 一般最大的大小只有4k 左右，但LocalStorage 最大存储量为 5Mb 左右 (每个浏览器都不一样)\n  Cookie 设置过期时间 #  response.setHeader(\u0026#39;Set-Cookie\u0026#39;, \u0026#39;Max-Age=30\u0026#39;) // 单位秒 清除Cookie #  首先引入MDN中一个小框架：https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie\n如图：\n然后调用\ndocCookies.removeItem(name) // name 输入要清除的cookie的key即可 LocalStorage 和 SessionStorage 的区别 #  区别就是 SessionStorage 在用户关闭页面 (会话结束) 后就会失效。而 LocalStorage 理论上永久有效，除非你将浏览器的缓存清理。\nCache-Control: max-age=1000 缓存 与 ETag 的「缓存」有什么区别？ #  Cache-Control: max-age=1000 缓存 设定在1000秒后必须重新加载缓存，在此期间不需要重新请求。 而 ETag 的「缓存」是通过对比MD5判断本地文件与服务器文件有无变化，只有有变化才会重新下载文件。ETag的 缓存 有请求有响应，但是只有本地文件与服务器文件有变化时才会重新加载响应。\nETag #  请求判断文件的MD5是否与原来的相同，相同则不响应\n缓存与 302 的区别\n缓存没有请求，304 有请求有响应，但没有响应第四部分\n"});index.add({'id':67,'href':'/history/2019-09-09-css%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/','title':"CSS 常用属性",'content':"清除浮动 #  最简便的写法\n.clearfix::after { content: \u0026#39;\u0026#39;; display: block; clear: both; } /* IE 兼容 */ .clearfix{ zoom: 1; } 默认属性去除 #  去掉默认的轮廓线\noutline: none; 去掉列表前面的序列号或点\nlist-style: none; textarea 去除\ntextarea { width: 200px; height: 200px; overflow: hidden; resize: none; /* 设置大小不可拖动 */ } 图片 #  图片文字中线对齐\nvertical-align: middle; 背景 #  透明背景 #  div { background-color: none; background-color: transparent; }  两个样式效果一样\n 背景图片 #  背景图片居中等比例缩放\nbody { background: url(../img/rs-cover.jpg); /* 背景图片水平居中，垂直居中 */ background-position: center center; /* background-size: cover 盖住我当前div的所有面积，按比例缩放。大概就是按照div的比例缩放的意思 */ background-size: cover; } a 标签 #  默认属性\na { color: inherit; /* 颜色继承父元素 */ text-decoration: none; /* 去掉下划线 */ } a 标签的禁止触发点击\n\u0026lt;a herf=\u0026#34;javascript:volid(0);\u0026#34;\u0026gt;不跳转\u0026lt;/a\u0026gt; 设置页面所有 a 标签在新页面打开，在 head 标签中添加以下标签：\n\u0026lt;base target=\u0026#34;_blank\u0026#34;\u0026gt; 文本 #  字母大写 #  text-transform: uppercase; 文本省略 #  一行的多余文字省略\ndiv { border: 1px solid red; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } 多行的多余文字省略\n  首先如果忘记如何使用可以谷歌搜索：css multi line text ellipsis\n  代码(此代码会在第二行后加省略，第二行后的内容会被隐藏)：\ndiv { border: 1px solid red; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }   字符 #  空格符：\u0026amp;nbsp; 禁止文本选中 #  user-select: none; 两边对齐 #  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS Bin\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; span { border: 1px solid green; display: inline-block; width: 5em; text-align: justify; line-height: 20px; overflow: hidden; height: 20px; } span::after { content: \u0026#39;\u0026#39;; display: inline-block; width: 100%; border: 1px solid blue; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;span\u0026gt;姓名\u0026lt;/span\u0026gt;\u0026lt;br data-tomark-pass\u0026gt; \u0026lt;span\u0026gt;联系电话\u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  原理：首先将span标签添加为行内块元素并添加 text-align: justify; 属性，此属性表示多行文字内容左右占满对齐，但此时span只有一行，所以需要用伪元素添加多行，给span 添加一个 after 伪元素使它和span本身的宽度一样宽，由于上面设置的宽度是5em，所以after就沾满了，此时span的宽度才被撑开到5em，此时就是左右文字都填充对齐了，再给span一个相同的高度和行高 并且使用 overflow: hidden 隐藏多余的after伪元素，就可以了\n 内联元素 #  连续字母换行 #  有时多个连续的英文字母即时用内联元素包裹也无法换行，如下案例所示： 代码\n\u0026lt;style\u0026gt; div { width: 200px; height: 50px; border: 1px solid blue; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;ssssssssssssssssssaaaaaaaaaa\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 效果链接：http://js.jirengu.com/cugovewodi/2/edit\n这时给div添加以下属性\ndiv { word-break: break-all; } 连续字母就可以换行了 效果链接：http://js.jirengu.com/hehatujuwe/1/edit\n解决定位时内联元素竖直排列 #  当一个内联元素绝对定位时，会竖直排列，而不是正常横向排列给内联元素添加以下属性即可\nwhite-space: nowrap; box-sizing #  MDN文档：https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing 常用样式：\nbox-sizing: border-box; 动画 #  动画过渡 #  点击查看MDN文档\n当前元素所有动画平滑过渡 时间 0.3 秒\ntransition: all 0.3s; 指定属性过渡\ntransition: width 2s; /* 宽度添加过渡效果 2s */ MDN案例\nhtml\n\u0026lt;div class=\u0026#34;sidebar\u0026#34;\u0026gt; \u0026lt;p\u0026gt;\u0026lt;a class=\u0026#34;menuButton\u0026#34; href=\u0026#34;home\u0026#34;\u0026gt;Home\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;a class=\u0026#34;menuButton\u0026#34; href=\u0026#34;about\u0026#34;\u0026gt;About\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;a class=\u0026#34;menuButton\u0026#34; href=\u0026#34;contact\u0026#34;\u0026gt;Contact Us\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;a class=\u0026#34;menuButton\u0026#34; href=\u0026#34;links\u0026#34;\u0026gt;Links\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; css\n.menuButton { position: relative; transition-property: background-color, color; transition-duration: 1s; transition-timing-function: ease-out; text-align: left; background-color: grey; left: 5px; top: 5px; height: 26px; color: white; border-color: black; font-family: sans-serif; font-size: 20px; text-decoration: none; box-shadow: 2px 2px 1px black; padding: 2px 4px; border: solid 1px black; } .menuButton:hover { position: relative; transition-property: background-color, color; transition-duration: 1s; transition-timing-function: ease-out; background-color:white; color:black; box-shadow: 2px 2px 1px black; } 操作元素 #  移动位置\n括号内表示坐标 (X轴 Y轴)\n单位可以使用百分比 ( 百分比根据自身 )\ntransform: translate(120px, 50%); 放大缩小\n括号内表示坐标 (X轴 Y轴)\ntransform: scale(2, 2); /* 放大 */ transform: scale(0.3, 0.3); /* 缩小 */ 拉伸\ntransform: skew(30deg, 0deg); /* 括号内参数(x轴，y轴) */ 选择器 #  伪类选择器\n选择父元素的第n个子元素\ne:nth-child(n) 选择父元素的第n个子元素，从最后向前数\ne:nth-last-child(n) 选择父元素的第一个子元素，等价于 e:nth-child(1)\ne:first-child 选择父元素的最后一个子元素，等价于 e:nth-last-child(1)\ne:last-child 选择不包含任何子元素的元素（注意，文本节点也被看作子元素）\ne:empty 拓展用法案例\np:nth-child(3) { color:#f00; } p:nth-child(odd) { color:#f00; } p:nth-child(even) { color:#f00; } p:nth-child(3n+0) { color:#f00; } p:nth-child(3n) { color:#f00; } tr:nth-child(2n+11) { background:#ff0; } "});index.add({'id':68,'href':'/history/2019-09-01-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2-%E5%93%8D%E5%BA%94%E5%BC%8F/','title':"移动端页面(响应式)",'content':"大纲 #    学会 media query (媒体查询)\n  学会要设计图（没图不做）\n 实在要做，也要提前画好草稿给应用看，提前达成共识。    学会隐藏元素\n  手机端要加一个 meta:vp 标签，示例：\n\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\u0026#34;\u0026gt;   手机端的交互方式不一样\n 没有 hover (没有鼠标经过) 有 touch 事件 (触摸事件) 没有 resize 没有滚动条    media query(媒体查询) #  根据设备显示宽度判断设备\n使用最大值来区分，如果某个媒体满足宽度是0-800之间就使得它的body变红\n@media (max-width: 800px) { body{ background: red; } } 也可以使用最小值判断，表示只在大于 800px 的设备上有该效果\n@media (min-width: 800px) { body{ background: red; } } 或者两个一起使用，表示大于 320px 小于 800px 宽度的设备显示\n@media(min-width: 320px) (max-width: 800px) { body{ background: red; } } 只在设备最大宽度为320px的设备生效，但一定会提前下载文件\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;style.css\u0026#34; media=\u0026#34;(max-width: 320px)\u0026#34;\u0026gt; 或者限定指定宽度内 (最小宽度为 320px 最大宽度为 800px 的设备)\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;two.css\u0026#34; media=\u0026#34;(min-width: 320px) and (max-width: 800px)\u0026#34;\u0026gt; 手机端要加 meta:vp #  在手机端中默认会用 320px 的宽度模拟 980px 宽度缩放显示网页，也就是等比例缩放\n所以需要用以下代码禁止缩放\n示例1\n\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\u0026#34;\u0026gt; 示例2 (更简短)\n\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; 长度单位 #   px 像素 em 一个 m 的宽度，也可以说成一个汉字的宽度 rem 全称：root em 页面中根元素的 font-size 大小 vh 全称：viewport height 视口高度 100vh=视口高度 vw 全称：viewport width 视口宽度 100vw=视口宽度   网页默认的字体大小是16px，谷歌浏览器中默认最小字体是12px\n "});index.add({'id':69,'href':'/history/element-ui/','title':"Element UI",'content':"分页组件 #  常用属性 #     名称 作用 类型 可选值 默认值     small 使用小型分页样式 boolean  false   background 为分页按钮添加背景色 boolean  false   page-size 每页显示数据个数 (支持 .sync 修饰符) number  10   total 数据总个数 (总条目数) number     current-page 当前页数 (支持 .sync 修饰符)   1    事件 #     名称 说明 回调参数     current-change 当前页 (currentPage) 改变时会触发 当前页    常用带跳转案例\n\u0026lt;el-pagination background @current-change=\u0026#34;handleCurrentChange\u0026#34; :current-page.sync=\u0026#34;currentPage1\u0026#34; :page-size=\u0026#34;100\u0026#34; layout=\u0026#34;total, prev, pager, next\u0026#34; :total=\u0026#34;1000\u0026#34;\u0026gt; \u0026lt;/el-pagination\u0026gt; "});index.add({'id':70,'href':'/history/vue%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/','title':"Vue 入门案例",'content':"几个 Vue 入门的小案例\n在使用 Vue 前注意引入一个 Vue 库，当前案例使用的是 script 标签引入如下版本\n\u0026lt;script src=\u0026#34;https://cdn.bootcss.com/vue/2.6.10/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 按钮开/关提示 #  代码 html \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button v-on:click=\u0026#34;go\u0026#34;\u0026gt;开/关\u0026lt;/button\u0026gt; \u0026lt;p v-if=\u0026#34;open\u0026#34;\u0026gt;我是文字内容\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; JavaScript let app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { open: false }, methods: { go(){ this.open = !this.open } } }) CSS p { border: 1px solid #ccc; padding: 10px; width: 200px; }  鼠标悬浮提示 #  代码\nhtml \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p v-bind:title=\u0026#34;xxx\u0026#34;\u0026gt;鼠标悬浮当前文字显示提示\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; JavaScript let app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { xxx: \u0026#39;我是文字提示\u0026#39; } }) CSS p { border: 1px solid #ccc; padding: 10px; width: 200px; }  简单的轮播 #  代码 html \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;window\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;demo\u0026#34; v-bind:style=\u0026#34;{transform: transformValue}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button v-on:click=\u0026#34;go(0)\u0026#34;\u0026gt;1\u0026lt;/button\u0026gt; \u0026lt;button v-on:click=\u0026#34;go(1)\u0026#34;\u0026gt;2\u0026lt;/button\u0026gt; \u0026lt;button v-on:click=\u0026#34;go(2)\u0026#34;\u0026gt;3\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; JavaScript let app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { transformValue: \u0026#39;\u0026#39; }, ​ methods:{ ​ go(index){ this.transformValue = `translateX(${-100*index}px)` } ​ } }) CSS body { padding: 100px 0 0 200px; } .window { width: 100px; height: 100px; border: 1px solid blue; } .demo { width: 300px; height: 100px; background: rgba(0, 0, 255, 0.3); transition: all 0.3s; }  tab 切换 #  简单的切换\nhtml \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li v-on:click=\u0026#34;selected = 0\u0026#34;\u0026gt;1\u0026lt;/li\u0026gt; \u0026lt;li v-on:click=\u0026#34;selected = 1\u0026#34;\u0026gt;2\u0026lt;/li\u0026gt; \u0026lt;li v-on:click=\u0026#34;selected = 2\u0026#34;\u0026gt;3\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li v-show=\u0026#34;selected === 0\u0026#34;\u0026gt;内容1\u0026lt;/li\u0026gt; \u0026lt;li v-show=\u0026#34;selected === 1\u0026#34;\u0026gt;内容2\u0026lt;/li\u0026gt; \u0026lt;li v-show=\u0026#34;selected === 2\u0026#34;\u0026gt;内容3\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; JavaScript let app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { selected: 0 } }) CSS li { list-style: none; display: inline-block; padding: 10px; border: 1px solid #ccc; }  for循环切换\nhtml \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li v-for=\u0026#34;tab in tabs\u0026#34; v-on:click=\u0026#34;selected = tab.name\u0026#34; v-bind:class=\u0026#34;{active: tab.name === selected}\u0026#34; \u0026gt;{{ tab.name }}\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li v-for=\u0026#34;tab in tabs\u0026#34; v-show=\u0026#34;selected === tab.name\u0026#34; \u0026gt;{{ tab.content }}\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; JavaScript let view = new Vue({ el: \u0026#39;#app\u0026#39;, data: { selected: \u0026#39;a\u0026#39;, tabs: [ { name: \u0026#39;a\u0026#39;, content: \u0026#39;内容a\u0026#39; }, { name: \u0026#39;b\u0026#39;, content: \u0026#39;内容b\u0026#39; }, { name: \u0026#39;c\u0026#39;, content: \u0026#39;内容c\u0026#39; } ] } }) CSS ol, li { margin: 0; padding: 0; } li { list-style: none; display: inline-block; cursor: pointer; padding: 10px; margin: 4px; border: 1px solid blue; } .active { background-color: #ccc; }  "});index.add({'id':71,'href':'/history/%E6%B5%8B%E8%AF%95%E9%A1%B5/','title':"测试页",'content':"主题添加CSS样式 #  h2 { font-size: 28px; padding-bottom: 10px; border-bottom: 1px solid #ccc; /* 所有标题样式 */ font-family: roboto, sans-serif; font-weight: bold; color: #34495e; font-size: 1.75rem; line-height: 1.225; margin: 35px 0 15px; padding-bottom: 0.5em; border-bottom: 1px solid #ddd; } html { font-size: 16px; letter-spacing: .33px; scroll-behavior: smooth; min-width: 20rem; overflow-x: hidden; } body { font-family: roboto,sans-serif; } 我是h1标题 #  我是文字内容\n我是h2标题 #  我是文字内容\n我是h3标题 #  我是文字内容\n我是h4标题 #  我是文字内容\n我是h5标题 #  我是文字内容\n我是h6标题 #  我是文字内容\n代码块测试 #  JavaScript\nfunction fn(){ console.log(\u0026#39;hi\u0026#39;) } html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;demo\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;main\u0026gt; \u0026lt;div class=\u0026#34;demo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; CSS\n* { margin: 0; padding: 0; } main { height: 100vh; display: flex; justify-content: center; align-items: center; } .demo { width: 100px; height: 100px; background-color: #000; } 有序列表 #   我是有序列表 我是有序列表 我是有序列表 我是有序列表  无序列表 #   我是无序列表 我是无序列表 我是无序列表 我是无序列表  注释块 #   我是注释内容\n 测试tabs切换 #  代码 html \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button v-on:click=\u0026#34;go\u0026#34;\u0026gt;开/关\u0026lt;/button\u0026gt; \u0026lt;p v-if=\u0026#34;open\u0026#34;\u0026gt;我是文字内容\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; JavaScript let app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { open: false }, methods: { go(){ this.open = !this.open } } }) CSS p { border: 1px solid #ccc; padding: 10px; width: 200px; }  标题测试长度测试长度测试长度测试长度测试长度测试长度测试长度测试长度测试长度测试长度测试长度 #  标题测试长度测试长度测试长度测试长度测试长度测试长度测试长度测试长度测试长度测试长度测试长度 #  git add . "});index.add({'id':72,'href':'/history/2019-08-28-webpack-use/','title':"webpack 的使用",'content':"部分命令可能会有些过时，所以要多看官方文档\n安装 node-sass #  搜索：node sass github\ngithub官网：https://github.com/sass/node-sass\n命令行输入：\nnpm install node-sass -g  -g 表示全局安装\n 全局安装与局部安装的区别\n  全局安装的命令会将插件安装在全局目录中 (包含在$PATH中)，不论在哪个目录下都可以调用\n  局部安装只能在当前路径使用该命令\n  使用 #  查看版本号\nnode-sass -v sass 的用法\n  更改CSS文件后缀为： scss\n命令行中的写法：mv style.css style.scss\n  使用 sass 编译：node-sass style.scss style.css\n  也可以使用 scss 语法书写代码：\ndiv { color: red; \u0026gt; ul { font-size: 16px; \u0026gt; li { border: 1px solid #000; \u0026gt; a { font-weight: bold; } } } } 再运行 node-sass style.scss style.css 后编译的语法：\ndiv { color: red; } div \u0026gt; ul { font-size: 16px; } div \u0026gt; ul \u0026gt; li { border: 1px solid #000; } div \u0026gt; ul \u0026gt; li \u0026gt; a { font-weight: bold; } 这样就是编译后的 CSS 了\n自动化编译\n在先前的命令后添加  -w 需要编译的文件名 例如：\nnode-sass style.scss style.css -w style.scss 将目录中所有scss文件自动化编译：\nnode-sass src/css/ -o dist/css -w 这样代码就会实时编译了，不需要每次更改都去执行先前的命令\n科普 scss 的 由来\nsass 语法 (被前端程序猿看不懂) ：\nbody p color: red 于是编译为 scss 语法 (被前端程序猿看懂的) ：\nbody p { color: red; } 安装 babel #    官网的安装教程：https://babeljs.io/docs/en/usage\n  安装后点击CLI查看命令行教程：https://babeljs.io/setup#installation\n   功能：为代码兼容IE8\n 使用 #  ./node_modules/.bin/babel js -d dist --watch  --watch 表示即时编译，这样就不需要每次更改源文件后执行一次编译，它会监听源文件，变动就会自动编译\n 自动化编译文件夹内所有js\n./node_modules/.bin/babel src/js/ -d dist/js/ --watch 前端目录分类\n src \u0026mdash; 全称 source 表示未经翻译优化的源代码 dist \u0026mdash; 全称 distribution 表示要发布的代码 vendors \u0026mdash; 名字就是全称 表示第三方代码 node_modules \u0026mdash; 表示第三方包  webpack 教程 #  官网安装教程：Getting Started 中文版教程：起步 | webpack 中文网 首先运行\nnpm init -y 然后安装\nnpm install webpack webpack-cli --save-dev 添加一个配置文件 webpack.config.js\nconst path = require('path'); module.exports = { entry: './src/index.js', output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') } }; 运行\nnpx webpack 自动化提交文件 #  自动复制修改后的文件(主要用于不需要编译的 html 文件和 img 文件)\n谷歌搜索：watch cli\n安装\nnpm i -g watch-cli 安装后执行命令\nwatch -p \u0026quot;src/index.html\u0026quot; -c \u0026quot;cp src/index.html dist/index.html\u0026quot;  将 src 目录下的 index.html 文件自动化编译到 dist 目录下的 index.html\n "});index.add({'id':73,'href':'/history/js%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%AF%86/','title':"JS基础常识",'content':"七种数据类型 #   number string boolean symbol null undefined object  五个 false 值 #   null undefined 0 NaN '\u0026rsquo; ( 空字符串 )  "});index.add({'id':74,'href':'/docs/git%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/','title':"Git用法总结",'content':"Git用法总结 #   老师谈经验：新人无法理解 git 的原理，你只能背命令。等你用 git 用一个月，再谈原理。 用 git 三个月，你就自然理解 git 了。不要试图一开始就理解 git！ Git 课外资料（可不看）：http://www.runoob.com/git/git-tutorial.html  配置 GitHub #    进入 https://github.com/settings/keys\n  如果页面里已经有一些 key，就点「delete」按钮把这些 key 全删掉。如果没有，就往下看\n  点击 New SSH key，你需要输入 Title 和 Key，但是你现在没有 key，往下看\n  打开 Git Bash\n  复制并运行 rm -rf ~/.ssh/* 把现有的 ssh key 都删掉，这句命令行如果你多打一个空格，可能就要重装系统了，建议复制运行。\n  运行 ssh-keygen -t rsa -b 4096 -C \u0026quot;你的邮箱\u0026quot;，注意填写你的邮箱！\n  按回车三次\n  运行 cat ~/.ssh/id_rsa.pub，得到一串东西，完整的复制这串东西\n  回到上面第 3 步的页面，在 Title 输入「我的第一个 key」\n  在 Key 里粘贴刚刚你你复制的那串东西\n  点击 Add SSH key\n  回到 Git Bash\n  运行\n  ssh -T git@github.com ```\n你可能会看到这样的提示：\r![2d23bb2399015a342a611ad5932b372b.png](en-resource://database/444:3)\r 输入 yes 回车……问你话你就答，别傻在那\r 然后如果你看到 Permission denied (publickey). 就说明你失败了，请回到第 1 步重来，是的，回到第 1 步重来；如果你看到 Hi FrankFang! You've successfully authenticated, but GitHub does not provide shell access. 就说明你成功了！  好了，终于 TMD 添加了一个无聊的 SSH key，不要问我这个有什么用，因为一会儿你就会用到它，你想了解原理就看这篇 文章\n如果要讲清楚，太浪费时间了，我们只是想用用 GitHub 而已。\n 一台电脑只需要一个 SSH key 一个 SSH key 可以访问你的所有仓库，即使你有 1000000 个仓库，都没问题 如果你新买了电脑，就在新电脑上重新生成一个 SSH key，把这个 key 也上传到 GitHub，它可以和之前的 key 共存在 GitHub 上 如果你把 key 从电脑上删除了，重新生成一个 key 即可，替换之前的 key  配置 git #  git config --global user.name 你的英文名 #此英文名不需要跟GitHub账号保持一致\rgit config --global user.email 你的邮箱 #此邮箱不需要跟GitHub账号保持一致\rgit config --global push.default matching\rgit config --global core.quotepath false\rgit config --global core.editor \u0026quot;vim\u0026quot;\r五句话，依次在命令行中运行（其中前两句要把中文改成对应的内容）。 一定要执行这五行！！！ 一定要执行这五行！！！ 一定要执行这五行！！！\n新建一个Git仓库 #  1.1 初始化 #    创建目录作为我们的项目目录：mkdir git-demo-1\n  进入目录 cd git-demo-1\n  git init，这句命令会在 git-demo-1 里创建一个 .git 目录\n  ls -la 你就会看到 .git 目录，它就是一个「仓库」，不要进去看，这仓库里面有毒，别进去！\n  在 git-demo-1 目录里面添加任意文件，假设我们添加了两个文件，分别是 index.html 和 css/style.css\n touch index.html mkdir css touch css/style.css    运行\ngit status -sb\r可以看到文件前面有 ?? 号\n ## Initial commit on master\r?? css/\r?? index.html\r这个 ?? 表示 git 一脸懵逼，不知道你要怎么对待这些变动。\n  使用 git add 将文件添加到「暂存区」\n 你可以一个一个地 add  git add index.html git add css/style.css   你也可以一次性 add  git add . 意思是把当前目录（.表示当前目录）里面的变动都加到「暂存区」      再次运行\ngit status -sb\r可以看到 ?? 变成了 A\n ## Initial commit on master\rA css/style.css\rA index.html\rA 的意思就是添加，也就是说你告诉 git，这些文件我要加到仓库里\n  使用 git commit -m \u0026ldquo;信息\u0026rdquo; 将你 add 过的内容「正式提交」到本地仓库（.git就是本地仓库），并添加一些注释信息，方便日后查阅\n 你可以一个一个地 commit  git commit index.html -m '添加index.html' git commit css/style.css -m \u0026quot;添加 css/style.css\u0026quot;   你也可以一次性 commit  git commit . -m \u0026quot;添加了几个文件\u0026quot;      再再次运行 git status -sb，发现没有文件变动了，这是因为文件的变动已经记录在仓库里了。\n  这时你使用 git log 就可以看到历史上的变动：\n commit f0d95058cd32a332b98967f6c0a701c64a00810a\rAuthor: frankfang \u0026lt;frankfang1990@gmail.com\u0026gt;\rDate: Thu Sep 28 22:30:43 2017 +0800\r添加几个文件\r  以上就是 git add / git commit 的一次完整过程，可以看到，挺复杂的。原则上，你错了任何一步，就给我从头来一遍，做到你不会再手抖为止。\n  1.2 文件变动 #  如果我想继续改文件，应该怎么做呢？\n  start css/style.css 会使用默认的编辑器打开 css/style.css（macOS 上对应的命令是 open css/style.css）\n  然后我们在 css/style.css 里写入 body {background: red}，保存退出\n  运行\ngit status -sb\r发现提示中有一个 M\n ## master\rM css/style.css\r这个 M 的意思就是 Modified，表示这个文件被修改了\n  此时你如果想让改动保存到仓库里，你需要先 git add css/style.css 或者也可以 git add . 注意，由于这个 css/style.css 以前被我们 add 过，你往文章上面看，我们是 add 过 css/style.css 的，所以此处的 git add 操作可以省略，但我建议你使用 git 的前一个月，不要省略 git add。 换句话说，每一次改动，都要经过 git add 和 git commit 两个命令，才能被添加到 .git 本地仓库里。\n  再次运行 git status -sb 发现 M 有红色变成了绿色，红色和绿色有啥区别呢？别管它们的区别，记住我说的，先 add，再 commit，等你熟练之后再去理解区别。 先形成肌肉记忆，在去形成大脑记忆！\n  运行 git commit -m \u0026quot;更新 css/style.css\u0026quot;，这个改动就被提交到 .git 本地仓库了。再说一次，不要去 .git 目录里面，那里的东西你一无所知。\n  再再次运行 git status -sb，会发现没有变更了，这说明所有变动都被本地仓库记录在案了。 这里来透露一下 git status -sb 是什么意思：git status 是用来显示当前的文件状态的，哪个文件变动了，方便你进行 git add 操作。-sb 选项的意思就是，SB都能看懂，哈，这是开玩笑，-s 的意思是显示总结（summary），-b 的意思是显示分支（branch），所以 -sb 的意思是显示总结和分支。\n  1.3 总结 #  至此，我们来总结一下用到的命令\n git init，初始化本地仓库 .git git status -sb，显示当前所有文件的状态 git add 文件路径，用来将变动加到暂存区 git commit -m \u0026ldquo;信息\u0026rdquo;，用来正式提交变动，提交至 .git 仓库 如果有新的变动，我们只需要依次执行 git add xxx 和 git commit -m \u0026lsquo;xxx\u0026rsquo; 两个命令即可。别看本教程废话那么多，其实就这一句有用！先 add 再 commit，行了，你学会 git 了。 git log 查看变更历史  将本地仓库上传到 GitHub #  如何将我们这个 git-demo-1 上传到 GitHub 呢？\n 在 GitHub 上新建一个空仓库，名称随意，一般可以跟本地目录名一致，也叫做 git-demo-1  按照截图所示，除了仓库名，其他的什么都别改，其他的什么都别改，其他的什么都别改，其他的什么都别改，这样你才能创建一个空仓库\n 点击创建按钮之后，GitHub 就会把后续的操作全告诉你，如图 请点击一下 ssh   看图，点击 SSH 按钮，点击 SSH 按钮，点击 SSH 按钮，我想你现在肯定不会忘了点击 SSH 按钮了吧~~~~如果不点击这个按钮，你就会使用默认的 HTTPS 地址。但是千万不要使用 HTTPS 地址，因为 HTTPS 地址使用起来特别麻烦，每次都要输入密码，而 SSH 不用输入用户名密码。 为什么 SSH 不用密码呢，因为你已经上传了 SSH public key。还记得吗？如果不记得，翻到本文第一部分「配置 GitHub」章节。\n  由于我们已经有本地仓库了，所以看图，图中下面半部分就是你需要的命令，我们一行一行拷贝过来执行\n 找到图中的「…or push an existing repository from the command line」这一行，你会看到 git remote add origin https://github.com/xxxxxxxxxx/git-demo-1.git， 如果你发现这个地址是 https 开头的，那你就做错了，还记得吗，我们要使用 SSH 地址，GitHub 的 SSH 地址是以 git@github.com 开头的。 再次点击 SSH 按钮，不管我强调多少遍，总会有人忘记点击 SSH 按钮，为什么呢？我也不知道，为了防止你忘了点击 SSH 按钮，我最后再说一遍，「点击 SSH按钮」，点击之后，整个世界就会变得美好起来。 得到新的命令 git remote add origin git@github.com:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx/git-demo-1.git，复制并运行它 复制第二行 git push -u origin master，运行它 刷新当前页面，你的仓库就上传到 GitHub 了！是不是特别简单？只要你按照我说的做，一丝不苟，即可。    如何上传更新 #  你在本地目录有任何变动，只需按照以下顺序就能上传：\n git add 文件路径 git commit -m \u0026ldquo;信息\u0026rdquo; git pull （相信我，你一定会忘记这一个命令） git push  下面是例子\n cd git-demo-1 touch index2.html git add index2.html git commit -m \u0026quot;新建 index2.html\u0026quot; git pull git push  然后你去 git-demo-1 的 GitHub 页面，就能看到 index2.html 出现在里面了。是不是很……简……单……呢……\ngit ignore #  在项目目录创建 .gitignore 文件就可以指定「哪些文件不上传到远程仓库」，比如\n.gitignroe\n/node_modules/\r/.vscode/\r这样就可以避免 node_modules/ 和 .vscode/ 目录被上传到 github 了。\n记住一句话：永远都不要上传 node_modules 到 github。 #  如果你想防止自己手贱上传 node_modules 到 github ，可以：\n 在项目根目录 touch .gitignore 在 .gitignore 里添加一行 /node_modules/ git add .gitignore; git commit -m \u0026lsquo;ignore\u0026rsquo;  直接在 GitHub 创建一个仓库，然后下载到本地 #  上面两步讲了\n 在本地创建仓库 将本地仓库上传到 GitHub  这里将第三种用法，那就是直接在 GitHub 创建一个仓库，然后下载到本地。\n  在GitHub 上新建一个仓库 git-demo-2，这次就不创建空仓库了，而是自带 README 和 Lisence 的仓库，创建截图如下： 请按图中所示，填写一模一样的内容，然后点击创建按钮。\n  这样一来，这个仓库就会自动拥有三个文件：\n   这三个文件的作用请自行了解：.gitignore 的作用、README.md 的作用 以及 LISENCE 的作用\n  好了，现在远程仓库已经创建好了，怎么下载到我们的本地（也就是我们的电脑上）呢？答案是使用 git clone 命令\n  点击页面中唯一的绿色按钮「clone or download」，会看到一个弹出层\n   请确保弹出层里的地址是 SSH 地址，也就是 git@github.com 开头的地址，如果不是，就点击 Use SSH 按钮，就点击 Use SSH 按钮，就点击 Use SSH 按钮。然后复制这个地址。\n  打开 Git Bash，找一个安全的目录，比如 ~/Desktop 桌面目录就很安全：cd ~/Desktop。运行。\n  运行 git clone 你刚才得到的以git@github.com开头的地址，运行完了你就会发现，桌面上多出一个 git-demo-2 目录。我再说一遍，桌面上多出一个 git-demo-2 目录。我再说一遍，桌面上多出一个 git-demo-2 目录。这个细节很重要，很多小白发现不了这个细节，我也不知道他们是眼瞎还是怎么了……\n  进入这个多出来的目录，对的，你肯定会忽略这一步。\n  进入这个多出来的目录，对的，你肯定会忽略这一步。\n  进入这个多出来的目录，对的，你肯定会忽略这一步。\n  好了你进入了这个目录了，如果没有，我就要吐血了，因为我的提示很明显。\n  运行 ls -la 你会看到，远程目录的所有文件都在这里出现了，另外你还看到了 .git 本地仓库。这是你就可以添加文件，git add，然后 git commit 了。\n  三种方式都说完了，它们分别是：\n 在本地创建仓库 将本地仓库上传到 GitHub 下载 GitHub 上的仓库到本地  其实呢，我还可以说很多种不同的方式，但是，你记住这几种就行了，够你用的了。我们并不想要了解 git 的所有高级用法，我们的目的很明确：能通过 Git 命令使用 GitHub 就行。\n我们再回顾一遍已经学到的命令：（这次只多了一个 git clone 命令）\n git clone git@github.com:xxxx，下载仓库 git init，初始化本地仓库 .git git status -sb，显示当前所有文件的状态 git add 文件路径，用来将变动加到暂存区 git commit -m \u0026ldquo;信息\u0026rdquo;，用来正式提交变动，提交至 .git 仓库 如果有新的变动，我们只需要依次执行 git add xxx 和 git commit -m \u0026lsquo;xxx\u0026rsquo; 两个命令即可。别看本教程废话那么多，其实就这一句有用！先 add 再 commit，行了，你学会 git 了。 git log 查看变更历史   本文所有内容均来自 Copyright © 2018 饥人谷版权所有\n "});index.add({'id':75,'href':'/history/action/','title':"Action 官方文档",'content':"Action 官方文档 #  Action 类似于 mutation，不同在于：\n Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。  让我们来注册一个简单的 action：\nconst store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { increment (context) { context.commit(\u0026#39;increment\u0026#39;) } } }) Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。\n实践中，我们会经常用到 ES2015 的 参数解构 来简化代码（特别是我们需要调用 commit 很多次的时候）：\nactions: { increment ({ commit }) { commit(\u0026#39;increment\u0026#39;) } } 分发 Action #  Action 通过 store.dispatch 方法触发：\nstore.dispatch(\u0026#39;increment\u0026#39;) 乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作：\nactions: { incrementAsync ({ commit }) { setTimeout(() =\u0026gt; { commit(\u0026#39;increment\u0026#39;) }, 1000) } } Actions 支持同样的载荷方式和对象方式进行分发：\n// 以载荷形式分发 store.dispatch(\u0026#39;incrementAsync\u0026#39;, { amount: 10 }) // 以对象形式分发 store.dispatch({ type: \u0026#39;incrementAsync\u0026#39;, amount: 10 }) 来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation：\nactions: { checkout ({ commit, state }, products) { // 把当前购物车的物品备份起来  const savedCartItems = [...state.cart.added] // 发出结账请求，然后乐观地清空购物车  commit(types.CHECKOUT_REQUEST) // 购物 API 接受一个成功回调和一个失败回调  shop.buyProducts( products, // 成功操作  () =\u0026gt; commit(types.CHECKOUT_SUCCESS), // 失败操作  () =\u0026gt; commit(types.CHECKOUT_FAILURE, savedCartItems) ) } } 注意我们正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。\n在组件中分发 Action #  你在组件中使用 this.$store.dispatch('xxx') 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：\nimport { mapActions } from \u0026#39;vuex\u0026#39; export default { // ...  methods: { ...mapActions([ \u0026#39;increment\u0026#39;, // 将 `this.increment()` 映射为 `this.$store.dispatch(\u0026#39;increment\u0026#39;)`  // `mapActions` 也支持载荷：  \u0026#39;incrementBy\u0026#39; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(\u0026#39;incrementBy\u0026#39;, amount)`  ]), ...mapActions({ add: \u0026#39;increment\u0026#39; // 将 `this.add()` 映射为 `this.$store.dispatch(\u0026#39;increment\u0026#39;)`  }) } } 组合 Action #  Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？\n首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise：\nactions: { actionA ({ commit }) { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { commit(\u0026#39;someMutation\u0026#39;) resolve() }, 1000) }) } } 现在你可以：\nstore.dispatch(\u0026#39;actionA\u0026#39;).then(() =\u0026gt; { // ... }) 在另外一个 action 中也可以：\nactions: { // ...  actionB ({ dispatch, commit }) { return dispatch(\u0026#39;actionA\u0026#39;).then(() =\u0026gt; { commit(\u0026#39;someOtherMutation\u0026#39;) }) } } 最后，如果我们利用 async / await，我们可以如下组合 action：\n// 假设 getData() 和 getOtherData() 返回的是 Promise  actions: { async actionA ({ commit }) { commit(\u0026#39;gotData\u0026#39;, await getData()) }, async actionB ({ dispatch, commit }) { await dispatch(\u0026#39;actionA\u0026#39;) // 等待 actionA 完成  commit(\u0026#39;gotOtherData\u0026#39;, await getOtherData()) } }  一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。\n "});index.add({'id':76,'href':'/history/axios%E5%85%A5%E9%97%A8/','title':"Axios 入门",'content':"安装 #  npm 安装 #  npm install axios yran 安装 #  yarn add axios CDN 引入 #  \u0026lt;script src=\u0026#34;https://unpkg.com/axios/dist/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  官方文档：GitHub-axios\n 使用 #  get请求\naxios.get(\u0026#39;/user?ID=12345\u0026#39;).then((response)=\u0026gt;{ console.log(response) }).catch((error)=\u0026gt;{ console.log(error) }) 拦截器 #  案例\n在返回 response 之前执行 .use() 中的函数\naxios.interceptors.response.use(function(response){ response.data = { \u0026#39;name\u0026#39;: \u0026#39;frank\u0026#39; } return response }) axios.get(\u0026#39;/books/1\u0026#39;).then((response)=\u0026gt;{ console.log(response) }) 根据请求路由判断\n当请求为 get 请求并且请求的 url 是 '/books/1' 才会返回数据 data 的值\naxios.interceptors.response.use(function(response){ let config = response.config let {method, url, data} = config if(url === \u0026#39;/books/1\u0026#39; \u0026amp;\u0026amp; method === \u0026#39;get\u0026#39;){ response.data = { \u0026#39;name\u0026#39;: \u0026#39;frank\u0026#39; } } return response }) axios.get(\u0026#39;/books/1\u0026#39;).then((response)=\u0026gt;{ console.log(response) }) 虚拟服务器 #  模拟服务器返回数据\n"});index.add({'id':77,'href':'/docs/css-grid-%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B/','title':"CSS Grid 网格布局教程",'content':"CSS Grid 网格布局教程 #  作者： 阮一峰\n日期： 2019年3月25日\n 一、概述 #  网格布局（Grid）是最强大的 CSS 布局方案。\n它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。\n上图这样的布局，就是 Grid 布局的拿手好戏。\nGrid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。\nFlex 布局是轴线布局，只能指定\u0026quot;项目\u0026quot;针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成\u0026quot;行\u0026quot;和\u0026quot;列\u0026rdquo;，产生单元格，然后指定\u0026quot;项目所在\u0026quot;的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。\n二、基本概念 #  学习 Grid 布局之前，需要了解一些基本概念。\n2.1 容器和项目 #  采用网格布局的区域，称为\u0026quot;容器\u0026rdquo;（container）。容器内部采用网格定位的子元素，称为\u0026quot;项目\u0026rdquo;（item）。\n\u0026lt;div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;p\u0026gt;1\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;p\u0026gt;2\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;p\u0026gt;3\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 上面代码中，最外层的元素就是容器，内层的三个元素就是项目。\n注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的``元素就不是项目。Grid 布局只对项目生效。\n2.2 行和列 #  容器里面的水平区域称为\u0026quot;行\u0026rdquo;（row），垂直区域称为\u0026quot;列\u0026rdquo;（column）。\n上图中，水平的深色区域就是\u0026quot;行\u0026rdquo;，垂直的深色区域就是\u0026quot;列\u0026rdquo;。\n2.3 单元格 #  行和列的交叉区域，称为\u0026quot;单元格\u0026rdquo;（cell）。\n正常情况下，n行和m列会产生n x m个单元格。比如，3行3列会产生9个单元格。\n2.4 网格线 #  划分网格的线，称为\u0026quot;网格线\u0026rdquo;（grid line）。水平网格线划分出行，垂直网格线划分出列。\n正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线，比如三行就有四根水平网格线。\n上图是一个 4 x 4 的网格，共有5根水平网格线和5根垂直网格线。\n三、容器属性 #  Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。\n3.1 display 属性 #  display: grid指定一个容器采用网格布局。\ndiv { display: grid; } 上图是display: grid的效果。\n默认情况下，容器元素都是块级元素，但也可以设成行内元素。\ndiv { display: inline-grid; } 上面代码指定div是一个行内元素，该元素内部采用网格布局。\n上图是display: inline-grid的效果。\n 注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。\n 3.2 grid-template-columns 属性， grid-template-rows 属性 #  容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。\n.container { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; } 上面代码指定了一个三行三列的网格，列宽和行高都是100px。\n除了使用绝对单位，也可以使用百分比。\n.container { display: grid; grid-template-columns: 33.33% 33.33% 33.33%; grid-template-rows: 33.33% 33.33% 33.33%; } （1）repeat()\n有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用repeat()函数，简化重复的值。上面的代码用repeat()改写如下。\n.container { display: grid; grid-template-columns: repeat(3, 33.33%); grid-template-rows: repeat(3, 33.33%); } repeat()接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。\nrepeat()重复某种模式也是可以的。\ngrid-template-columns: repeat(2, 100px 20px 80px); 上面代码定义了6列，第一列和第四列的宽度为100px，第二列和第五列为20px，第三列和第六列为80px。\n（2）auto-fill 关键字\n有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。\n.container { display: grid; grid-template-columns: repeat(auto-fill, 100px); } 上面代码表示每列宽度100px，然后自动填充，直到容器不能放置更多的列。\n（3）fr 关键字\n为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为\u0026quot;片段\u0026rdquo;）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。\n.container { display: grid; grid-template-columns: 1fr 1fr; } 上面代码表示两个相同宽度的列。\nfr可以与绝对长度的单位结合使用，这时会非常方便。\n.container { display: grid; grid-template-columns: 150px 1fr 2fr; } 上面代码表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。\n（4）minmax()\nminmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。\ngrid-template-columns: 1fr 1fr minmax(100px, 1fr); 上面代码中，minmax(100px, 1fr)表示列宽不小于100px，不大于1fr。\n（5）auto 关键字\nauto关键字表示由浏览器自己决定长度。\ngrid-template-columns: 100px auto 100px; 上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度。\n（6）网格线的名称\ngrid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。\n.container { display: grid; grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4]; grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4]; } 上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。\n网格布局允许同一根线有多个名字，比如[fifth-line row-5]。\n（7）布局实例\ngrid-template-columns属性对于网页布局非常有用。两栏式布局只需要一行代码。\n.wrapper { display: grid; grid-template-columns: 70% 30%; } 上面代码将左边栏设为70%，右边栏设为30%。\n传统的十二网格布局，写起来也很容易。\ngrid-template-columns: repeat(12, 1fr); 3.3 grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性 #  grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。\n.container { grid-row-gap: 20px; grid-column-gap: 20px; } 上面代码中，grid-row-gap用于设置行间距，grid-column-gap用于设置列间距。\ngrid-gap属性是grid-column-gap和grid-row-gap的合并简写形式，语法如下。\ngrid-gap: \u0026lt;grid-row-gap\u0026gt; \u0026lt;grid-column-gap\u0026gt;; 因此，上面一段 CSS 代码等同于下面的代码。\n.container { grid-gap: 20px 20px; } 如果grid-gap省略了第二个值，浏览器认为第二个值等于第一个值。\n 根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。\n 3.4 grid-template-areas 属性 #  网格布局允许指定\u0026quot;区域\u0026rdquo;（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。\n.container { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-template-areas: \u0026#39;a b c\u0026#39; \u0026#39;d e f\u0026#39; \u0026#39;g h i\u0026#39;; } 上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。\n多个单元格合并成一个区域的写法如下。\ngrid-template-areas: \u0026#39;a a a\u0026#39; \u0026#39;b b b\u0026#39; \u0026#39;c c c\u0026#39;; 上面代码将9个单元格分成a、b、c三个区域。\n下面是一个布局实例。\ngrid-template-areas: \u0026#34;header header header\u0026#34; \u0026#34;main main sidebar\u0026#34; \u0026#34;footer footer footer\u0026#34;; 上面代码中，顶部是页眉区域header，底部是页脚区域footer，中间部分则为main和sidebar。\n如果某些区域不需要利用，则使用\u0026quot;点\u0026rdquo;（.）表示。\ngrid-template-areas: \u0026#39;a . c\u0026#39; \u0026#39;d . f\u0026#39; \u0026#39;g . i\u0026#39;; 上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。\n 注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。\n比如，区域名为header，则起始位置的水平网格线和垂直网格线叫做header-start，终止位置的水平网格线和垂直网格线叫做header-end。\n 3.5 grid-auto-flow 属性 #  划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是\u0026quot;先行后列\u0026rdquo;，即先填满第一行，再开始放入第二行，即下图数字的顺序。\n这个顺序由grid-auto-flow属性决定，默认值是row，即\u0026quot;先行后列\u0026rdquo;。也可以将它设成column，变成\u0026quot;先列后行\u0026rdquo;。\ngrid-auto-flow: column; 上面代码设置了column以后，放置顺序就变成了下图。\ngrid-auto-flow属性除了设置成row和column，还可以设成row dense和column dense。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。\n下面的例子让1号项目和2号项目各占据两个单元格，然后在默认的grid-auto-flow: row情况下，会产生下面这样的布局。\n上图中，1号项目后面的位置是空的，这是因为3号项目默认跟着2号项目，所以会排在2号项目后面。\n现在修改设置，设为row dense，表示\u0026quot;先行后列\u0026rdquo;，并且尽可能紧密填满，尽量不出现空格。\ngrid-auto-flow: row dense; 上面代码的效果如下。\n上图会先填满第一行，再填满第二行，所以3号项目就会紧跟在1号项目的后面。8号项目和9号项目就会排到第四行。\n如果将设置改为column dense，表示\u0026quot;先列后行\u0026rdquo;，并且尽量填满空格。\ngrid-auto-flow: column dense; 上面代码的效果如下。\n上图会先填满第一列，再填满第2列，所以3号项目在第一列，4号项目在第二列。8号项目和9号项目被挤到了第四列。\n3.6 justify-items 属性， align-items 属性， place-items 属性 #  justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。\n.container { justify-items: start | end | center | stretch; align-items: start | end | center | stretch; } 这两个属性的写法完全相同，都可以取下面这些值。\n start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。  .container { justify-items: start; } 上面代码表示，单元格的内容左对齐，效果如下图。\n.container { align-items: start; } 上面代码表示，单元格的内容头部对齐，效果如下图。\nplace-items属性是align-items属性和justify-items属性的合并简写形式。\nplace-items: \u0026lt;align-items\u0026gt; \u0026lt;justify-items\u0026gt;; 下面是一个例子。\nplace-items: start end; 如果省略第二个值，则浏览器认为与第一个值相等。\n3.7 justify-content 属性， align-content 属性， place-content 属性 #  justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。\n.container { justify-content: start | end | center | stretch | space-around | space-between | space-evenly; align-content: start | end | center | stretch | space-around | space-between | space-evenly; } 这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以justify-content属性为例，align-content属性的图完全一样，只是将水平方向改成垂直方向。）\n start - 对齐容器的起始边框。   end - 对齐容器的结束边框。   center - 容器内部居中。   stretch - 项目大小没有指定时，拉伸占据整个网格容器。   space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。   space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。   space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。  place-content属性是align-content属性和justify-content属性的合并简写形式。\nplace-content: \u0026lt;align-content\u0026gt; \u0026lt;justify-content\u0026gt; 下面是一个例子。\nplace-content: space-around space-evenly; 如果省略第二个值，浏览器就会假定第二个值等于第一个值。\n3.8 grid-auto-columns 属性， grid-auto-rows 属性 #  有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。\ngrid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。\n下面的例子里面，划分好的网格是3行 x 3列，但是，8号项目指定在第4行，9号项目指定在第5行。\n.container { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-auto-rows: 50px; } 上面代码指定新增的行高统一为50px（原始的行高为100px）。\n3.9 grid-template 属性， grid 属性 #  grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。\ngrid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。\n从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。\n四、项目属性 #  下面这些属性定义在项目上面。\n4.1 grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性 #  项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。\n grid-column-start属性：左边框所在的垂直网格线 grid-column-end属性：右边框所在的垂直网格线 grid-row-start属性：上边框所在的水平网格线 grid-row-end属性：下边框所在的水平网格线  .item-1 { grid-column-start: 2; grid-column-end: 4; } 上面代码指定，1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。\n上图中，只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。\n除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的grid-auto-flow属性决定，这个属性的默认值是row，因此会\u0026quot;先行后列\u0026quot;进行排列。读者可以把这个属性的值分别改成column、row dense和column dense，看看其他项目的位置发生了怎样的变化。\n下面的例子是指定四个边框位置的效果。\n.item-1 { grid-column-start: 1; grid-column-end: 3; grid-row-start: 2; grid-row-end: 4; } 这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。\n.item-1 { grid-column-start: header-start; grid-column-end: header-end; } 上面代码中，左边框和右边框的位置，都指定为网格线的名字。\n这四个属性的值还可以使用span关键字，表示\u0026quot;跨越\u0026rdquo;，即左右边框（上下边框）之间跨越多少个网格。\n.item-1 { grid-column-start: span 2; } 上面代码表示，1号项目的左边框距离右边框跨越2个网格。\n这与下面的代码效果完全一样。\n.item-1 { grid-column-end: span 2; } 使用这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序。\n4.2 grid-column 属性， grid-row 属性 #  grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。\n.item { grid-column: / ; grid-row: / ; } 下面是一个例子。\n.item-1 { grid-column: 1 / 3; grid-row: 1 / 2; } /* 等同于 */ .item-1 { grid-column-start: 1; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2; } 上面代码中，项目item-1占据第一行，从第一根列线到第三根列线。\n这两个属性之中，也可以使用span关键字，表示跨越多少个网格。\n.item-1 { background: #b03532; grid-column: 1 / 3; grid-row: 1 / 3; } /* 等同于 */ .item-1 { background: #b03532; grid-column: 1 / span 2; grid-row: 1 / span 2; } 上面代码中，项目item-1占据的区域，包括第一行 + 第二行、第一列 + 第二列。\n斜杠以及后面的部分可以省略，默认跨越一个网格。\n.item-1 { grid-column: 1; grid-row: 1; } 上面代码中，项目item-1占据左上角第一个网格。\n4.3 grid-area 属性 #  grid-area属性指定项目放在哪一个区域。\n.item-1 { grid-area: e; } 上面代码中，1号项目位于e区域，效果如下图。\ngrid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。\n.item { grid-area: \u0026lt;row-start\u0026gt; / \u0026lt;column-start\u0026gt; / \u0026lt;row-end\u0026gt; / \u0026lt;column-end\u0026gt;; } 下面是一个例子。\n.item-1 { grid-area: 1 / 1 / 3 / 3; } 4.4 justify-self 属性， align-self 属性， place-self 属性 #  justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。\nalign-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。\n.item { justify-self: start | end | center | stretch; align-self: start | end | center | stretch; } 这两个属性都可以取下面四个值。\n start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。  下面是justify-self: start的例子。\n.item-1 { justify-self: start; } place-self属性是align-self属性和justify-self属性的合并简写形式。\nplace-self: \u0026lt;align-self\u0026gt; \u0026lt;justify-self\u0026gt;; 下面是一个例子。\nplace-self: center center; 如果省略第二个值，place-self属性会认为这两个值相等。\n五、参考链接 #   A Complete Guide to Grid, by Chris House Understanding the CSS Grid Layout Module, by Ian Yates How to Build an Off-Canvas Navigation With CSS Grid, Ian Yates Introduction to the CSS Grid Layout With Examples, Dogacan Bilgili Learn CSS Grid, Jonathan Suh How I stopped using Bootstrap\u0026rsquo;s layout thanks to CSS Grid, Cédric Kui  （完）\n  本文内容转载自：http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html\n "});index.add({'id':78,'href':'/docs/es6-%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%97%E8%A1%A8/','title':"ES 6 新特性列表",'content':"ES 6 新特性列表 #  由 饥人谷 搜集整理。点击链接，查看中文学习资料。\n 作用域  块级作用域 块级变量 let 块级常量 const   箭头函数  sum = (a, b) =\u0026gt; a + b nums.forEach( v =\u0026gt; { console.log(v) }) 词法 this   参数处理  默认参数值 剩余参数 展开运算符   模板字面量  多行字符串 字符串插值 带标签的模板字面量 原始字符串   原有字面量加强  更安全的二进制字面量（0b1111101） 更安全的八进制字面量（0o767） 字符串支持 Unicode  String.fromCodePoint String.prototype.codePointAt   正则表达式字面量添加 Unicode 支持（u 标记） 正则表达式添加 y 标记，支持粘滞匹配   对象属性加强  属性定义支持短语法 obj = { x, y } 属性名支持表达式 obj = {[\u0026quot;baz\u0026quot; + quux() ]: 42} 添加 __proto__ 属性，但不建议使用   解构赋值  数组匹配 [ b, a ] = [ a, b ] 对象匹配 let { a, b, c } = objABC 参数匹配 function g ({ name: n, val: v }) {}   模块  导入（import） 导出（export） 默认导出（export default）   类  使用 extends 实现继承 重写构造器 super 关键字   迭代  迭代器 for of   生成器 Promise 元编程  代理（Proxy） 反射（Reflect）   新增数据类型  Symbol 类型 Set 类型 Map 类型 WeakSet 类型 WeakMap 类型 TypedArray 类型   原有内置对象 API 增强  Object.assign Array.from Array.of Array.prototype.fill Array.prototype.find Array.prototype.findIndex Array.prototype.copyWithin Array.prototype.entries Array.prototype.keys Array.prototype.values String.prototype.includes String.prototype.repeat String.prototype.startsWith String.prototype.endsWith Number.EPSILON Number.isInteger Number.isSafeInteger Number.isFinite Number.isNaN(‘NaN’) // false Math.acosh Math.hypot Math.imul Math.sign Math.trunc   尾递归优化    本文转载自：饥人谷 - ES 6 新特性列表\n "});index.add({'id':79,'href':'/history/js%E4%B8%AD%E7%9A%84symbol%E6%98%AF%E4%BB%80%E4%B9%88/','title':"JS 中的 Symbol 是什么？",'content':"JS 中的 Symbol 是什么？ #  ES 6 引入了一个新的数据类型 Symbol，它是用来做什么的呢？\n为了说明 Symbol 的作用，我们先来描述一个使用场景。\n我们在做一个游戏程序，用户需要选择角色的种族。\nvar race = { protoss: \u0026#39;protoss\u0026#39;, // 神族  terran: \u0026#39;terran\u0026#39;, // 人族  zerg: \u0026#39;zerg\u0026#39; // 虫族 } function createRole(type){ if(type === race.protoss){创建神族角色} else if(type === race.terran){创建人族角色} else if(type === race.zerg){创建虫族角色} } 那么用户选择种族后，就需要调用 createRole 来创建角色：\n// 传入字符串 createRole(\u0026#39;zerg\u0026#39;) // 或者传入变量 createRole(race.zerg) 一般传入字符串被认为是不好的做法，所以使用 createRole(race.zerg) 的更多。\n如果使用 createRole(race.zerg)，那么聪明的读者会发现一个问题：race.protoss、race.terran、race.zerg 的值为多少并不重要。\n改为如下写法，对 createRole(race.zerg) 毫无影响：\nvar race = { protoss: \u0026#39;askdjaslkfjas;lfkjas;flkj\u0026#39;, // 神族  terran: \u0026#39;;lkfalksjfl;askjfsfal;skfj\u0026#39;, // 人族  zerg: \u0026#39;qwieqwoirqwoiruoiwqoisrqwroiu\u0026#39; // 虫族 } 也就是说：\nrace.zerg 的值是多少无所谓，只要它的值跟 race.protoss 和 race.terran 的值不一样就行。\nSymbol 的用途就是如此：Symbol 可以创建一个独一无二的值（但并不是字符串）。\n用 Symbol 来改写上面的 race：\nvar race = { protoss: Symbol(), terran: Symbol(), zerg: Symbol() } race.protoss !== race.terran // true race.protoss !== race.zerg // true 你也可以给每个 Symbol 起一个名字：\nvar race = { protoss: Symbol(\u0026#39;protoss\u0026#39;), terran: Symbol(\u0026#39;terran\u0026#39;), zerg: Symbol(\u0026#39;zerg\u0026#39;) } 不过这个名字跟 Symbol 的值并没有关系，你可以认为这个名字就是个注释。如下代码可以证明 Symbol 的名字与值无关：\nvar a1 = Symbol(\u0026#39;a\u0026#39;) var a2 = Symbol(\u0026#39;a\u0026#39;) a1 !== a2 // true 如果你觉得我说得还是太复杂了，看不懂，你可以记一句话：\nSymbol 生成一个全局唯一的值。\n 以上，就是 Symbol 的简述，更详细更权威的知识参考下面的自学链接。\n自学链接：\nMDN： Symbol - JavaScript\n阮一峰：ECMAScript 6入门\n  本文转自：https://zhuanlan.zhihu.com/p/22652486?refer=study-fe\n "});index.add({'id':80,'href':'/history/json%E6%98%AF%E4%BB%80%E4%B9%88/','title':"JSON 是什么？",'content':"JSON 是什么？ #  （本文精髓在最后一节）\nJSON 绝对不是对象，请问\n JSON 是什么？ \u0026ldquo;null\u0026rdquo; 是 JSON 吗？\u0026ldquo;1\u0026rdquo; 是 JSON 吗？ JSON 与 JS 对象的区别是什么？  JSON 是什么？ #  如果你在 Google 搜索 JSON，那么一眼就会看到 JSON 的官网 http://json.org。\n官网会明明白白的告诉你，JSON 是一种数据格式。\n什么是格式？你可以理解为语法。JSON 的格式灵感来自于 JS 对象字面量的语法，但是两者没有任何关联。\n这种格式可以描述三种数据。\n1. object（无序的「键-值」集合）。\n语法如下：\n这个图叫做语法图，你可以讲其想象成铁轨，有一列火车从左往右行驶。\n这列火车遇到的第一个符号是 { ，所以对象语法的第一个符号也必须是 { 。\n如果继续直行，会分别遇到 string、冒号和 value，所以对应的文本内容是 { string: value 。\n然后你可以选择直行或者往下拐，最后到达终点。\n把旅途中遇到的所有符号连起来，就是完整的语法。\n比如下面三种写法都可以表示 object\n{} {\u0026#34;key1\u0026#34;: \u0026#34;value1\u0026#34;} // string 对应 \u0026#34;key1\u0026#34;，value 对应 \u0026#34;value1\u0026#34;，后面会讲 {\u0026#34;key1\u0026#34;: \u0026#34;value1\u0026#34;, \u0026#34;key2\u0026#34;: \u0026#34;value2\u0026#34;} 2. array（有序的值集合）\n语法如下：\n下面三种写法都可以表示 array\n[] [1] [1,\u0026#34;hi\u0026#34;] 3. value\nvalue 对应对象语法图里的 value 和数组语法图里 value，value 也可以是 object 或 array，所以下面的语法成立：\n{\u0026#34;key1\u0026#34;: { \u0026#34;key2\u0026#34; : \u0026#34;value2\u0026#34; } } [ 1, [ 2, 3 ] ] 另外值还可以是 string、number、true、false 和 null。\nstring 的语法如下：\n你可能奇怪为什么 string 的语法这么复杂，我举例来说明你就明白了：\n\u0026#34;你好\u0026#34; \u0026#34;\\\u0026#34;你好\\\u0026#34;\u0026#34; \u0026#34;\\\\你好\\\\\u0026#34; \u0026#34;\\/你好\\/\u0026#34; \u0026#34;\\b\\f\\n\\r\\t特殊符号\u0026#34; \u0026#34;\\u4f60用编码表示字符\u0026#34; 上面都是合法的 string。这也是「JSON 中字符串必须使用双引号」的原因——规定如此。\nnumber 的语法如下，有兴趣可以自己走一遍：\n另外需要特殊提醒一下，true、false 和 null 都是合法的 JSON。\nJSON 和 JS Object 的区别 #  简单来说，两种没有任何关联。\nJSON 语法的作者是道格拉斯（Douglas Crockford），JS 语法的作者是布兰登・艾奇（Brendan Eich）。道格拉斯发明 JSON 的时候参考了 JS 的对象语法，仅此而已。\n如果硬要说区别：\n\\1. JSON 的字符串必须用双引号。\n\\2. JSON 无法表示 undefined，只能表示 \u0026ldquo;undefined\u0026rdquo;\n\\3. JSON 无法表示函数\n\\4. JSON 的对象语法不能有引用\n以上，就是对 JSON 的详细介绍。\n欢迎进群与我探讨技术，暗号：前端/Java交流（附二维码）http://qr.jirengu.com/api/taskUrl?tid=56\n编辑于 2019-07-17\n  本文转自：https://zhuanlan.zhihu.com/p/22627657?refer=study-fe\n "});index.add({'id':81,'href':'/history/2019-11-12-module%E8%AF%AD%E6%B3%95/','title':"Module语法",'content':"历史 #  由于 JavaScript 一直没有模块(module)体系，无法将一个文件拆分成一个相互依赖的多个小文件，再用简单的方法拼装在一起。其他语言都有这样的功能。 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上实现了模块功能，并且相当简单，取代了之前的方案。\n静态加载 #   运行时加载：只有在运行时才会加载，缺点：无法在编译时做“静态优化” 静态加载(ES6)：也称“编译时加载”，在编译时就加载模块，缺点：无法引用模块本身  案例 #  运行时加载 整体加载 fs 模块(即加载 fs 的所有方法)，生成一个对象，然后再从这个对象上面读取 3 个方法。这种加载就是 “运行时加载”，因为只有在运行时才能得到这个对象，导致无法在编译时做“静态优化”\n// CommonJS模块 let { stat, exists, readFile } = require(\u0026#39;fs\u0026#39;); // 相当于 let _fs = require(\u0026#39;fs\u0026#39;) let stat = _fs.stat; let exists = _fs.exists; let readfile = _fs.readfile; 静态加载 ES6语法可以从 fs 模块加载 3 个方法，其他方法不加载。这种方法就叫做静态加载，\nimport { stat, exists, readFile } from \u0026#39;fs\u0026#39;; 严格模式 #  ES6 的模块自动采用严格模式\nexport 使用 #  模块功能主要有两个命令组成：export 和 import 。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法读取。如果你希望外部能够读取模块内部的某个变量，就必须使用 export 关键字输出该变量。下面是一个 JS 文件里使用 export 命令输出变量\nexport var firstName = \u0026#39;Michael\u0026#39;; export var lastName = \u0026#39;Jackson\u0026#39;; export var year = \u0026#39;1997\u0026#39;; 上面代码是 profile.js 文件，保存了用户信息。ES6 将其视为一个模块，里面用 export 命令对外部输出了三个变量。\nexport 的写法，除了像上面这样，还可以这样\nvar firstName = \u0026#39;Michael\u0026#39;; var lastName = \u0026#39;Jackson\u0026#39;; var year = 1997; export { firstName, lastName, year }; export default #  export 有两种不同的导出方式，命名导出和默认导出。你能够在每一个模块中定义多个命名导出，但是只允许有一个默认导出。\n命名导出： // 导出早前定义的函数 export { myFunction }; // 导出常量 export const foo = Math.sqrt(2); 默认导出（函数）：\nexport default function() {} 默认导出（类）：\nexport default class {} 为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。\n// export-default.js export default function () { console.log(\u0026#39;foo\u0026#39;); } 上面代码是一个模块文件 export-default.js，它的默认输出是一个函数。\n其他模块加载该模块时，import 命令可以为该匿名函数指定任意名字。\n// import-default.js import customName from \u0026#39;./export-default\u0026#39;; customName(); // \u0026#39;foo\u0026#39; 上面代码的import命令，可以用任意名称指向export-default.js输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时import命令后面，不使用大括号。\nexport default命令用在非匿名函数前，也是可以的。\n// export-default.js export default function foo() { console.log(\u0026#39;foo\u0026#39;); } // 或者写成 function foo() { console.log(\u0026#39;foo\u0026#39;); } export default foo; 上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。\n本文摘自\nMDN文档 - export\nES6 入门 - export default 命令\n"});index.add({'id':82,'href':'/docs/unicode%E4%B8%8Ejavascript%E8%AF%A6%E8%A7%A3/','title':"Unicode与JavaScript详解",'content':"分享按钮\n作者： 阮一峰\n日期： 2014年12月11日\n 上个月，我做了一次分享，详细介绍了Unicode字符集，以及JavaScript语言对它的支持。下面就是这次分享的讲稿。\n一、Unicode是什么？ #  Unicode源于一个很简单的想法：将全世界所有的字符包含在一个集合里，计算机只要支持这一个字符集，就能显示所有的字符，再也不会有乱码了。\n**它从0开始，为每个符号指定一个编号，这叫做\u0026quot;码点\u0026rdquo;（code point）。**比如，码点0的符号就是null（表示所有二进制位都是0）。\nU+0000 = null 上式中，U+表示紧跟在后面的十六进制数是Unicode的码点。\n目前，Unicode的最新版本是7.0版，一共收入了109449个符号，其中的中日韩文字为74500个。可以近似认为，全世界现有的符号当中，三分之二以上来自东亚文字。比如，中文\u0026quot;好\u0026quot;的码点是十六进制的597D。\nU+597D = 好 这么多符号，Unicode不是一次性定义的，而是分区定义。每个区可以存放65536个（216）字符，称为一个平面（plane）。目前，一共有17个（25）平面，也就是说，整个Unicode字符集的大小现在是221。\n最前面的65536个字符位，称为基本平面（缩写BMP），它的码点范围是从0一直到216-1，写成16进制就是从U+0000到U+FFFF。所有最常见的字符都放在这个平面，这是Unicode最先定义和公布的一个平面。\n剩下的字符都放在辅助平面（缩写SMP），码点范围从U+010000一直到U+10FFFF。\n二、UTF-32与UTF-8 #  Unicode只规定了每个字符的码点，到底用什么样的字节序表示这个码点，就涉及到编码方法。\n**最直观的编码方法是，每个码点使用四个字节表示，字节内容一一对应码点。这种编码方法就叫做UTF-32。**比如，码点0就用四个字节的0表示，码点597D就在前面加两个字节的0。\nU+0000 = 0x0000 0000 U+597D = 0x0000 597D UTF-32的优点在于，转换规则简单直观，查找效率高。缺点在于浪费空间，同样内容的英语文本，它会比ASCII编码大四倍。这个缺点很致命，导致实际上没有人使用这种编码方法，HTML 5标准就明文规定，网页不得编码成UTF-32。\n人们真正需要的是一种节省空间的编码方法，这导致了UTF-8的诞生。**UTF-8是一种变长的编码方法，字符长度从1个字节到4个字节不等。**越是常用的字符，字节越短，最前面的128个字符，只使用1个字节表示，与ASCII码完全相同。\n   编号范围 字节     0x0000 - 0x007F 1   0x0080 - 0x07FF 2   0x0800 - 0xFFFF 3   0x010000 - 0x10FFFF 4    由于UTF-8这种节省空间的特性，导致它成为互联网上最常见的网页编码。不过，它跟今天的主题关系不大，我就不深入了，具体的转码方法，可以参考我多年前写的《字符编码笔记》。\n三、UTF-16简介 #  UTF-16编码介于UTF-32与UTF-8之间，同时结合了定长和变长两种编码方法的特点。\n它的编码规则很简单：基本平面的字符占用2个字节，辅助平面的字符占用4个字节。也就是说，UTF-16的编码长度要么是2个字节（U+0000到U+FFFF），要么是4个字节（U+010000到U+10FFFF）。\n于是就有一个问题，当我们遇到两个字节，怎么看出它本身是一个字符，还是需要跟其他两个字节放在一起解读？\n说来很巧妙，我也不知道是不是故意的设计，在基本平面内，从U+D800到U+DFFF是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。\n具体来说，辅助平面的字符位共有220个，也就是说，对应这些字符至少需要20个二进制位。UTF-16将这20位拆成两半，前10位映射在U+D800到U+DBFF（空间大小210），称为高位（H），后10位映射在U+DC00到U+DFFF（空间大小210），称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。\n所以，当我们遇到两个字节，发现它的码点在U+D800到U+DBFF之间，就可以断定，紧跟在后面的两个字节的码点，应该在U+DC00到U+DFFF之间，这四个字节必须放在一起解读。\n四、UTF-16的转码公式 #  Unicode码点转成UTF-16的时候，首先区分这是基本平面字符，还是辅助平面字符。如果是前者，直接将码点转为对应的十六进制形式，长度为两字节。\nU+597D = 0x597D 如果是辅助平面字符，Unicode 3.0版给出了转码公式。\nH = Math.floor((c-0x10000) / 0x400)+0xD800 L = (c - 0x10000) % 0x400 + 0xDC00 以字符为例，它是一个辅助平面字符，码点为U+1D306，将其转为UTF-16的计算过程如下。\nH = Math.floor((0x1D306-0x10000)/0x400)+0xD800 = 0xD834 L = (0x1D306-0x10000) % 0x400+0xDC00 = 0xDF06 所以，字符的UTF-16编码就是0xD834 DF06，长度为四个字节。\n五、JavaScript使用哪一种编码？ #  JavaScript语言采用Unicode字符集，但是只支持一种编码方法。\n这种编码既不是UTF-16，也不是UTF-8，更不是UTF-32。上面那些编码方法，JavaScript都不用。\nJavaScript用的是UCS-2！\n六、UCS-2编码 #  怎么突然杀出一个UCS-2？这就需要讲一点历史。\n互联网还没出现的年代，曾经有两个团队，不约而同想搞统一字符集。一个是1988年成立的Unicode团队，另一个是1989年成立的UCS团队。等到他们发现了对方的存在，很快就达成一致：世界上不需要两套统一字符集。\n1991年10月，两个团队决定合并字符集。也就是说，从今以后只发布一套字符集，就是Unicode，并且修订此前发布的字符集，UCS的码点将与Unicode完全一致。\nUCS的开发进度快于Unicode，1990年就公布了第一套编码方法UCS-2，使用2个字节表示已经有码点的字符。（那个时候只有一个平面，就是基本平面，所以2个字节就够用了。）UTF-16编码迟至1996年7月才公布，明确宣布是UCS-2的超集，即基本平面字符沿用UCS-2编码，辅助平面字符定义了4个字节的表示方法。\n**两者的关系简单说，就是UTF-16取代了UCS-2，或者说UCS-2整合进了UTF-16。**所以，现在只有UTF-16，没有UCS-2。\n七、JavaScript的诞生背景 #  那么，为什么JavaScript不选择更高级的UTF-16，而用了已经被淘汰的UCS-2呢？\n答案很简单：非不想也，是不能也。因为在JavaScript语言出现的时候，还没有UTF-16编码。\n1995年5月，Brendan Eich用了10天设计了JavaScript语言；10月，第一个解释引擎问世；次年11月，Netscape正式向ECMA提交语言标准（整个过程详见《JavaScript诞生记》）。对比UTF-16的发布时间（1996年7月），就会明白Netscape公司那时没有其他选择，只有UCS-2一种编码方法可用！\n八、JavaScript字符函数的局限 #  **由于JavaScript只能处理UCS-2编码，造成所有字符在这门语言中都是2个字节，如果是4个字节的字符，会当作两个双字节的字符处理。**JavaScript的字符函数都受到这一点的影响，无法返回正确结果。\n还是以字符为例，它的UTF-16编码是4个字节的0xD834 DF06。问题就来了，4个字节的编码不属于UCS-2，JavaScript不认识，只会把它看作单独的两个字符U+D834和U+DF06。前面说过，这两个码点是空的，所以JavaScript会认为是两个空字符组成的字符串！\n上面代码表示，JavaScript认为字符的长度是2，取到的第一个字符是空字符，取到的第一个字符的码点是0xDB34。这些结果都不正确！\n解决这个问题，必须对码点做一个判断，然后手动调整。下面是正确的遍历字符串的写法。\nwhile (++index \u0026lt; length) { // ...  if (charCode \u0026gt;= 0xD800 \u0026amp;\u0026amp; charCode \u0026lt;= 0xDBFF) { output.push(character + string.charAt(++index)); } else { output.push(character); } } 上面代码表示，遍历字符串的时候，必须对码点做一个判断，只要落在0xD800到0xDBFF的区间，就要连同后面2个字节一起读取。\n类似的问题存在于所有的JavaScript字符操作函数。\n  String.prototype.replace() String.prototype.substring() String.prototype.slice() \u0026hellip;   上面的函数都只对2字节的码点有效。要正确处理4字节的码点，就必须逐一部署自己的版本，判断一下当前字符的码点范围。\n九、ECMAScript 6 #  JavaScript的下一个版本ECMAScript 6（简称ES6），大幅增强了Unicode支持，基本上解决了这个问题。\n（1）正确识别字符\nES6可以自动识别4字节的码点。因此，遍历字符串就简单多了。\nfor (let s of string ) { // ... } 但是，为了保持兼容，length属性还是原来的行为方式。为了得到字符串的正确长度，可以用下面的方式。\nArray.from(string).length （2）码点表示法\nJavaScript允许直接用码点表示Unicode字符，写法是\u0026quot;反斜杠+u+码点\u0026rdquo;。\n\u0026#39;好\u0026#39; === \u0026#39;\\u597D\u0026#39; // true 但是，这种表示法对4字节的码点无效。ES6修正了这个问题，只要将码点放在大括号内，就能正确识别。\n（3）字符串处理函数\nES6新增了几个专门处理4字节码点的函数。\n  String.fromCodePoint()：从Unicode码点返回对应字符 String.prototype.codePointAt()：从字符返回对应的码点 String.prototype.at()：返回字符串给定位置的字符   （4）正则表达式\nES6提供了u修饰符，对正则表达式添加4字节码点的支持。\n（5）Unicode正规化\n有些字符除了字母以外，还有附加符号。比如，汉语拼音的Ǒ，字母上面的声调就是附加符号。对于许多欧洲语言来说，声调符号是非常重要的。\nUnicode提供了两种表示方法。一种是带附加符号的单个字符，即一个码点表示一个字符，比如Ǒ的码点是U+01D1；另一种是将附加符号单独作为一个码点，与主体字符复合显示，即两个码点表示一个字符，比如Ǒ可以写成O（U+004F） + ˇ（U+030C）。\n// 方法一 \u0026#39;\\u01D1\u0026#39; // \u0026#39;Ǒ\u0026#39;  // 方法二 \u0026#39;\\u004F\\u030C\u0026#39; // \u0026#39;Ǒ\u0026#39; 这两种表示方法，视觉和语义都完全一样，理应作为等同情况处理。但是，JavaScript无法辨别。\n\u0026#39;\\u01D1\u0026#39;===\u0026#39;\\u004F\\u030C\u0026#39; //false ES6提供了normalize方法，允许\u0026ldquo;Unicode正规化\u0026rdquo;，即将两种方法转为同样的序列。\n\u0026#39;\\u01D1\u0026#39;.normalize() === \u0026#39;\\u004F\\u030C\u0026#39;.normalize() // true 关于ES6的更多介绍，请看《ECMAScript 6入门》。\n==========================\n我的讲稿就是上面这些内容，当天的PPT请看这里。\n（完）\n文档信息 #   版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证） 发表日期： 2014年12月11日    本文转自：http://www.ruanyifeng.com/blog/2014/12/unicodejavascript.html\n "});index.add({'id':83,'href':'/history/vue-%E7%82%B9%E5%87%BB%E7%A9%BA%E7%99%BD%E5%85%B3%E9%97%AD%E6%B5%AE%E5%B1%82/','title':"Vue 点击空白关闭浮层",'content':"案例\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-if=\u0026#34;open\u0026#34; @click.stop\u0026gt; 显示的浮层 \u0026lt;/p\u0026gt; \u0026lt;button @click.stop=\u0026#34;autoFloat\u0026#34;\u0026gt;开/关\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data () { return { open: false } }, methods: { autoFloat () { this.open = !this.open }, closeFloat () { this.open = false } }, mounted () { document.addEventListener(\u0026#39;click\u0026#39;, this.closeFloat) }, destroyed () { document.removeEventListener(\u0026#39;click\u0026#39;, this.closeFloat) } } \u0026lt;/script\u0026gt; "});index.add({'id':84,'href':'/history/vue-cli%E4%BD%BF%E7%94%A8/','title':"Vue-cli 使用",'content':"Vue 命令行入门项目之 - 井字棋\n创建 #  首先打开命令行工具，安装 Vue\n可以使用下列任一命令安装这个新的包 ( 推荐使用 yarn 安装 )：\nnpm install -g @vue/cli # 或 yarn global add @vue/cli 更新 yarn 的 vue-cli\nyarn global add @vue/cli 安装后，可以用这个命令来检查其版本是否正确：\nvue --version 创建一个当前项目的目录，进入这个目录\n运行以下命令来创建一个新项目：\nvue create . # 表示在当前目录下创建 vue create hello-world # 表示创建在一个指定目录下 运行后会出现以下问题\nVue CLI v4.0.4 # 是否要在当前目录创建这个项目，输入 y/n 选择，此次选择默认Y ? Generate project in current directory? (Y/n) # 选择使用的默认配置，此处选择第二个，方向键上下切换，回车选择 ? Please pick a preset: (Use arrow keys) \u0026gt; default (babel, eslint) Manually select features # 自定义选择所需要的功能，空格选中/取消，方向键切换，回车确认,此次只选中 Babel 即可 ? Check the features needed for your project: (Press \u0026lt;space\u0026gt; to select, \u0026lt;a\u0026gt; to toggle all, \u0026lt;i\u0026gt; to invert selection) \u0026gt;(*) Babel ( ) TypeScript ( ) Progressive Web App (PWA) Support ( ) Router ( ) Vuex ( ) CSS Pre-processors (*) Linter / Formatter ( ) Unit Testing ( ) E2E Testing # 选择配置分开存放或所有配置都存放在 package.json 中，此次选择默认即可，回车确认 ? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? (Use arrow keys) \u0026gt; In dedicated config files In package.json # 需要将当前项目备份，为以后项目使用吗，此次选择 N ? Save this as a preset for future projects? (y/N) # 选择默认打包工具，如果没有此选项说明你只安装了一个打包工具 ? Pick the package manager to use when installing dependencies: (Use arrow keys) \u0026gt; Use Yarn Use NPM 简写：\nv-on:click\nv-on:click=\u0026#34;onClickSelf\u0026#34; 可以简写为： @click=\u0026#34;onClickSelf\u0026#34; v-bind:\nv-bind:title=\u0026#34;提示信息\u0026#34; 可以简写为： :title=\u0026#34;提示信息\u0026#34; ​\t组件点击事件\nApp.vue\n\u0026lt;Cell v-on:click=\u0026#34;console.log(1)\u0026#34; /\u0026gt; Cell.vue\n\u0026lt;!-- 当前组件被点击时, 在组件的事件中调用this.$emit(\u0026#39;click\u0026#39;) --\u0026gt; \u0026lt;template v-else\u0026gt; \u0026lt;div class=\u0026#34;circle\u0026#34; v-on:click=\u0026#34;onClickSelf\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { onClickSelf() { this.$emit(\u0026#34;click\u0026#34;); } } }; \u0026lt;/script\u0026gt; 部署 #  打包之前需要在项目根目录创建 vue.config.js 并且含以下内容\nmodule.exports = { publicPath: process.env.NODE_ENV === \u0026#39;production\u0026#39; ? \u0026#39;/my-project/\u0026#39; // 生产环境目录  : \u0026#39;/\u0026#39; // 开发环境目录 }  其中 my-project 就是你当前项目 dist 目录加 dist 目录上级目录总路径\n 然后将文件打包到 dist 目录\nyarn build\r具体参阅 Vue-cli 文档：部署 - Github Pages\n使用到的API #  Math.floor() #  Math.floor() 返回小于或等于一个给定数字的最大整数。\n Note: Math.floor() === 向下取整\n 就是取当前数的最小整数，例如：\nconsole.log(Math.floor(0.2)) // 打出 0 console.log(Math.floor(1.5)) // 打出 1 console.log(Math.floor(2.8)) // 打出 2 查看 MDN\nMDN 文档 - Math.floor()\n"});index.add({'id':85,'href':'/history/vuex%E4%BD%BF%E7%94%A8/','title':"Vuex 使用",'content':"安装 #  官方文档：Vuex 安装\n直接下载 #  https://unpkg.com/vuex\n引用 #  Unpkg.com 提供了基于 NPM 的 CDN 链接。以上的链接会一直指向 NPM 上发布的最新版本。您也可以通过 https://unpkg.com/vuex@2.0.0 这样的方式指定特定的版本。\n使用 Unpkg 引入最新版，( Vuex引入后会自动初始化 )：\n\u0026lt;script src=\u0026#34;https://unpkg.com/vue\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vuex\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; NPM #  npm install vuex --save 使用 #  官方文档：Vuex 使用\n最简单的 Store #   提示： 我们将在后续的文档示例代码中使用 ES2015 语法。如果你还没能掌握 ES2015，你得抓紧了！\n 安装 Vuex 之后，让我们来创建一个 store。创建过程直截了当——仅需要提供一个初始 state 对象和一些 mutation：\nconst store = new Vuex.Store({ state: { count: 10 }, mutations: { increment (state) { state.count++ } } }) store.commit(\u0026#39;increment\u0026#39;) /* 提交 count 的值就会加一 */ console.log(store.state.count) /* 打出11 */ State #  作用：主要用来获取数据\n代码\nhtml\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; JavaScript\nconst store = new Vuex.Store({ state: { count: 10, myName: \u0026#39;小明\u0026#39;, myEmail: \u0026#39;123456@qq.com\u0026#39; }, mutations: { increment(state) { state.count++ } } }) const Counter = { template: ` \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;编号：{{ count }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;姓名：{{ myName }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;邮箱：{{ myEmail }}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;add()\u0026#34;\u0026gt;编号+1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; `, computed: { count() { return this.$store.state.count }, myName() { return this.$store.state.myName }, myEmail() { return this.$store.state.myEmail }, }, methods: { add() { this.$store.commit(\u0026#39;increment\u0026#39;) } } } const app = new Vue({ el: \u0026#39;#app\u0026#39;, store, components: { Counter }, template: ` \u0026lt;div\u0026gt; \u0026lt;counter\u0026gt;\u0026lt;/counter\u0026gt; \u0026lt;/div\u0026gt; ` })  代码预览链接：https://jsbin.com/dunarom/edit?html,js,output\n 其中 Counter 对象的 computed 属性中的内容写成如下形式简写：\ncomputed: { ...Vuex.mapState([\u0026#39;count\u0026#39;, \u0026#39;myName\u0026#39;, \u0026#39;myEmail\u0026#39;]) }  代码预览链接：https://jsbin.com/dunarom/1/edit?html,js,output\n Getter #  作用：主要用来同步数据\n在 new Vuex.Store({}) 的参数中添加如下内容：\nconst store = new Vuex.Store({ state: { count: 10, myName: \u0026#39;小明\u0026#39;, myEmail: \u0026#39;123456@qq.com\u0026#39; }, mutations: { increment(state) { state.count++ }, modifyName(state, newName){ state.myName = newName } }, getters: { myData(state){ return \u0026#39;编号为 \u0026#39;+state.count+ \u0026#39; 的 \u0026#39; +state.myName + \u0026#39; 的邮箱是 \u0026#39; + state.myEmail } } }) 在 Counter 对象中的 computed 属性中添加如下内容\ncomputed: { myData(){ return this.$store.getters.myData }, ...Vuex.mapState([\u0026#39;count\u0026#39;, \u0026#39;myName\u0026#39;, \u0026#39;myEmail\u0026#39;]) } 上面的代码可以写成以下格式\ncomputed: { ...Vuex.mapState([\u0026#39;count\u0026#39;, \u0026#39;myName\u0026#39;, \u0026#39;myEmail\u0026#39;]), ...Vuex.mapGetters([\u0026#39;myData\u0026#39;]) } 在控制台 commit 数据，小明就会改为小红，如下\nstore.commit(\u0026#39;modifyName\u0026#39;, \u0026#39;小红\u0026#39;) 最终代码\n代码，预览链接\nMutation #  作用：主要用来修改数据\nMutation 的代码在 store 中就用到了\nmutations: { increment(state) { state.count++ } } "});index.add({'id':86,'href':'/docs/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E6%96%87%E7%AB%A0%E7%B2%BE%E9%80%89/','title':"《前端学习指南》文章精选",'content':"《前端学习指南》文章精选 #  不知不觉，我和若愚的知乎专栏《前端学习指南》已经开通三个月了。\n这个专栏一开始是饥人谷给学员的福利，将平时教学中，学生经常问的问题总结成文字，方便查阅。\n写着写着，发现大家很喜欢我们这种「接地气」的文章，有些同学从第一篇到现在，每篇都看。\n如果你是最近才关注我们，下面是过去三个月的精选文章，可以看看，都很不错，业界良心。\n如果你最近要面试前端岗位，那你看完这些文章，就抱到佛脚了。\n this 的值到底是什么？一次说清楚 JS 中的闭包是什么？ 独家前端书籍推荐 简述浏览器缓存是如何控制的 前端新手如何做简历 平时你从哪里获取前端知识？ 什么是立即执行函数 为什么 className 不要以 ad 开头？ JS 中的 Symbol 是什么？ cookie、session、localStorage分别是什么？有什么作用？ JSON 是什么？ AJAX 是什么？ CSRF 是什么？ 为什么不建议将 font-size 设置为 12px 以下？  如果觉得有用，请不要分享（这是个梗：有一次我写的是「请分享」，居然被人举报，说我诱导分享；后来知乎还真就把文章给封了。此后，我就只说「请不要分享」了，你说知乎气人不气人）。\n如果你看到不错的文章，欢迎投稿给我们。如果是英文，我们来翻译。\n欢迎进群与我探讨技术，暗号：前端/Java交流（附二维码）http://qr.jirengu.com/api/taskUrl?tid=56\n编辑于 2019-07-17\n  本文转自：https://zhuanlan.zhihu.com/p/23991042\n "});index.add({'id':87,'href':'/history/2020-02-03-%E5%8E%9F%E5%9E%8B%E9%93%BE%E8%A1%A5%E5%85%85/','title':"原型链补充",'content':"原型链原理补充\nvar obj = {} obj.toString() // 当obj.toString()时做了什么: window.Object.prototype.toString.call(obj) "});index.add({'id':88,'href':'/docs/%E5%A6%82%E4%BD%95%E5%9C%A8-js-%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%B6%88%E7%81%AD-for-%E5%BE%AA%E7%8E%AF/','title':"如何在 JS 代码中消灭 for 循环",'content':"如何在 JS 代码中消灭 for 循环 #  一，用好 filter，map，和其它 ES6 新增的高阶遍历函数 #  **问题一：**将数组中的 false值去除\nconst arrContainsEmptyVal = [3, 4, 5, 2, 3, undefined, null, 0, \u0026#34;\u0026#34;]; 答案：\nconst compact = arr =\u0026gt; arr.filter(Boolean); 问题二： 将数组中的 VIP 用户余额加 10\nconst users = [ { username: \u0026#34;Kelly\u0026#34;, isVIP: true, balance: 20 }, { username: \u0026#34;Tom\u0026#34;, isVIP: false, balance: 19 }, { username: \u0026#34;Stephanie\u0026#34;, isVIP: true, balance: 30 } ]; 答案：\nusers.map( user =\u0026gt;(user.isVIP ?{...user, balance: user.balance +10}: user)); 补充：经网友提醒，这个答案存在浅拷贝的问题。操作引用型数据确实是一个麻烦的问题。下面提供两个方案：\n1. 用 Ramda：\nimport R from \u0026#34;ramda\u0026#34;; const add10IfVIP = R.ifElse( R.propEq(\u0026#34;isVIP\u0026#34;, true), R.evolve({ balance: R.add(10) }), R.identity ); const updateUsers = R.map(add10IfVIP); updateUsers(users); 2. 用 Immer\n如果你习惯写 mutable 的代码，可以试下 Immer，用 mutable 的风格写 immutable 的代码。\nimport produce from \u0026#34;immer\u0026#34;; const updatedUsers = produce(users, nextState =\u0026gt; { nextState.forEach(user =\u0026gt; { if (user.isVIP) { user.balance += 10; } }); }); **问题三：**判断字符串中是否含有元音字母\nconst randomStr = \u0026#34;hdjrwqpi\u0026#34;; 答案：\nconst isVowel = char =\u0026gt; [\u0026#34;a\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;u\u0026#34;].includes(char); const containsVowel = str =\u0026gt; [...str].some(isVowel); containsVowel(randomStr); **问题四：**判断用户是否全部是成年人\nconst users = [ { name: \u0026#34;Jim\u0026#34;, age: 23 }, { name: \u0026#34;Lily\u0026#34;, age: 17 }, { name: \u0026#34;Will\u0026#34;, age: 25 } ]; 答案：\nusers.every(user =\u0026gt; user.age \u0026gt;= 18); 问题五： 找出上面用户中的第一个未成年人\n答案：\nconst findTeen = users =\u0026gt; users.find(user =\u0026gt; user.age \u0026lt; 18); findTeen(users); **问题六：**将数组中重复项清除\nconst dupArr = [1, 2, 3, 3, 3, 3, 6, 7]; 答案：\nconst uniq = arr =\u0026gt; [...new Set(arr)]; uniq(dupArr); 问题七： 生成由随机整数组成的数组，数组长度和元素大小可自定义\n答案：\nconst genNumArr = (length, limit) =\u0026gt; Array.from({ length }, _ =\u0026gt; Math.floor(Math.random() * limit)); genNumArr(10, 100); 二，理解和熟练使用 reduce #  问题八： 不借助原生高阶函数，定义 reduce\n答案：\nconst reduce = (f, acc, arr) =\u0026gt; { if (arr.length === 0) return acc; const [head, ...tail] = arr; return reduce(f, f(head, acc), tail); }; **问题九：**将多层数组转换成一层数组\nconst nestedArr = [1, 2, [3, 4, [5, 6]]]; 答案：\nconst flatten = arr =\u0026gt; arr.reduce( (flat, next) =\u0026gt; flat.concat(Array.isArray(next) ? flatten(next) : next), [] ); **问题十：**将下面数组转成对象，key/value 对应里层数组的两个值\nconst objLikeArr = [[\u0026#34;name\u0026#34;, \u0026#34;Jim\u0026#34;], [\u0026#34;age\u0026#34;, 18], [\u0026#34;single\u0026#34;, true]]; 答案：\nconst fromPairs = pairs =\u0026gt; pairs.reduce((res, pair) =\u0026gt; ((res[pair[0]] = pair[1]), res), {}); fromPairs(objLikeArr); **问题十一：**取出对象中的深层属性\nconst deepAttr = { a: { b: { c: 15 } } }; 答案：\nconst pluckDeep = path =\u0026gt; obj =\u0026gt; path.split(\u0026#34;.\u0026#34;).reduce((val, attr) =\u0026gt; val[attr], obj); pluckDeep(\u0026#34;a.b.c\u0026#34;)(deepAttr); **问题十二：**将用户中的男性和女性分别放到不同的数组里：\nconst users = [ { name: \u0026#34;Adam\u0026#34;, age: 30, sex: \u0026#34;male\u0026#34; }, { name: \u0026#34;Helen\u0026#34;, age: 27, sex: \u0026#34;female\u0026#34; }, { name: \u0026#34;Amy\u0026#34;, age: 25, sex: \u0026#34;female\u0026#34; }, { name: \u0026#34;Anthony\u0026#34;, age: 23, sex: \u0026#34;male\u0026#34; }, ]; 答案：\nconst partition = (arr, isValid) =\u0026gt; arr.reduce( ([pass, fail], elem) =\u0026gt; isValid(elem) ? [[...pass, elem], fail] : [pass, [...fail, elem]], [[], []], ); const isMale = person =\u0026gt; person.sex === \u0026#34;male\u0026#34;; const [maleUser, femaleUser] = partition(users, isMale); 问题十三： reduce 的计算过程，在范畴论里面叫 catamorphism，即一种连接的变形。和它相反的变形叫 anamorphism。现在我们定义一个和 reduce 计算过程相反的函数 unfold（注：reduce 在 Haskell 里面叫 fold，对应 unfold）\nconst unfold = (f, seed) =\u0026gt; { const go = (f, seed, acc) =\u0026gt; { const res = f(seed); return res ? go(f, res[1], acc.concat(res[0])) : acc; }; return go(f, seed, []); }; 根据这个 unfold 函数，定义一个 Python 里面的 range 函数。\n答案：\nconst range = (min, max, step = 1) =\u0026gt; unfold(x =\u0026gt; x \u0026lt; max \u0026amp;\u0026amp; [x, x + step], min); 三，用递归代替循环（可以break！） #   Edit: 虽然递归爆栈的问题可以用代码解决，但递归确实性能赶不上循环。这部分内容纯粹当做递归函数案例了。如何解决递归爆栈，可以参考我的另一篇文章不懂递归？读完这篇保证你懂\n 问题十四： 将两个数组每个元素一一对应相加。注意，第二个数组比第一个多出两个，不要把第二个数组遍历完。\nconst num1 = [3, 4, 5, 6, 7]; const num2 = [43, 23, 5, 67, 87, 3, 6]; 答案：\nconst zipWith = f =\u0026gt; xs =\u0026gt; ys =\u0026gt; { if (xs.length === 0 || ys.length === 0) return []; const [xHead, ...xTail] = xs; const [yHead, ...yTail] = ys; return [f(xHead)(yHead), ...zipWith(f)(xTail)(yTail)]; }; const add = x =\u0026gt; y =\u0026gt; x + y; zipWith(add)(num1)(num2); **问题十五：**将 Stark 家族成员提取出来。注意，目标数据在数组前面，使用 filter 方法遍历整个数组是浪费。\nconst houses = [ \u0026#34;Eddard Stark\u0026#34;, \u0026#34;Catelyn Stark\u0026#34;, \u0026#34;Rickard Stark\u0026#34;, \u0026#34;Brandon Stark\u0026#34;, \u0026#34;Rob Stark\u0026#34;, \u0026#34;Sansa Stark\u0026#34;, \u0026#34;Arya Stark\u0026#34;, \u0026#34;Bran Stark\u0026#34;, \u0026#34;Rickon Stark\u0026#34;, \u0026#34;Lyanna Stark\u0026#34;, \u0026#34;Tywin Lannister\u0026#34;, \u0026#34;Cersei Lannister\u0026#34;, \u0026#34;Jaime Lannister\u0026#34;, \u0026#34;Tyrion Lannister\u0026#34;, \u0026#34;Joffrey Baratheon\u0026#34; ]; 答案：\nconst takeWhile = f =\u0026gt; ([head, ...tail]) =\u0026gt; f(head) ? [head, ...takeWhile(f)(tail)] : []; const isStark = name =\u0026gt; name.toLowerCase().includes(\u0026#34;stark\u0026#34;); takeWhile(isStark)(houses); **问题十六：**找出数组中的奇数，然后取出前4个：\nconst numList = [1, 3, 11, 4, 2, 5, 6, 7]; 答案：\nconst takeFirst = (limit, f, arr) =\u0026gt; { if (limit === 0 || arr.length === 0) return []; const [head, ...tail] = arr; return f(head) ? [head, ...takeFirst(limit - 1, f, tail)] : takeFirst(limit, f, tail); }; const isOdd = n =\u0026gt; n % 2 === 1; takeFirst(4, isOdd, numList); 四，使用高阶函数遍历数组时可能遇到的陷阱 #  问题十七： 从长度为 100 万的随机整数组成的数组中取出偶数，再把所有数字乘以 3\n// 用我们刚刚定义的辅助函数来生成符合要求的数组 const bigArr = genNumArr(1e6, 100); 能运行的答案：\nconst isEven = num =\u0026gt; num % 2 === 0; const triple = num =\u0026gt; num * 3; bigArr.filter(isEven).map(triple); 注意，上面的解决方案将数组遍历了两次，无疑是浪费。如果写 for 循环，只用遍历一次：\nconst results = []; for (let i = 0; i \u0026lt; bigArr.length; i++) { if (isEven(bigArr[i])) { results.push(triple(bigArr[i])); } } 在我的电脑上测试，先 filter 再 map 的方法耗时 105.024 ms，而采用 for 循环的方法耗时仅 25.598 ms！那是否说明遇到此类情况必须用 for 循环解决呢? No！\n五，死磕到底，Transduce！\n我们先用 reduce 来定义 filter 和 map，至于为什么这样做等下再解释。\nconst filter = (f, arr) =\u0026gt; arr.reduce((acc, val) =\u0026gt; (f(val) \u0026amp;\u0026amp; acc.push(val), acc), []); const map = (f, arr) =\u0026gt; arr.reduce((acc, val) =\u0026gt; (acc.push(f(val)), acc), []); 重新定义的 filter 和 map 有共有的逻辑。我们把这部分共有的逻辑叫做 reducer。有了共有的逻辑后，我们可以进一步地抽象，把 reducer 抽离出来，然后传入 filter 和 map：\nconst filter = f =\u0026gt; reducer =\u0026gt; (acc, value) =\u0026gt; { if (f(value)) return reducer(acc, value); return acc; }; const map = f =\u0026gt; reducer =\u0026gt; (acc, value) =\u0026gt; reducer(acc, f(value)); 现在 filter 和 map 的函数 signature 一样，我们就可以进行函数组合（function composition）了。\nconst pushReducer = (acc, value) =\u0026gt; (acc.push(value), acc); bigNum.reduce(map(triple)(filter(isEven)(pushReducer)), []); 但是这样嵌套写法易读性太差，很容易出错。我们可以写一个工具函数来辅助函数组合：\nconst pipe = (...fns) =\u0026gt; (...args) =\u0026gt; fns.reduce((fx, fy) =\u0026gt; fy(fx), ...args); 然后我们就可以优雅地组合函数了：\nbigNum.reduce( pipe( filter(isEven), map(triple) )(pushReducer), [] ); 经过测试（用 console.time()/console.timeEnd()）,上面的写法耗时 33.898 ms，仅比 for 循环慢 8 ms。为了代码的易维护性和易读性，这点性能上的微小牺牲，我认为是可以接受的。\n这种写法叫 transduce。有很多工具库提供了 transducer 函数。比如 transducers-js。除了用 transducer 来遍历数组，还能用它来遍历对象和其它数据集。功能相当强大。\n六，for 循环和 for \u0026hellip; of 循环的区别\nfor \u0026hellip; of 循环是在 ES6 引入 Iterator 后，为了遍历 Iterable 数据类型才产生的。EcmaScript 的 Iterable 数据类型有数组，字符串，Set 和 Map。for \u0026hellip; of 循环属于重型的操作（具体细节我也没了解过），如果用 AirBNB 的 ESLint 规则，在代码中使用 for \u0026hellip; of 来遍历数组是会被禁止的。\n那么，for \u0026hellip; of 循环应该在哪些场景使用呢？目前我发现的合理使用场景是遍历自定义的 Iterable。来看这个题目：\n问题十八： 将 Stark 家族成员名字遍历，每次遍历暂停一秒，然后将当前遍历的名字打印来，遍历完后回到第一个元素再重新开始，无限循环。\nconst starks = [ \u0026#34;Eddard Stark\u0026#34;, \u0026#34;Catelyn Stark\u0026#34;, \u0026#34;Rickard Stark\u0026#34;, \u0026#34;Brandon Stark\u0026#34;, \u0026#34;Rob Stark\u0026#34;, \u0026#34;Sansa Stark\u0026#34;, \u0026#34;Arya Stark\u0026#34;, \u0026#34;Bran Stark\u0026#34;, \u0026#34;Rickon Stark\u0026#34;, \u0026#34;Lyanna Stark\u0026#34; ]; 答案：\nfunction* repeatedArr(arr) { let i = 0; while (true) { yield arr[i++ % arr.length]; } } const infiniteNameList = repeatedArr(starks); const wait = ms =\u0026gt; new Promise(resolve =\u0026gt; { setTimeout(() =\u0026gt; { resolve(); }, ms); }); (async () =\u0026gt; { for (const name of infiniteNameList) { await wait(1000); console.log(name); } })(); 七，放弃倔强，实在需要用 for 循环了\n前面讲到的问题基本覆盖了大部分需要使用 for 循环的场景。那是否我们可以保证永远不用 for 循环呢？其实不是。我讲了这么多，其实是在鼓励大家不要写 for 循环，而不是不用 for 循环。我们常用的数组原型链上的 map，filter 等高阶函数，底层其实是用 for 循环实现的。在需要写一些底层代码的时候，还是需要写 for 循环的。来看这个例子：\nNumber.prototype[Symbol.iterator] = function*() { for (let i = 0; i \u0026lt;= this; i++) { yield i; } }; [...6]; // [0, 1, 2, 3, 4, 5, 6] 注意，这个例子只是为了好玩。生产环境中不要直接修改 JS 内置数据类型的原型链。原因是 V8 引擎有一个原型链快速推测机制，修改原型链会破坏这个机制，造成性能问题。\n发布于 2018-12-04\n 本文转载自：https://zhuanlan.zhihu.com/p/51549583\n "});index.add({'id':89,'href':'/docs/%E5%B9%B3%E6%97%B6%E4%BD%A0%E4%BB%8E%E5%93%AA%E9%87%8C%E8%8E%B7%E5%8F%96%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/','title':"平时你从哪里获取前端知识？",'content':"平时你从哪里获取前端知识？ #  由于之前本文被和谐了，所以重发一篇。\n以下是我获取前端知识的网站：\n  用 MDN 查 JavaScript 和 CSS 基础知识\n  用维基百科查编程概念\n  用 Stackoverflow 查疑难杂症\n  用 http://Caniuse.com 查兼容性\n  用 Google 搜索\n   用「site:http://github.com 关键词」搜索好用的库 用「关键词 MDN」来搜索 MDN    用 http://jsfeeds.com 获取前端最新资讯（英文）\n  遇到牛人，我就会收藏到我的 GitHub\n  用 HackerNews 知道编程界最新动态\n  用知乎、微博了解国内前端界的动态\n  去 http://v2ex.com 水技术\n  尽量避开百度搜索\n  发布于 2016-10-09\n  本文转自：https://zhuanlan.zhihu.com/p/22836435?refer=study-fe\n "});index.add({'id':90,'href':'/docs/2020-04-18-%E6%88%91%E7%94%A8%E4%BA%86%E4%B8%A4%E4%B8%AA%E6%9C%88%E7%9A%84%E6%97%B6%E9%97%B4%E6%89%8D%E7%90%86%E8%A7%A3-let/','title':"我用了两个月的时间才理解 let",'content':"我用了两个月的时间才理解 let #  当然不是说用完整的两个月时间来理解 let，而是零零碎碎地理解，同时我还要想着怎么写出一篇文章把这个事情说清楚。\n在 let 刚出来的时候，我就「以为」我理解了 let。然鹅在过去的两个月里，我对 let 的理解发生了一波三折的变化。\n我写这篇文章，是希望我的学习过程，能对你自学有帮助。\n初识 let #  跟很多人一样，我第一次了解 let 的特性是从 MDN 的文档：\n我得到的信息有这么几条：\n let 声明的变量的作用域是块级的； let 不能重复声明已存在的变量； let 有暂时死区，不会被提升。  大部分人应该都是这么认为的，我也是这么理解的。\n这个理解「没有问题」，但是不够「全面和深刻」。\n第一次质疑 #  我第一次质疑我的理解是在遇到 for 循环的时候，代码如下。\n// 代码段1 var liList = document.querySelectorAll(\u0026#39;li\u0026#39;) // 共5个li for( var i=0; i\u0026lt;liList.length; i++){ liList[i].onclick = function(){ console.log(i) } } 大家都知道依次点击 li 会打印出 5 个 5。如果把 var i 改成 let i，就会分别打印出 0、1、2、3、4：\n// 代码段2 var liList = document.querySelectorAll(\u0026#39;li\u0026#39;) // 共5个li for( let i=0; i\u0026lt;liList.length; i++){ liList[i].onclick = function(){ console.log(i) } } 然而，用我之前的知识来理解这个代码是不能自圆其说的。因为代码中依然只声明了一个 i，在 for 循环结束后，i 的值还是会变成 5 才对。\n这说明我的理解有误。\n于是我去看 MDN 的例子，发现鸡贼的 MDN 巧妙地避开了这个问题，它的例子是这样的：\n你看 MDN 的例子，在每次循环的时候用 let j 保留的 i 的值，所以在 i 变化的时候，j 并不会变化。而console.log 的是 j，所以不会出现 5 个 5。\n为什么 MDN 要故意声明一个 j 呢，为什么不直接用 i 呢？\n我猜测 MDN 为了简化知识，隐瞒了什么。\n于是我去看了看 ES 文档，其中的 13.7.4.7 章节 清楚地说明了个中缘由，但是由于说得太清楚了，很多人都看不下去，不信你可以试试。\n我说一下我的理解：\n for( let i = 0; i\u0026lt; 5; i++) 这句话的圆括号之间，有一个隐藏的作用域 for( let i = 0; i\u0026lt; 5; i++) { 循环体 } 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。 其他细节就不说了，太细碎了  也就是说上面的代码段2可以近似近似近似地理解为\n// 代码段3 var liList = document.querySelectorAll(\u0026#39;li\u0026#39;) // 共5个li for( let i=0; i\u0026lt;liList.length; i++){ let i = 隐藏作用域中的i // 看这里看这里看这里  liList[i].onclick = function(){ console.log(i) } } 那样的话，5 次循环，就会有 5 个不同的 i，console.log 出来的 i 当然也是不同的值。\n再加上隐藏作用域里的 i，一共有 6 个 i。\n这就是 MDN 加那句 let j = i 的原因：方便新人理解。\n总得来说就是 let/const 在与 for 一起用时，会有一个 perIterationBindings 的概念（一种语法糖）。\n从此之后，我就开始怀疑我对 let 的所有理解了。\n第二次质疑 #  我在 StackOverflow 上闲逛的时候，无意中发现了一个是关于「let 到底有没有提升」的问题：\nAre variables declared with let or const not hoisted in ES6?\n其中一个高票回答认为 JS 中所有的声明（var/let/const/function/class），都存在提升，理由是如下代码：\nx = \u0026#34;global\u0026#34;; // function scope: (function() { x; // not \u0026#34;global\u0026#34;  var/let/… x; }()); // block scope (not for `var`s): { x; // not \u0026#34;global\u0026#34;  let/const/… x; } 我觉得他说得挺有道理的。于是我又去 MDN 和 ECMAScript 翻了翻，发现两处疑点：\n MDN 关于 let 是否存在提升的章节，被编辑了两次，第一次说存在提升，第二次说不存在提升（参考 2017 年 3 月 10 号的变更记录）。也就是说 MDN 的维护者都在这个问题上产生过分歧，更何况我们了。 ES 文档里出现了「var/let hoisting」字样。  鉴于此，我认为应该尊重 ES 文档，认为 let 确实存在提升。只不过由于暂时死区的限制，你不能在 let x 之前使用 let（详见我的那篇 let 声明会提升（hoist）吗？）。\n故事并没有结束 #  当一个疑问一直存在你脑中时，你会在潜意识中不停地对它进行消化和思考。\n上面说到我认为 let 存在提升的主要原因是 ES 文档中出现了「var/let hoisting」字样。\n但是我在咨询 TC39 的成员 Rick Waldron 时，他是这么说的：\n You\u0026rsquo;re misunderstanding the intention of that (non-normative) Note. let and const do not hoist as var and function decls do.\n 而且还细心地专门写了一个 gist 来详细解释（twitter 有 140 字限制）。\n既然 TC39 的 representative 都说了 let hoisting 不是一个正式词汇，那我就应该重新思考一下什么是「提升」了。\n于是就有了这篇文章，我想要说一下我对「提升」的理解。你看完之后，就知道 let 到底有没有「提升」。\n首先明确一点：提升不是一个技术名词。\n要搞清楚提升的本质，需要理解 JS 变量的「创建create、初始化initialize 和赋值assign」\n有的地方把创建说成是声明（declare），为了将这个概念与变量声明区别开，我故意不使用声明这个字眼。\n有的地方把初始化叫做绑定（binding），但我感觉这个词不如初始化形象。\n我们来看看 var 声明的「创建、初始化和赋值」过程\n假设有如下代码：\nfunction fn(){ var x = 1 var y = 2 } fn() 在执行 fn 时，会有以下过程（不完全）：\n 进入 fn，为 fn 创建一个环境。 找到 fn 中所有用 var 声明的变量，在这个环境中「创建」这些变量（即 x 和 y）。 将这些变量「初始化」为 undefined。 开始执行代码 x = 1 将 x 变量「赋值」为 1 y = 2 将 y 变量「赋值」为 2  也就是说 var 声明会在代码执行之前就将「创建变量，并将其初始化为 undefined」。\n这就解释了为什么在 var x = 1 之前 console.log(x) 会得到 undefined。\n接下来来看 function 声明的「创建、初始化和赋值」过程\n假设代码如下：\nfn2() function fn2(){ console.log(2) } JS 引擎会有一下过程：\n 找到所有用 function 声明的变量，在环境中「创建」这些变量。 将这些变量「初始化」并「赋值」为 function(){ console.log(2) }。 开始执行代码 fn2()  也就是说 function 声明会在代码执行之前就「创建、初始化并赋值」。\n接下来看 let 声明的「创建、初始化和赋值」过程\n假设代码如下：\n{ let x = 1 x = 2 } 我们只看 {} 里面的过程：\n 找到所有用 let 声明的变量，在环境中「创建」这些变量 开始执行代码（注意现在还没有初始化） 执行 x = 1，将 x 「初始化」为 1（这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined） 执行 x = 2，对 x 进行「赋值」  这就解释了为什么在 let x 之前使用 x 会报错：\nlet x = \u0026#39;global\u0026#39; { console.log(x) // Uncaught ReferenceError: x is not defined  let x = 1 } 原因有两个\n console.log(x) 中的 x 指的是下面的 x，而不是全局的 x 执行 log 时 x 还没「初始化」，所以不能使用（也就是所谓的暂时死区）  看到这里，你应该明白了 let 到底有没有提升：\n let 的「创建」过程被提升了，但是初始化没有提升。 var 的「创建」和「初始化」都被提升了。 function 的「创建」「初始化」和「赋值」都被提升了。  最后看 const，其实 const 和 let 只有一个区别，那就是 const 只有「创建」和「初始化」，没有「赋值」过程。\n这四种声明，用下图就可以快速理解：\n所谓暂时死区，就是不能在初始化之前，使用变量。\n完了吗？ #  故事依然没有结束，这周我在知乎上问了一个问题：如何理解 let x = x 报错之后，再次 let x 依然会报错？（这个问题是饥人谷的学生问我的）\n这个问题说明：如果 let x 的初始化过程失败了，那么\n x 变量就将永远处于 created 状态。 你无法再次对 x 进行初始化（初始化只有一次机会，而那次机会你失败了）。 由于 x 无法被初始化，所以 x 永远处在暂时死区（也就是盗梦空间里的 limbo）！ 有人会觉得 JS 坑，怎么能出现这种情况；其实问题不大，因为此时代码已经报错了，后面的代码想执行也没机会。  细节参见我的另一篇文章：JS变量封禁大法：薛定谔的X\n以上，就是一个 let 引发的思考。\n重要参考：JavaScript variables lifecycle: why let is not hoisted\n\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-分割线\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\n想要获取更多优质资源，我看知乎首页的微信号。\n 本文转载自：我用了两个月的时间才理解 let - 方应杭\n "});index.add({'id':91,'href':'/history/2020-05-07-%E6%95%B0%E7%BB%84/','title':"数组",'content':"Array.prototype\n.slice() #  数组浅拷贝\n.slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。\n语法\narr.slice([begin[, end]])  传入两个参数，第一个是数组起始序号，第二个是数组结束序号，返回的数组中包括起始序号，不包括结束序号\n 案例\nconst animals = [\u0026#39;ant\u0026#39;, \u0026#39;bison\u0026#39;, \u0026#39;camel\u0026#39;, \u0026#39;duck\u0026#39;, \u0026#39;elephant\u0026#39;]; console.log(animals.slice(2)); // expected output: Array [\u0026#34;camel\u0026#34;, \u0026#34;duck\u0026#34;, \u0026#34;elephant\u0026#34;]  console.log(animals.slice(2, 4)); // expected output: Array [\u0026#34;camel\u0026#34;, \u0026#34;duck\u0026#34;]  console.log(animals.slice(1, 5)); // expected output: Array [\u0026#34;bison\u0026#34;, \u0026#34;camel\u0026#34;, \u0026#34;duck\u0026#34;, \u0026#34;elephant\u0026#34;] 伪数组 #  只有数组的样子，但没有数组的方法(如：.push等)。原型链直接指向对象\n伪数组转化为数组 #  例如，将函数中的 arguments 伪数组转化为数组：\nES5写法\nlet args = Array.prototype.slice.call(arguments) ES6写法\nlet args = Array.from(arguments) // 使用API let args = [...arguments] // 使用剩余参数法 完整案例\n根据传入参数相加，返回参数相加的总和\nfunction sum(){ let args = [...arguments] // ES6语法  let numbers = args.slice(0) return numbers } console.log(sum(1, 2, 3, 4, 5)) .reduce() #  reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。\n案例\n数组累加\n当传入一个参数时，第一次执行将数组的第一项作为执行函数的第一个参数传入，第二项作为第二个参数传入，每次函数执行都会返回上两个数组之间的计算结果，作为下一次函数执行的第一个参数\nconst array1 = [\u0026#39;K\u0026#39;, 2, \u0026#39;P\u0026#39;, 4]; const reducer = (accumulator, currentValue) =\u0026gt; { console.log(\u0026#39;accumulator：\u0026#39; + accumulator) console.log(\u0026#39;currentValue：\u0026#39; + currentValue) console.log(\u0026#39;=========\u0026#39;) return accumulator + currentValue }; // \u0026#39;K\u0026#39; + 2 + \u0026#39;P\u0026#39; + 4 console.log(array1.reduce(reducer)); /* 输出: accumulator：K currentValue：2 ========= accumulator：K2 currentValue：P ========= accumulator：K2P currentValue：4 ========= K2P4 */ 当传入两个参数时，第一次执行将 .reduce() 第二个参数作为执行函数的第一个参数传入，之后每次函数执行都会返回上两个数组之间的计算结果，作为下一次函数执行的第一个参数\nconst array1 = [\u0026#39;K\u0026#39;, 2, \u0026#39;P\u0026#39;, 4]; const reducer = (accumulator, currentValue) =\u0026gt; { console.log(\u0026#39;accumulator：\u0026#39; + accumulator) console.log(\u0026#39;currentValue：\u0026#39; + currentValue) console.log(\u0026#39;=========\u0026#39;) return accumulator + currentValue }; // \u0026#39;K\u0026#39; + 2 + \u0026#39;P\u0026#39; + 4 console.log(array1.reduce(reducer, 5)); /* 输出: accumulator：5 currentValue：K ========= accumulator：5K currentValue：2 ========= accumulator：5K2 currentValue：P ========= accumulator：5K2P currentValue：4 ========= 5K2P4 */ "});index.add({'id':92,'href':'/docs/2020-02-08-%E7%9F%A5%E8%AF%86%E7%9A%84%E8%AF%85%E5%92%92/','title':"知识的诅咒",'content':"知识的诅咒 #    含义：一种认知偏差，形容专家常以术语交谈，但丧失与非专业人士的沟通的能力\n  如何破除\n尽量不使用专业术语来解释专业术语\n多让旁人指出他不懂的地方\n  "});index.add({'id':93,'href':'/history/2020-04-27-%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%AE%80%E5%8E%86%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B/','title':"简历该怎么写",'content':"就业：简历该怎么写\n一个完整的简历制作过程 #  《在线简历制作》\n饥人谷优秀简历展示 #  进了今日头条的简历 https://kylewh.github.io/Resume/index.html 另一个简历 https://adashuai5.github.io/resume/ 虽然很多人条件没有他的好，但是这个简历的态度非常认真，各方面细节都打磨得非常好，值得学习。\n简历应该怎么写？ #  参考文章\n 从培训班出来之后找工作的经历，教会了我这五件事 一个炫酷的简历模板 互联网公司招聘启事的正确阅读方式 面试词典：什么叫精通？什么叫熟悉？什么叫了解？ 平时你从哪里获取前端知识？ 如果中国前端已经一半海水了，那么 Java、iOS 和安卓就…… 更多文章请看我的知乎问答  目的 #  展示自己的优点。\n内容 #    基本信息\n 年龄、姓名、性别、目标职位（文件名里写，方方-应聘前端工程师.pdf）、学校 联系方式（PDF可以写手机，网页版不要写手机，搜索引擎会搜到）：手机、邮箱、QQ、微信    技能描述\n 小程序制作 ★★ 可以独立进行小程序开发，熟悉AAAA、BBB、CCCC相关API或组件的使用。 Vue ★★★★★ 熟悉 Vue 常用功能，如组件、Vue-Router、双向绑定等。 jQuery ★★★★★ 熟悉 jQuery 的常用 API，能使用 jQuery 制作网站、轮播、Tab 组件等。 HTML 5 \u0026amp; CSS 3 ★★★★★ 能独立制作精美网页，掌握 CSS 3 动画、过渡效果、响应式等常用技术。 移动端页面 ★★★★ 会使用 REM、vw/vh、FastClick 等技术制作适配手机设备的页面。 前端框架 ★★★ 理解 MVC、MVVM 等思想，可以熟练使用相关的库，如 Vue、React    教育经历 必须写\n  工作经历\n有就写\n 经历如果跟编程无关，就简单描述，加一句自学前端半年。\r经历跟前端有关，就说技术名称，如 Java、Linux命令行、HTTP，自学前端半年。 没有就不写，刚毕业，自学前端半年。\n实习经历也算。\n  项目展示\n 数量：6~8个，给我看，给你删两个。 举例：  画板  源码链接 预览链接（手机预览给二维码 https://cli.im）/) 关键词：原生 JavaScript、Canvas、响应式、jQuery、Vue 描述：该项目使用原生JS实现，主要调用 Canvas API，实现了划线、调色、橡皮擦、保存等功能。完全由我独立开发。用 XXX 实现了 XXX 功能，用 XXX 实现了 XXX 功能。   简历生成器  源码链接 预览链接 关键词：Vue、原生 JS、Vue-Router、响应式、webpack、SASS、Babel、vue-cli 描述：该项目使用 Vue 实现了一个可编辑简历的工具，该工具可以在线修改简历、分享简历、换主题等。这是我通过两周的学习，实现的第一个 Vue 项目，目前已经发布上线。我用 Vue-Router 实现了路由功能，使用 webpack 打包代码……     要配截图，一图胜千言 种类：  手机页面 框架（Vue、React） CSS 3（皮卡丘） 原生 JS、jQuery（网易云音乐） Node.js 命令行 小程序、React、echarts.js   项目只要好看，就是好项目。只要不好看就会扣分。 给面试官看的东西，不要有明显的缺点。 如果是在线网页，网页里的图片大小全部都不能超过 300kb    链接：博客链接、GitHub链接\n 博客：至少有8篇 GitHub：要有点绿再给面试官看 你翻译的文章链接 你在 MDN 上贡献的编辑    其他\n 得奖 英语四六级 计算等级考试 其他可能有两点的东西    投递 #  拉勾基本可以放弃了，全是「不匹配」。 BOSS直聘app，如果没有技术面试，就别去。\n智联招聘、前程无忧、大街网等基本在一线城市不用看。\n 去拉勾、boss看公司，薪水下限低于9k的你都可以尝试。 一线城市9k以下你就投，二线城市7k以下你就投，三线城市5.5k以下就投 去搜公司的官网 在官网找「加入我们」「招聘」字样 一定要看我的文章：https://zhuanlan.zhihu.com/p/24146797  微博搜「前端招聘」微信搜「杭州 前端」点击找人，也可以用推特搜\nv2ex.com 万不得已再使用，需要简历有两点（项目很美）\n直接上门。\n 打印30份简历。 去当地软件园、高新区问是否招人。（提前在百度地图查看、智联或拉勾招聘查本地软件园有哪些公司在招聘）  简历制作 #   假想面试官刚吃完早饭，30分钟后去开会，现在要看10份简历，你的简历是否能脱颖而出，是否有亮点，没有亮点是否有美图。 把所有学过的东西随意组合（不要自己设计），让自己的简历跟同学的不一样。  《在线简历制作》\n"});index.add({'id':94,'href':'/history/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8/','title':"计算属性和监听器",'content':"基础例子 #  \u0026lt;div id=\u0026#34;example\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Original message: \u0026#34;{{ message }}\u0026#34;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Computed reversed message: \u0026#34;{{ reversedMessage }}\u0026#34;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; JS\nvar vm = new Vue({ el: \u0026#39;#example\u0026#39;, data: { message: \u0026#39;Hello\u0026#39; }, computed: { // 计算属性的 getter  reversedMessage: function () { // `this` 指向 vm 实例  return this.message.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;) } } }) "});})();